<!doctype html><html lang="fr"><meta charset="utf-8"><title>FAQ des Hooks</title><meta name="viewport"content="width=device-width,initial-scale=1"><link rel="stylesheet"href="../../../../../../../../docs/themes/packages/prism-coy-theme/theme_common.css"><section id="faq-des-hooks"class="level1"><h1>FAQ des Hooks</h1><p>Les <em>Hooks</em> sont une nouveautÃ© de React 16.8. Ils permettent de bÃ©nÃ©ficier dâ€™un Ã©tat local et d'autres fonctionnalitÃ©s de React sans avoir Ã  Ã©crire de classes.<p>Cette page contient les rÃ©ponses aux questions les plus frÃ©quentes sur les <a href="./hooks-overview.html">Hooks</a>.<ul><li><strong><a href="#adoption-strategy">StratÃ©gie d'adoption</a></strong><ul><li><a href="#which-versions-of-react-include-hooks">Quelles versions de React incluent les HooksÂ ?</a><li><a href="#do-i-need-to-rewrite-all-my-class-components">Dois-je rÃ©Ã©crire tous mes composants Ã  base de classeÂ ?</a><li><a href="#what-can-i-do-with-hooks-that-i-couldnt-with-classes">Que puis-je faire avec les Hooks qu'il est impossible de faire avec des classesÂ ?</a><li><a href="#how-much-of-my-react-knowledge-stays-relevant">Quelle proportion de mes connaissances en React reste pertinenteÂ ?</a><li><a href="#should-i-use-hooks-classes-or-a-mix-of-both">Dois-je utiliser des Hooks, des classes ou un mÃ©lange des deuxÂ ?</a><li><a href="#do-hooks-cover-all-use-cases-for-classes">Est-ce que les Hooks couvrent tous les cas d'utilisation des classesÂ ?</a><li><a href="#do-hooks-replace-render-props-and-higher-order-components">Est-ce que les Hooks remplacent les props de rendu et les composants d'ordre supÃ©rieurÂ ?</a><li><a href="#what-do-hooks-mean-for-popular-apis-like-redux-connect-and-react-router">Qu'est-ce que les Hooks changent pour les API populaires telles que Redux <code>connect()</code> et React RouterÂ ?</a><li><a href="#do-hooks-work-with-static-typing">Est-ce que les Hooks sont compatibles avec le typage statiqueÂ ?</a><li><a href="#how-to-test-components-that-use-hooks">Comment tester des composants utilisant des HooksÂ ?</a><li><a href="#what-exactly-do-the-lint-rules-enforce">Qu'est-ce que les rÃ¨gles de linting imposentÂ ?</a></ul><li><strong><a href="#from-classes-to-hooks">Des classes aux Hooks</a></strong><ul><li><a href="#how-do-lifecycle-methods-correspond-to-hooks">Quelles sont les correspondances entre les mÃ©thodes de cycle de vie et les HooksÂ ?</a><li><a href="#how-can-i-do-data-fetching-with-hooks">Comment charger des donnÃ©es distantes avec les HooksÂ ?</a><li><a href="#is-there-something-like-instance-variables">Existe-t-il un Ã©quivalent aux variables d'instancesÂ ?</a><li><a href="#should-i-use-one-or-many-state-variables">Dois-je utiliser une ou plusieurs variables d'Ã©tat localÂ ?</a><li><a href="#can-i-run-an-effect-only-on-updates">Puis-je exÃ©cuter un effet seulement lors des mises Ã  jourÂ ?</a><li><a href="#how-to-get-the-previous-props-or-state">Comment rÃ©cupÃ©rer les props ou l'Ã©tat local prÃ©cÃ©dentsÂ ?</a><li><a href="#why-am-i-seeing-stale-props-or-state-inside-my-function">Pourquoi vois-je des props ou un Ã©tat local obsolÃ¨tes dans ma fonctionÂ ?</a><li><a href="#how-do-i-implement-getderivedstatefromprops">Comment puis-je implÃ©menter <code>getDerivedStateFromProps</code>Â ?</a><li><a href="#is-there-something-like-forceupdate">Existe-t-il un Ã©quivalent Ã  <code>forceUpdate</code>Â ?</a><li><a href="#can-i-make-a-ref-to-a-function-component">Puis-je crÃ©er une ref vers une fonction composantÂ ?</a><li><a href="#how-can-i-measure-a-dom-node">Comment puis-je mesurer un nÅ“ud DOMÂ ?</a><li><a href="#what-does-const-thing-setthing--usestate-mean">Que signifie <code>const [thing, setThing] = useState()</code>Â ?</a></ul><li><strong><a href="#performance-optimizations">Optimisations des performances</a></strong><ul><li><a href="#can-i-skip-an-effect-on-updates">Puis-je sauter un effet lors des mises Ã  jourÂ ?</a><li><a href="#is-it-safe-to-omit-functions-from-the-list-of-dependencies">Est-il acceptable dâ€™omettre les fonctions du tableau de dÃ©pendancesÂ ?</a><li><a href="#what-can-i-do-if-my-effect-dependencies-change-too-often">Que faire quand mes dÃ©pendances dâ€™effet changent trop souventÂ ?</a><li><a href="#how-do-i-implement-shouldcomponentupdate">Comment puis-je implÃ©menter <code>shouldComponentUpdate</code>Â ?</a><li><a href="#how-to-memoize-calculations">Comment mÃ©moÃ¯ser les calculsÂ ?</a><li><a href="#how-to-create-expensive-objects-lazily">Comment crÃ©er paresseusement des objets coÃ»teuxÂ ?</a><li><a href="#are-hooks-slow-because-of-creating-functions-in-render">La crÃ©ation de fonctions Ã  la volÃ©e pendant le rendu ralentit-elle les HooksÂ ?</a><li><a href="#how-to-avoid-passing-callbacks-down">Comment Ã©viter de transmettre des fonctions de rappelÂ ?</a><li><a href="#how-to-read-an-often-changing-value-from-usecallback">Comment lire une valeur changeant frÃ©quemment avec <code>useCallback</code>Â ?</a></ul><li><strong><a href="#under-the-hood">Sous le capot</a></strong><ul><li><a href="#how-does-react-associate-hook-calls-with-components">Comment React associe-t-il les appels de Hooks avec les composantsÂ ?</a><li><a href="#what-is-the-prior-art-for-hooks">Quelles sont les sources d'inspiration des HooksÂ ?</a></ul></ul><section id="adoption-strategy"class="level2"><h2>StratÃ©gie d'adoption</h2><section id="which-versions-of-react-include-hooks"class="level3"><h3>Quelles versions de React incluent les HooksÂ ?</h3><p>Depuis la version 16.8.0, React embarque une implÃ©mentation stable de React Hooks pourÂ :<ul><li>React DOM<li>React Native<li>React DOM Server<li>Le moteur de rendu de test de React<li>Le moteur de rendu superficiel de React</ul><p>Remarquez que <strong>pour activer les Hooks, tous les paquets React doivent Ãªtre en version 16.8.0 ou supÃ©rieure</strong>. Les Hooks ne fonctionneront pas si vous oubliez de mettre Ã  jour React DOM, par exemple.<p><a href="https://reactnative.dev/blog/2019/03/12/releasing-react-native-059">React Native 0.59</a> et ultÃ©rieurs prennent en charge les Hooks.</section><section id="do-i-need-to-rewrite-all-my-class-components"class="level3"><h3>Dois-je rÃ©Ã©crire tous mes composants Ã  base de classeÂ ?</h3><p>Non. Il n'est <a href="./hooks-intro.html#gradual-adoption-strategy">pas prÃ©vu</a> de retirer les classes de ReactÂ : nous avons tous besoin de continuer Ã  livrer nos produits et ne pouvons pas nous permettre de rÃ©Ã©crire tout le code. Nous recommandons d'essayer les Hooks dans de nouveaux composants et projets.</section><section id="what-can-i-do-with-hooks-that-i-couldnt-with-classes"class="level3"><h3>Que puis-je faire avec les Hooks qu'il est impossible de faire avec des classesÂ ?</h3><p>Les Hooks offrent un nouveau moyen puissant et expressif de rÃ©utiliser des fonctionnalitÃ©s entre composants. <a href="./hooks-custom.html">Â«Â Contruire vos propres HooksÂ Â»</a> offre un aperÃ§u des possibilitÃ©s. <a href="https://medium.com/@dan_abramov/making-sense-of-react-hooks-fdbde8803889">Cet article</a> (en anglais) Ã©crit par un membre de l'Ã©quipe noyau de React explore plus en dÃ©tail les nouvelles possibilitÃ©s apportÃ©es par les Hooks.</section><section id="how-much-of-my-react-knowledge-stays-relevant"class="level3"><h3>Quelle proportion de mes connaissances en React reste pertinenteÂ ?</h3><p>Les Hooks sont un moyen plus direct d'utiliser les fonctionnalitÃ©s de React que vous connaissez dÃ©jÃ , telles que lâ€™Ã©tat local, le cycle de vie, le contexte et les refs. Ils ne changent pas fondamentalement la faÃ§on dont React fonctionne, et vos connaissances des composants, des props, et du flux de donnÃ©es descendant sont toujours valides.<p>Les Hooks ont tout de mÃªme une courbe d'apprentissage. Si quelque chose manque dans leur documentation, <a href="https://github.com/reactjs/reactjs.org/issues/new">crÃ©ez un ticket</a> sur le dÃ©pÃ´t GitHub et nous essaierons de vous aider.</section><section id="should-i-use-hooks-classes-or-a-mix-of-both"class="level3"><h3>Dois-je utiliser des Hooks, des classes ou un mÃ©lange des deuxÂ ?</h3><p>Quand vous serez prÃªtÂ·e, nous vous conseillons de commencer Ã  essayer les Hooks dans les nouveaux composants que vous Ã©crirez. Assurez-vous que chaque membre de votre Ã©quipe soit partantÂ·e pour les utiliser, et Ã  lâ€™aise avec cette documentation. Nous dÃ©conseillons de rÃ©Ã©crire vos classes existantes avec les Hooks, sauf si vous aviez dÃ©jÃ  prÃ©vu de les rÃ©Ã©crire de toute faÃ§on (ex. pour corriger des bugs).<p>Vous ne pouvez pas utiliser les Hooks <em>Ã  l'intÃ©rieur</em> d'un composant Ã  base de classe, mais vous pouvez complÃ¨tement mÃ©langer classes et fonctions composants utilisant des Hooks dans une mÃªme arborescence. Qu'un composant soit une classe ou une fonction utilisant les Hooks ne constitue quâ€™un dÃ©tail d'implÃ©mentation de ce composant. Sur le long terme, nous nous attendons Ã  ce que lâ€™essentiel des composants React soient Ã©crits Ã  base de Hooks.</section><section id="do-hooks-cover-all-use-cases-for-classes"class="level3"><h3>Est-ce que les Hooks couvrent tous les cas d'utilisation des classesÂ ?</h3><p>Notre but est que les Hooks couvrent tous les cas d'utilisation des classes dÃ¨s que possible. Il nâ€™existe pas pour l'instant d'Ã©quivalent en Hook pour les mÃ©thodes de cycle de vie moins courantes que sont <code>getSnapshotBeforeUpdate</code>, <code>getDerivedStateFromError</code> et <code>componentDidCatch</code>, mais nous prÃ©voyons de les ajouter rapidement.<p>Les Hooks en sont encore Ã  leur dÃ©buts, et quelques bibliothÃ¨ques tierces peuvent ne pas Ãªtre compatibles avec les Hooks Ã  l'heure actuelle.</section><section id="do-hooks-replace-render-props-and-higher-order-components"class="level3"><h3>Est-ce que les Hooks remplacent les props de rendu et les composants d'ordre supÃ©rieurÂ ?</h3><p>Souvent, les props de rendu et les composants d'ordre supÃ©rieur nâ€™affichent quâ€™un seul enfant. Nous pensons que les Hooks simplifient ce cas d'utilisation. Ces deux approches restent pertinentes (par exemple, un composant de dÃ©filement virtuel pourrait avoir une prop <code>renderItem</code>, ou un composant de conteneur visuel pourrait avoir sa propre structure DOM). Mais dans la plupart des cas, les Hooks seront suffisants et pourront aider Ã  rÃ©duire l'imbrication dans votre arborescence de composants.</section><section id="what-do-hooks-mean-for-popular-apis-like-redux-connect-and-react-router"class="level3"><h3>Qu'est-ce que les Hooks changent pour les API populaires telles que Redux <code>connect()</code> et React RouterÂ ?</h3><p>Vous pouvez continuer Ã  utiliser les mÃªmes API que d'habitudeÂ ; elles fonctionneront toujours comme avant.<p>Depuis sa version v7.1.0, React-Redux <a href="https://react-redux.js.org/api/hooks">prend en charge l'API des Hooks</a> et fournit des Hooks tels que <code>useDispatch</code> et <code>useSelector</code>.<p>React Router <a href="https://reacttraining.com/react-router/web/api/Hooks">prend en charge les Hooks</a> depuis sa v5.1.<p>Dâ€™autres bibliothÃ¨ques pourront prendre en charge les Hooks Ã  lâ€™avenir.</section><section id="do-hooks-work-with-static-typing"class="level3"><h3>Est-ce que les Hooks sont compatibles avec le typage statiqueÂ ?</h3><p>Les Hooks ont Ã©tÃ© conÃ§us avec le typage statique Ã  l'esprit. Comme ce sont des fonctions, il est plus facile de les typer correctement que d'autres approches telles que les composants d'ordre supÃ©rieur. Les derniÃ¨res dÃ©finitions Flow et TypeScript pour React prennent en charge les Hooks React.<p>Surtout, les Hooks personnalisÃ©s vous donnent la possibilitÃ© de restreindre l'API React si vous souhaitez les typer de faÃ§on plus stricte. React vous fournit des primitives, mais vous pouvez les combiner de faÃ§ons diffÃ©rentes de celles que nous fournissons d'entrÃ©e de jeu.</section><section id="how-to-test-components-that-use-hooks"class="level3"><h3>Comment tester des composants utilisant des HooksÂ ?</h3><p>Du point de vue de React, un composant utilisant des Hooks est un composant normal. Si votre solution de test ne repose pas sur des fonctionnements internes de React, tester des composants avec des Hooks ne devrait pas Ãªtre diffÃ©rent de la faÃ§on dont vous testez vos composants habituellement.<blockquote><p>Note<p><a href="./testing-recipes.html">Testing Recipes</a> inclut plusieurs exemples que vous pouvez copier-coller.</blockquote><p>Par exemple, prenons ce composant de comptageÂ :<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Example</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>count<span class="token punctuation">,</span> setCount<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
    <span class="token dom variable">document</span><span class="token punctuation">.</span><span class="token property-access">title</span> <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Vous avez cliquÃ© </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>count<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> fois</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword control-flow">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&#x3C;</span>div<span class="token operator">></span>
      <span class="token operator">&#x3C;</span>p<span class="token operator">></span><span class="token maybe-class-name">Vous</span> avez cliquÃ© <span class="token punctuation">{</span>count<span class="token punctuation">}</span> fois<span class="token operator">&#x3C;</span><span class="token operator">/</span>p<span class="token operator">></span>
      <span class="token operator">&#x3C;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token function">setCount</span><span class="token punctuation">(</span>count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token operator">></span>
        <span class="token maybe-class-name">Cliquez</span> ici
      <span class="token operator">&#x3C;</span><span class="token operator">/</span>button<span class="token operator">></span>
    <span class="token operator">&#x3C;</span><span class="token operator">/</span>div<span class="token operator">></span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>Nous le testerons en utilisant React DOM. Pour Ãªtre certains que le comportement correspond Ã  ce qui se passerait dans le navigateur, nous enroberons le code d'affichage et de mise Ã  jour par des appels Ã  <a href="./test-utils.html#act"><code>ReactTestUtils.act()</code></a>Â :<pre class="language-js{3,20-22,29-31}"><code class="language-js{3,20-22,29-31}">import React from 'react';
import ReactDOM from 'react-dom';
import { act } from 'react-dom/test-utils';
import Counter from './Counter';

let container;

beforeEach(() => {
  container = document.createElement('div');
  document.body.appendChild(container);
});

afterEach(() => {
  document.body.removeChild(container);
  container = null;
});

it('can render and update a counter', () => {
  // Test du premier rendu et de son effet
  act(() => {
    ReactDOM.render(&#x3C;Counter />, container);
  });
  const button = container.querySelector('button');
  const label = container.querySelector('p');
  expect(label.textContent).toBe('Vous avez cliquÃ© 0 fois');
  expect(document.title).toBe('Vous avez cliquÃ© 0 fois');

  // Test du second rendu et de son effet
  act(() => {
    button.dispatchEvent(new MouseEvent('click', {bubbles: true}));
  });
  expect(label.textContent).toBe('Vous avez cliquÃ© 1 fois');
  expect(document.title).toBe('Vous avez cliquÃ© 1 fois');
});</code></pre><p>Les appels Ã  <code>act()</code> vont aussi traiter les effets qu'ils contiennent.<p>Si vous souhaitez tester un Hook personnalisÃ©, c'est possible en crÃ©ant un composant dans votre test, et en utilisant le Hook depuis celui-ci. Vous pourrez alors tester le composant que vous venez de crÃ©er.<p>Pour rÃ©duire le code gÃ©nÃ©rique, nous vous conseillons d'utiliser <a href="https://testing-library.com/react">React Testing Library</a> qui est conÃ§u de maniÃ¨re Ã  encourager l'Ã©criture de tests utilisant les composants comme le feraient les utilisateurs finaux.<p>Pour plus d'information, consultez <a href="./testing-recipes.html">Testing Recipes</a>.</section><section id="what-exactly-do-the-lint-rules-enforce"class="level3"><h3>Qu'est-ce que les <a href="https://www.npmjs.com/package/eslint-plugin-react-hooks">rÃ¨gles de linting</a> imposentÂ ?</h3><p>Nous mettons Ã  disposition un <a href="https://www.npmjs.com/package/eslint-plugin-react-hooks">plugin ESlint</a> qui impose <a href="./hooks-rules.html">les rÃ¨gles des Hooks</a> pour Ã©viter les bugs. Il part du principe que toute fonction commenÃ§ant par "<code>use</code>" suivi d'une lettre majuscule est un Hook. Nous admettons que cette heuristique n'est pas parfaite et peut dÃ©clencher des faux positifs, mais sans convention au niveau de l'Ã©cosystÃ¨me, il n'existe aucun moyen de faire fonctionner les Hooks correctementâ€”et des noms plus longs dÃ©courageront l'adoption des Hooks ou le respect des conventions par la communautÃ©.<p>En particulier, la rÃ¨gle impose queÂ :<ul><li>Les appels de Hooks soient situÃ©s soit Ã  l'intÃ©rieur d'une fonction nommÃ©e en casse <code>PascalCase</code> (supposÃ©e Ãªtre un composant) ou d'une autre fonction <code>useSomething</code> (supposÃ©e Ãªtre un Hook personnalisÃ©).<li>Les Hooks soient appelÃ©s dans le mÃªme ordre Ã  chaque rendu.</ul><p>Il existe quelques autres heuristiques, et elles changeront peut-Ãªtre avec le temps, au fur et Ã  mesure que nous peaufinons la rÃ¨gle pour amÃ©liorer la dÃ©couverte de bugs tout en Ã©vitant les faux positifs.</section></section><section id="from-classes-to-hooks"class="level2"><h2>Des classes aux Hooks</h2><section id="how-do-lifecycle-methods-correspond-to-hooks"class="level3"><h3>Quelles sont les correspondances entre les mÃ©thodes de cycle de vie et les HooksÂ ?</h3><ul><li><code>constructor</code>Â : les fonctions composants n'ont pas besoin d'un constructeur. Vous pouvez initialiser l'Ã©tat local lors de l'appel Ã  <a href="./hooks-reference.html#usestate"><code>useState</code></a>. Si le calcul de l'Ã©tat local initial est trop coÃ»teux, vous pouvez passer une fonction Ã  <code>useState</code>.<li><code>getDerivedStateFromProps</code>Â : planifiez plutÃ´t une mise Ã  jour <a href="#how-do-i-implement-getderivedstatefromprops">pendant le rendu</a>.<li><code>shouldComponentUpdate</code>Â : voyez <code>React.memo</code> <a href="#how-do-i-implement-shouldcomponentupdate">ci-dessous</a>.<li><code>render</code>Â : c'est le corps-mÃªme de la fonction composant.<li><code>componentDidMount</code>, <code>componentDidUpdate</code>, <code>componentWillUnmount</code>Â : le <a href="./hooks-reference.html#useeffect">Hook <code>useEffect</code></a> peut exprimer toutes les combinaisons de celles-ci (y compris des cas <a href="#can-i-skip-an-effect-on-updates">moins</a> <a href="#can-i-run-an-effect-only-on-updates">frÃ©quents</a>).<li><code>getSnapshotBeforeUpdate</code>, <code>componentDidCatch</code> et <code>getDerivedStateFromError</code>Â : il n'existe pas encore de Hook Ã©quivalent pour ces mÃ©thodes, mais ils seront ajoutÃ©s prochainement.</ul></section><section id="how-can-i-do-data-fetching-with-hooks"class="level3"><h3>Comment charger des donnÃ©es distantes avec les HooksÂ ?</h3><p>Voici une <a href="https://codesandbox.io/s/jvvkoo8pq3">petite dÃ©mo</a> pour vous aider Ã  dÃ©marrer. Pour en apprendre davantage, jetez un Å“il Ã  <a href="https://www.robinwieruch.de/react-hooks-fetch-data/">cet article</a> (en anglais) sur le chargement de donnÃ©es distantes avec les Hooks.</section><section id="is-there-something-like-instance-variables"class="level3"><h3>Existe-t-il un Ã©quivalent aux variables d'instancesÂ ?</h3><p>OuiÂ ! Le Hook <a href="./hooks-reference.html#useref"><code>useRef()</code></a> n'est pas seulement pour les refs au DOM. L'objet "ref" est un conteneur gÃ©nÃ©rique dont la propriÃ©tÃ© <code>current</code> est modifiable et peut contenir n'importe quelle valeur, de la mÃªme faÃ§on qu'une propriÃ©tÃ© d'instance dans une classe.<p>Vous pouvez lui affecter une valeur depuis <code>useEffect</code>Â :<pre class="language-js{2,8}"><code class="language-js{2,8}">function Timer() {
  const intervalRef = useRef();

  useEffect(() => {
    const id = setInterval(() => {
      // ...
    });
    intervalRef.current = id;
    return () => {
      clearInterval(intervalRef.current);
    };
  });

  // ...
}</code></pre><p>Si nous avions juste voulu dÃ©finir une horloge, nous n'aurions pas eu besoin de la ref (<code>id</code> pouvait rester local Ã  l'effet) mais Ã§a peut Ãªtre utile si nous voulons arrÃªter l'horloge depuis un gestionnaire dâ€™Ã©vÃ©nements.<pre class="language-js{3}"><code class="language-js{3}">  // ...
  function handleCancelClick() {
    clearInterval(intervalRef.current);
  }
  // ...</code></pre><p>Conceptuellement, vous pouvez vous reprÃ©senter les refs comme des variables d'instance dans une classe. Ã€ moins que vous n'ayez recours Ã  de l'<a href="#how-to-create-expensive-objects-lazily">initialisation paresseuse</a>, Ã©vitez dâ€™Ã©crire dans vos refs pendant le renduÂ : Ã§a peut donner des comportements hasardeux. Au lieu de Ã§a, vous voudrez gÃ©nÃ©ralement modifier les refs au sein de gestionnaires d'Ã©vÃ©nements ou dâ€™effets.</section><section id="should-i-use-one-or-many-state-variables"class="level3"><h3>Dois-je utiliser une ou plusieurs variables d'Ã©tat localÂ ?</h3><p>Si vous avez l'habitude des classes, vous serez peut-Ãªtre tentÃ©Â·e de toujours appeler <code>useState()</code> une seule fois, en mettant tout l'Ã©tat local dans un unique objet. Si vous y tenez, c'est tout Ã  fait possible. Voici un exemple d'un composant qui piste le mouvement de la souris. Nous gardons sa position et sa taille dans l'Ã©tat localÂ :<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Box</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>state<span class="token punctuation">,</span> setState<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token literal-property property">left</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token literal-property property">top</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token literal-property property">width</span><span class="token operator">:</span> <span class="token number">100</span><span class="token punctuation">,</span> <span class="token literal-property property">height</span><span class="token operator">:</span> <span class="token number">100</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span></code></pre><p>Maintenant, disons que nous voulons Ã©crire un bout de code pour modifier <code>left</code> et <code>top</code> quand l'utilisateur bouge la souris. Voyez comme nous devons fusionner manuellement ces champs dans l'Ã©tat local prÃ©cÃ©dentÂ :<pre class="language-js{4,5}"><code class="language-js{4,5}">  // ...
  useEffect(() => {
    function handleWindowMouseMove(e) {
      // La dÃ©composition de "...state" permet de sâ€™assurer quâ€™on ne Â«Â perdÂ Â» pas width et height
      setState(state => ({ ...state, left: e.pageX, top: e.pageY }));
    }
    // RemarqueÂ : cette implÃ©mentation est un peu simplifiÃ©e
    window.addEventListener('mousemove', handleWindowMouseMove);
    return () => window.removeEventListener('mousemove', handleWindowMouseMove);
  }, []);
  // ...</code></pre><p>C'est dÃ» au fait que lorsque nous mettons Ã  jour une variable de l'Ã©tat local, nous <em>remplaÃ§ons</em> sa valeur, alors quâ€™avec <code>this.setState</code> dans une classe, on <em>fusionne</em> les champs mis Ã  jour dans l'objet.<p>Si la fusion automatique vous manque, vous pouvez Ã©crire un Hook personnalisÃ© <code>useLegacyState</code> qui fusionne les mises Ã  jour de l'Ã©tat local. Cependant, <strong>nous recommandons plutÃ´t de sÃ©parer l'Ã©tat local en de multiple variables d'Ã©tat en se basant sur celles qui ont tendance Ã  changer de valeur ensemble</strong>.<p>Par exemple, nous pourrions dÃ©couper l'Ã©tat local de notre composant en deux objets <code>position</code> et <code>size</code>, et toujours remplacer la <code>position</code> sans avoir besoin de fusionnerÂ :<pre class="language-js{2,7}"><code class="language-js{2,7}">function Box() {
  const [position, setPosition] = useState({ left: 0, top: 0 });
  const [size, setSize] = useState({ width: 100, height: 100 });

  useEffect(() => {
    function handleWindowMouseMove(e) {
      setPosition({ left: e.pageX, top: e.pageY });
    }
    // ...</code></pre><p>SÃ©parer les variables d'Ã©tat indÃ©pendantes prÃ©sente un intÃ©rÃªt supplÃ©mentaireÂ : il devient facile d'extraire une partie de la logique dans un Hook personnalisÃ©, par exempleÂ :<pre class="language-js{2,7}"><code class="language-js{2,7}">function Box() {
  const position = useWindowPosition();
  const [size, setSize] = useState({ width: 100, height: 100 });
  // ...
}

function useWindowPosition() {
  const [position, setPosition] = useState({ left: 0, top: 0 });
  useEffect(() => {
    // ...
  }, []);
  return position;
}</code></pre><p>Remarquez comme nous avons pu dÃ©placer l'appel Ã  <code>useState</code> pour la variable d'Ã©tat local <code>position</code> et l'effet associÃ© dans un Hook personnalisÃ© sans rien changer au code. Si tout l'Ã©tat local Ã©tait un unique objet, extraire cet aspect aurait Ã©tÃ© plus difficile.<p>Les deux approches sont possiblesÂ : mettre tout l'Ã©tat local dans un unique appel Ã  <code>useState</code> ou avoir un appel Ã  <code>useState</code> par champ. La lisibilitÃ© des composants sera fonction de l'Ã©quilibre que vous trouverez entre ces deux extrÃªmes, et du regroupement des Ã©tats locaux associÃ©s en quelques variables d'Ã©tat indÃ©pendantes. Si la logique de l'Ã©tat local devient trop complexe, nous vous conseillons de plutÃ´t la <a href="./hooks-reference.html#usereducer">gÃ©rer avec un rÃ©ducteur</a> ou un Hook personnalisÃ©.</section><section id="can-i-run-an-effect-only-on-updates"class="level3"><h3>Puis-je exÃ©cuter un effet seulement lors des mises Ã  jourÂ ?</h3><p>C'est un cas d'utilisation assez rare. Si vous en avez besoin, vous pouvez <a href="#is-there-something-like-instance-variables">utiliser une ref modifiable</a> pour stocker manuellement un boolÃ©en indiquant si vous Ãªtes sur le premier rendu ou un rendu postÃ©rieur, et vÃ©rifier ensuite ce drapeau dans votre effet. (Si vous faites Ã§a rÃ©guliÃ¨rement, vous voudrez sans doute crÃ©er un Hook personnalisÃ© pour Ã§a.)</section><section id="how-to-get-the-previous-props-or-state"class="level3"><h3>Comment rÃ©cupÃ©rer les props ou l'Ã©tat local prÃ©cÃ©dentsÂ ?</h3><p>Actuellement, vous pouvez le faire manuellement <a href="#is-there-something-like-instance-variables">avec une ref</a>Â :<pre class="language-js{6,8}"><code class="language-js{6,8}">function Counter() {
  const [count, setCount] = useState(0);

  const prevCountRef = useRef();
  useEffect(() => {
    prevCountRef.current = count;
  });
  const prevCount = prevCountRef.current;

  return &#x3C;h1>MaintenantÂ : {count}, avantÂ : {prevCount}&#x3C;/h1>;
}</code></pre><p>Ã‡a peut sembler un peu biscornu mais vous pouvez l'extraire dans un Hook personnalisÃ©Â :<pre class="language-js{3,7}"><code class="language-js{3,7}">function Counter() {
  const [count, setCount] = useState(0);
  const prevCount = usePrevious(count);
  return &#x3C;h1>MaintenantÂ : {count}, avantÂ : {prevCount}&#x3C;/h1>;
}

function usePrevious(value) {
  const ref = useRef();
  useEffect(() => {
    ref.current = value;
  });
  return ref.current;
}</code></pre><p>Remaquez que Ã§a fonctionne pour les props, l'Ã©tat local, et toute autre valeur calculÃ©e.<pre class="language-js{5}"><code class="language-js{5}">function Counter() {
  const [count, setCount] = useState(0);

  const calculation = count + 100;
  const prevCalculation = usePrevious(calculation);
  // ...</code></pre><p>Il est possible quâ€™Ã  l'avenir React fournisse un Hook <code>usePrevious</code> prÃªt Ã  l'emploi, puisque c'est un cas d'usage assez frÃ©quent.<p>Voir aussi <a href="#how-do-i-implement-getderivedstatefromprops">lâ€™approche recommandÃ©e pour un Ã©tat local dÃ©rivÃ©</a>.</section><section id="why-am-i-seeing-stale-props-or-state-inside-my-function"class="level3"><h3>Pourquoi vois-je des props ou un Ã©tat local obsolÃ¨tes dans ma fonctionÂ ?</h3><p>Toute fonction au sein d'un composant, y compris les gestionnaires d'Ã©vÃ©nements et les effets, Â«Â voitÂ Â» les props et l'Ã©tat local en vigueur lors du rendu qui les a crÃ©Ã©es. Par exemple, prenez ce genre de codeÂ :<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Example</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>count<span class="token punctuation">,</span> setCount<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">function</span> <span class="token function">handleAlertClick</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
      <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'Vous avez cliquÃ© Ã  '</span> <span class="token operator">+</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword control-flow">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&#x3C;</span>div<span class="token operator">></span>
      <span class="token operator">&#x3C;</span>p<span class="token operator">></span><span class="token maybe-class-name">Vous</span> avez cliquÃ© <span class="token punctuation">{</span>count<span class="token punctuation">}</span> fois<span class="token operator">&#x3C;</span><span class="token operator">/</span>p<span class="token operator">></span>
      <span class="token operator">&#x3C;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token function">setCount</span><span class="token punctuation">(</span>count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token operator">></span>
        <span class="token maybe-class-name">Cliquez</span> ici
      <span class="token operator">&#x3C;</span><span class="token operator">/</span>button<span class="token operator">></span>
      <span class="token operator">&#x3C;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span>handleAlertClick<span class="token punctuation">}</span><span class="token operator">></span>
        <span class="token maybe-class-name">Afficher</span> un message
      <span class="token operator">&#x3C;</span><span class="token operator">/</span>button<span class="token operator">></span>
    <span class="token operator">&#x3C;</span><span class="token operator">/</span>div<span class="token operator">></span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>Si vous cliquez dâ€™abord sur Â«Â Afficher un messageÂ Â» puis incrÃ©mentez tout de suite le compteur, le message affichera la variable <code>count</code> <strong>telle quâ€™elle Ã©tait lors du clic sur le bouton Â«Â Afficher un messageÂ Â»</strong>. Ã‡a Ã©vite les bugs causÃ©s par du code qui suppose que les props et l'Ã©tat local ne changent pas.<p>Si vous souhaitez explicitement lire le <strong>tout dernier</strong> Ã©tat depuis une fonction de rappel asynchrone, vous pouvez le conserver dans <a href="./hooks-faq.html#is-there-something-like-instance-variables">une ref</a>, la modifier puis la relire.<p>Pour finir, une autre explication possible pour vos props ou votre Ã©tat pÃ©rimÃ©s rÃ©siderait dans votre utilisation incorrecte de lâ€™optimisation du hook par Â«Â tableau de dÃ©pendancesÂ Â», auquel il manquerait certaines valeurs. Par exemple, si un effet indique <code>[]</code> comme deuxiÃ¨me argument mais lit <code>someProp</code> en interne, il continuera Ã  Â«Â voirÂ Â» la valeur initiale de <code>someProp</code>. La solution consiste soit Ã  retirer l'argument de tableau de dÃ©pendances, soit Ã  le corriger. Voici <a href="#is-it-safe-to-omit-functions-from-the-list-of-dependencies">comment y gÃ©rer des fonctions</a> ainsi que <a href="#what-can-i-do-if-my-effect-dependencies-change-too-often">dâ€™autres stratÃ©gies habituelles</a> pour exÃ©cuter des effets moins souvent sans ignorer Ã  tort des dÃ©pendances.<blockquote><p>Remarque<p>Nous proposons une rÃ¨gle ESLint <a href="https://github.com/facebook/react/issues/14920"><code>exhaustive-deps</code></a> dans le cadre du module <a href="https://www.npmjs.com/package/eslint-plugin-react-hooks#installation"><code>eslint-plugin-react-hooks</code></a>. Elle vous avertit lorsque les dÃ©pendances spÃ©cifiÃ©es semblent incorrectes et vous propose un correctif.</blockquote></section><section id="how-do-i-implement-getderivedstatefromprops"class="level3"><h3>Comment puis-je implÃ©menter <code>getDerivedStateFromProps</code>Â ?</h3><p>MÃªme si vous n'en avez probablement <a href="/blog/2018/06/07/you-probably-dont-need-derived-state.html">pas besoin</a>, dans les rares cas oÃ¹ c'est nÃ©cessaire (comme implÃ©menter un composant <code>&#x3C;Transition></code>) vous pouvez mettre Ã  jour l'Ã©tat local en plein rendu. React va rafraÃ®chir le composant avec l'Ã©tat local mis Ã  jour immÃ©diatement aprÃ¨s Ãªtre sorti du premier rendu afin que Ã§a ne soit pas trop coÃ»teux.<p>Ici, nous stockons la valeur prÃ©cÃ©dente de la prop <code>row</code> dans une variable de l'Ã©tat local afin que nous puissions les comparerÂ :<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">ScrollView</span></span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span>row<span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>isScrollingDown<span class="token punctuation">,</span> setIsScrollingDown<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>prevRow<span class="token punctuation">,</span> setPrevRow<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token keyword null nil">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>row <span class="token operator">!==</span> prevRow<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// Row a changÃ© depuis le dernier rendu. Met Ã  jour isScrollingDown.</span>
    <span class="token function">setIsScrollingDown</span><span class="token punctuation">(</span>prevRow <span class="token operator">!==</span> <span class="token keyword null nil">null</span> <span class="token operator">&#x26;&#x26;</span> row <span class="token operator">></span> prevRow<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">setPrevRow</span><span class="token punctuation">(</span>row<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword control-flow">return</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">On dÃ©file vers le basÂ : </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>isScrollingDown<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>Ã‡a peut sembler Ã©trange Ã  premiÃ¨re vue, mais <code>getDerivedStateFromProps</code> avait prÃ©cisÃ©ment Ã©tÃ© conÃ§ue pour des mises Ã  jour pendant le rendu.</section><section id="is-there-something-like-forceupdate"class="level3"><h3>Existe-t-il un Ã©quivalent Ã  forceUpdateÂ ?</h3><p>Les deux Hooks <code>useState</code> et <code>useReducer</code> <a href="./hooks-reference.html#bailing-out-of-a-state-update">abandonnent la mise Ã  jour</a> si la valeur suivante est la mÃªme que la valeur prÃ©cÃ©dente. Modifier l'Ã©tat local en place et appeler <code>setState</code> ne causera pas de rafraÃ®chissement.<p>GÃ©nÃ©ralement, vous ne devez pas modifier l'Ã©tat local directement en React. Cependant, Ã  titre d'Ã©chappatoire, vous pouvez maintenir un compteur incrÃ©mental pour forcer un rafraÃ®chissement mÃªme si l'Ã©tat local n'a pas changÃ©Â :<pre class="language-js"><code class="language-js">  <span class="token keyword">const</span> <span class="token punctuation">[</span>ignored<span class="token punctuation">,</span> forceUpdate<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useReducer</span><span class="token punctuation">(</span><span class="token parameter">x</span> <span class="token arrow operator">=></span> x <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">function</span> <span class="token function">handleClick</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">forceUpdate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span></code></pre><p>Ã‰vitez autant que possible d'utiliser cette approche.</section><section id="can-i-make-a-ref-to-a-function-component"class="level3"><h3>Puis-je crÃ©er une ref vers une fonction composantÂ ?</h3><p>Vous ne devriez pas en avoir besoin souvent, mais vous pouvez exposer quelques mÃ©thodes impÃ©ratives Ã  un composant parent avec le Hook <a href="./hooks-reference.html#useimperativehandle"><code>useImperativeHandle</code></a>.</section><section id="how-can-i-measure-a-dom-node"class="level3"><h3>Comment puis-je mesurer un nÅ“ud DOMÂ ?</h3><p>Une faÃ§on rudimentaire de mesurer la position ou les dimensions dâ€™un nÅ“ud DOM consiste Ã  utiliser une <a href="./refs-and-the-dom.html#callback-refs">ref avec fonction de rappel</a>. React appellera la fonction de rappel chaque fois que la ref est attachÃ©e Ã  un nÅ“ud diffÃ©rent. Voici une <a href="https://codesandbox.io/s/l7m0v5x4v9">petite dÃ©mo</a>Â :<pre class="language-js{4-8,12}"><code class="language-js{4-8,12}">function MeasureExample() {
  const [height, setHeight] = useState(0);

  const measuredRef = useCallback(node => {
    if (node !== null) {
      setHeight(node.getBoundingClientRect().height);
    }
  }, []);

  return (
    &#x3C;>
      &#x3C;h1 ref={measuredRef}>Bonjour, monde&#x3C;/h1>
      &#x3C;h2>Lâ€™en-tÃªte ci-dessus fait {Math.round(height)}px de haut&#x3C;/h2>
    &#x3C;/>
  );
}</code></pre><p>Nous avons Ã©vitÃ© <code>useRef</code> dans cet exemple parce quâ€™un objet ref ne nous notifie pas des <em>changements</em> de la valeur actuelle de la ref. Une ref avec fonction de rappel garantit que <a href="https://codesandbox.io/s/818zzk8m78">mÃªme si un composant enfant affiche ultÃ©rieurement le nÅ“ud DOM mesurÃ©</a> (ex. en rÃ©action Ã  un clic), nous serons quand mÃªme notifiÃ©s dans le composant parent et pourrons mettre les mesures Ã  jour.<p>Remarquez que nous passons <code>[]</code> comme tableau de dÃ©pendances Ã  <code>useCallback</code>. Câ€™est pour nous assurer que notre ref Ã  fonction de rappel ne change pas dâ€™un rendu Ã  lâ€™autre, afin que React ne nous appelle pas pour rien.<p>Dans cet exemple, la ref avec fonction de rappel ne sera appelÃ©e que lors du montage et du dÃ©montage du composant, puisque le composant <code>&#x3C;h1></code> reste prÃ©sent dâ€™un rendu au suivant. Si vous souhaitez Ãªtre notifiÃ©Â·e Ã  chaque redimensionnement, vous voudrez peut-Ãªtre utiliser <a href="https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserver"><code>ResizeObserver</code></a> ou un Hook tiers basÃ© dessus.<p>Si vous le souhaitez, vous pouvez <a href="https://codesandbox.io/s/m5o42082xy">extraire cette logique</a> dans un Hook rÃ©utilisableÂ :<pre class="language-js{2}"><code class="language-js{2}">function MeasureExample() {
  const [rect, ref] = useClientRect();
  return (
    &#x3C;>
      &#x3C;h1 ref={ref}>Bonjour, monde&#x3C;/h1>
      {rect !== null &#x26;&#x26;
        &#x3C;h2>Lâ€™en-tÃªte ci-dessus fait {Math.round(rect.height)}px de haut&#x3C;/h2>
      }
    &#x3C;/>
  );
}

function useClientRect() {
  const [rect, setRect] = useState(null);
  const ref = useCallback(node => {
    if (node !== null) {
      setRect(node.getBoundingClientRect());
    }
  }, []);
  return [rect, ref];
}</code></pre></section><section id="what-does-const-thing-setthing--usestate-mean"class="level3"><h3>Que signifie <code>const [thing, setThing] = useState()</code>Â ?</h3><p>Si vous nâ€™avez pas l'habitude de cette syntaxe, allez voir l'<a href="./hooks-state.html#tip-what-do-square-brackets-mean">explication</a> dans la documentation du Hook dâ€™Ã©tat.</section></section><section id="performance-optimizations"class="level2"><h2>Optimisations des performances</h2><section id="can-i-skip-an-effect-on-updates"class="level3"><h3>Puis-je sauter un effet lors des mises Ã  jourÂ ?</h3><p>Oui. Reportez-vous au <a href="./hooks-reference.html#conditionally-firing-an-effect">dÃ©clenchement conditionnel d'un effet</a>. Remarquez qu'oublier de gÃ©rer des mises Ã  jour est souvent <a href="./hooks-effect.html#explanation-why-effects-run-on-each-update">source de bugs</a>, ce qui explique pourquoi ce n'est pas le comportement par dÃ©faut.</section><section id="is-it-safe-to-omit-functions-from-the-list-of-dependencies"class="level3"><h3>Est-il acceptable dâ€™omettre les fonctions du tableau de dÃ©pendancesÂ ?</h3><p>En rÃ¨gle gÃ©nÃ©rale, non.<pre class="language-js{3,8}"><code class="language-js{3,8}">function Example({ someProp }) {
  function doSomething() {
    console.log(someProp);
  }

  useEffect(() => {
    doSomething();
  }, []); // ğŸ”´ Ce nâ€™est pas fiable (Ã§a appelle `doSomething` qui utilise `someProp`)
}</code></pre><p>Il nâ€™est pas facile de se souvenir du dÃ©tail des props et de l'Ã©tat local utilisÃ©s par les fonctions hors de l'effet. C'est pourquoi <strong>vous voudrez gÃ©nÃ©ralement dÃ©clarer les fonctions dont votre effet a besoin <em>Ã  lâ€™intÃ©rieur de celui-ci</em>.</strong> Il devient alors facile de voir de quelles valeurs de la portÃ©e du composant dÃ©pend cet effetÂ :<pre class="language-js{4,8}"><code class="language-js{4,8}">function Example({ someProp }) {
  useEffect(() => {
    function doSomething() {
      console.log(someProp);
    }

    doSomething();
  }, [someProp]); // âœ… OK (notre effet nâ€™utilise que `someProp`)
}</code></pre><p>Si aprÃ¨s Ã§a vous nâ€™utilisez toujours pas de valeurs issues de la portÃ©e du composant, vous pouvez sans problÃ¨me spÃ©cifier <code>[]</code>Â :<pre class="language-js{7}"><code class="language-js{7}">useEffect(() => {
  function doSomething() {
    console.log('bonjour');
  }

  doSomething();
}, []); // âœ… OK dans ce cas prÃ©cis car nous nâ€™utilisons *aucune* valeur de la portÃ©e du composant</code></pre><p>Selon votre cas, vous trouverez quelques options supplÃ©mentaires plus bas dans cette page.<blockquote><p>Remarque<p>Nous mettons Ã  disposition la rÃ¨gle ESLint <a href="https://github.com/facebook/react/issues/14920"><code>exhaustive-deps</code></a> dans le cadre du module <a href="https://www.npmjs.com/package/eslint-plugin-react-hooks#installation"><code>eslint-plugin-react-hooks</code></a>. Elle vous aide Ã  trouver les composants qui ne gÃ¨rent pas correctement les mises Ã  jour.</blockquote><p>Voyons en quoi câ€™est important.<p>Si vous prÃ©cisez une <a href="./hooks-reference.html#conditionally-firing-an-effect">liste de dÃ©pendances</a> comme dernier argument de <code>useEffect</code>, <code>useLayoutEffet</code>, <code>useMemo</code>, <code>useCallback</code>, ou <code>useImperativeHandle</code>, cette liste doit inclure toutes les valeurs utilisÃ©es dans la fonction passÃ©e qui participent au flux de donnÃ©es de React. Ã‡a inclut les props, l'Ã©tat local, et toute valeur qui en dÃ©coule.<p>Le <strong>seul cas</strong> pour lequel vous pouvez sereinement omettre une fonction de la liste des dÃ©pendances, c'est lorsque rien Ã  l'intÃ©rieur (y compris dans les autres fonctions qu'elle appelle) ne rÃ©fÃ©rence les props, l'Ã©tat local ou des valeurs qui en dÃ©coulent. L'exemple suivant a ce problÃ¨meÂ :<pre class="language-js{5,12}"><code class="language-js{5,12}">function ProductPage({ productId }) {
  const [product, setProduct] = useState(null);

  async function fetchProduct() {
    const response = await fetch('http://myapi/product/' + productId); // Utilise la prop productId
    const json = await response.json();
    setProduct(json);
  }

  useEffect(() => {
    fetchProduct();
  }, []); // ğŸ”´ ErronÃ© car `fetchProduct` utilise `productId`
  // ...
}</code></pre><p><strong>Le correctif recommandÃ© consiste Ã  dÃ©placer la fonction <em>dans</em> votre effet</strong>. Ã‡a facilite le repÃ©rage des props et variables d'Ã©tat que votre effet utilise, pour garantir qu'elles sont toutes dÃ©clarÃ©esÂ :<pre class="language-js{5-10,13}"><code class="language-js{5-10,13}">function ProductPage({ productId }) {
  const [product, setProduct] = useState(null);

  useEffect(() => {
    // En dÃ©plaÃ§ant cette fonction dans l'effet, on voit clairement quelles valeurs il utilise.
    async function fetchProduct() {
      const response = await fetch('http://myapi/product/' + productId);
      const json = await response.json();
      setProduct(json);
    }

    fetchProduct();
  }, [productId]); // âœ… Correct car notre effet nâ€™utilise que `productId`
  // ...
}</code></pre><p>Ã‡a permet aussi de gÃ©rer les rÃ©ponses trop tardives grÃ¢ce Ã  des variables locales Ã  l'effetÂ :<pre class="language-js{2,6,10}"><code class="language-js{2,6,10}">  useEffect(() => {
    let ignore = false;
    async function fetchProduct() {
      const response = await fetch('http://myapi/product/' + productId);
      const json = await response.json();
      if (!ignore) setProduct(json);
    }

    fetchProduct();
    return () => { ignore = true };
  }, [productId]);</code></pre><p>Nous avons dÃ©placÃ© la fonction dans l'effet, donc cette variable n'a pas Ã  figurer dans la liste des dÃ©pendances.<blockquote><p>Astuce<p>Jetez un coup dâ€™Å“il Ã  <a href="https://codesandbox.io/s/jvvkoo8pq3">cette petite dÃ©mo</a> et <a href="https://www.robinwieruch.de/react-hooks-fetch-data/">cet article</a> (en anglais) pour en apprendre davantage sur le chargement de donnÃ©es distantes avec les Hooks.</blockquote><p><strong>Si pour une raison ou une autre vous ne <em>pouvez pas</em> dÃ©placer la fonction dans l'effet, vous avez d'autres optionsÂ :</strong><ul><li><strong>Vous pouvez essayer de dÃ©placer la fonction hors du composant</strong>. Dans ce cas, vous Ãªtes sÃ»rÂ·e quâ€™elle ne pourra pas rÃ©fÃ©rencer des props ou variables d'Ã©tat, et quâ€™elle n'a donc pas besoin de figurer dans la liste des dÃ©pendances.<li>Si la fonction que vous appelez est un calcul pur et qu'on peut sereinement l'appeler pendant le rendu, vous pouvez <strong>l'appeler plutÃ´t hors de l'effet</strong> et faire dÃ©pendre l'effet de la valeur qu'elle renvoie.<li>En dernier recours, vous pouvez <strong>ajouter une fonction aux dÃ©pendances de l'effet mais <em>enrober sa dÃ©finition</em></strong> dans un Hook <a href="./hooks-reference.html#usecallback"><code>useCallback</code></a>. Ã‡a garantit qu'elle ne changera pas Ã  chaque rendu sauf si <em>ses propres</em> dÃ©pendances changent aussiÂ :</ul><pre class="language-js{2-5}"><code class="language-js{2-5}">function ProductPage({ productId }) {
  // âœ… Enrobe avec useCallback pour Ã©viter de changer Ã  chaque rendu
  const fetchProduct = useCallback(() => {
    // ... Fait un truc avec productId ...
  }, [productId]); // âœ… Toutes les dÃ©pendances de useCallback sont spÃ©cifiÃ©es

  return &#x3C;ProductDetails fetchProduct={fetchProduct} />;
}

function ProductDetails({ fetchProduct }) {
  useEffect(() => {
    fetchProduct();
  }, [fetchProduct]); // âœ… Toutes les dÃ©pendances de useEffect sont spÃ©cifiÃ©es
  // ...
}</code></pre><p>Remarquez que dans cet exemple nous <strong>devons</strong> garder la fonction dans la liste des dÃ©pendances. On s'assure ainsi qu'une modification Ã  la prop <code>productId</code> de <code>ProductPage</code> dÃ©clenchera automatiquement un nouveau chargement de donnÃ©es distantes dans le composant <code>ProductDetails</code>.</section><section id="what-can-i-do-if-my-effect-dependencies-change-too-often"class="level3"><h3>Que faire quand mes dÃ©pendances dâ€™effet changent trop souventÂ ?</h3><p>Il arrive que votre effet utilise un Ã©tat qui change trop frÃ©quemment. Vous pourriez alors Ãªtre tentÃ©Â·e dâ€™omettre cet Ã©tat de la liste des dÃ©pendances, mais Ã§a engendre souvent des bugsÂ :<pre class="language-js{6,9}"><code class="language-js{6,9}">function Counter() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    const id = setInterval(() => {
      setCount(count + 1); // Cet effet dÃ©pend de lâ€™Ã©tat `count`
    }, 1000);
    return () => clearInterval(id);
  }, []); // ğŸ”´ BugÂ : `count` nâ€™est pas listÃ© comme dÃ©pendance

  return &#x3C;h1>{count}&#x3C;/h1>;
}</code></pre><p>La liste de dÃ©pendances vide, <code>[]</code>, singifie que lâ€™effet ne sera exÃ©cutÃ© quâ€™une fois au montage du composant, et non Ã  chaque rafraÃ®chissement. Le problÃ¨me vient du fait que dans la fonction de rappel passÃ©e Ã  <code>setInterval</code>, la valeur de <code>count</code> ne va pas changer, car on a crÃ©Ã© une fermeture lexicale <em>(closure, NdT)</em> avec <code>count</code> Ã  <code>0</code>, tel quâ€™elle Ã©tait lorsque la fonction de rappel de lâ€™effet sâ€™est exÃ©cutÃ©e. Ã€ chaque seconde, cette fonction appelle <code>setCount(0 + 1)</code>, de sorte que le compteur ne dÃ©passe jamais 1.<p>On pourrait corriger le bug en spÃ©cifiant <code>[count]</code> comme liste de dÃ©pendances, mais Ã§a rÃ©initialiserait notre horloge Ã  chaque modification. En pratique, chaque <code>setInterval</code> aurait une chance de sâ€™exÃ©cuter avant dâ€™Ãªtre rÃ©initialisÃ© (comme pour un <code>setTimeout</code>). Ce nâ€™est peut-Ãªtre pas souhaitable. Pour corriger Ã§a, nous pouvons utiliser <a href="./hooks-reference.html#functional-updates">la version basÃ©e fonction de <code>setState</code></a>. Elle nous permet dâ€™indiquer <em>comment</em> lâ€™Ã©tat change, sans rÃ©fÃ©rencer lâ€™Ã©tat <em>actuel</em>Â :<pre class="language-js{6,9}"><code class="language-js{6,9}">function Counter() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    const id = setInterval(() => {
      setCount(c => c + 1); // âœ… Ã‡a ne dÃ©pend pas de la variable `count` issue de la portÃ©e
    }, 1000);
    return () => clearInterval(id);
  }, []); // âœ… Notre effet nâ€™utilise aucune variable issue de la portÃ©e du composant

  return &#x3C;h1>{count}&#x3C;/h1>;
}</code></pre><p>(Lâ€™identitÃ© de la fonction <code>setCount</code> est garantie stable, il est donc naturel de lâ€™omettre.)<p>Ã€ prÃ©sent, la fonction de rappel de <code>setInterval</code> est appelÃ©e une fois par seconde, mais Ã  chaque fois lâ€™appel interne Ã  <code>setCount</code> peut utiliser une valeur Ã  jour de <code>count</code> (appelÃ©e <code>c</code> dans la fonction de rappel ci-dessus).<p>Pour des cas plus complexes (comme lorsquâ€™un Ã©tat dÃ©pend d'un autre Ã©tat), essayez de dÃ©placer la logique de mise Ã  jour de l'Ã©tat hors de l'effet avec le <a href="./hooks-reference.html#usereducer">Hook <code>useReducer</code></a>. <a href="https://adamrackis.dev/state-and-use-reducer/">Cet article</a> (en anglais) vous donne un exemple de cette approche. <strong>Lâ€™identitÃ© de la fonction <code>dispatch</code> fournie par <code>useReducer</code> est garantie stable</strong>, mÃªme si la fonction de rÃ©duction est dÃ©clarÃ©e dans le composant et lit ses props.<p>En dernier recours, si vous voulez quelque chose de similaire au <code>this</code> dâ€™une classe, vous pouvez <a href="./hooks-faq.html#is-there-something-like-instance-variables">utiliser une ref</a> pour stocker une donnÃ©e modifiable. Vous pouvez alors y Ã©crire et la relire. Par exempleÂ :<pre class="language-js{2-6,10-11,16}"><code class="language-js{2-6,10-11,16}">function Example(props) {
  // Garde les derniÃ¨res props dans une ref.
  const latestProps = useRef(props);
  useEffect(() => {
    latestProps.current = props;
  });

  useEffect(() => {
    function tick() {
      // Lit les derniÃ¨res props en vigueur
      console.log(latestProps.current);
    }

    const id = setInterval(tick, 1000);
    return () => clearInterval(id);
  }, []); // Cet effet nâ€™est jamais rÃ©-exÃ©cutÃ©
}</code></pre><p>Ne faites Ã§a que si vous n'avez pas pu trouver de meilleure solution, car se reposer sur des mutations rend les composants plus imprÃ©visibles. Si vous n'arrivez pas Ã  trouver une approche adaptÃ©e pour votre besoin, <a href="https://github.com/facebook/react/issues/new">crÃ©ez un ticket</a> avec un exemple exÃ©cutable de code pour que nous puissions essayer de vous aider.</section><section id="how-do-i-implement-shouldcomponentupdate"class="level3"><h3>Comment puis-je implÃ©menter shouldComponentUpdateÂ ?</h3><p>Vous pouvez enrober une fonction composant avec <code>React.memo</code> pour comparer superficiellement ses propsÂ :<pre class="language-js"><code class="language-js"><span class="token keyword">const</span> <span class="token maybe-class-name">Button</span> <span class="token operator">=</span> <span class="token maybe-class-name">React</span><span class="token punctuation">.</span><span class="token method function property-access">memo</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
  <span class="token comment">// votre composant</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>Ce n'est pas un Hook car ce n'est pas composable, alors que les Hooks le sont. <code>React.memo</code> est Ã©quivalent Ã  <code>PureComponent</code>, mais ne compare que les props. (Vous pouvez aussi ajouter un second argument pour spÃ©cifier une fonction de comparaison personnalisÃ©e qui prendra en arguments les anciennes et nouvelles props. Si elle renvoie <code>true</code>, la mise Ã  jour est Ã©vitÃ©e.)<p><code>React.memo</code> ne compare pas l'Ã©tat local car il n'y a pas dâ€™unique objet d'Ã©tat local Ã  comparer. Mais vous pouvez rendre les descendants purs Ã©galement, ou mÃªme <a href="./hooks-faq.html#how-to-memoize-calculations">optimiser les descendants individuellement avec <code>useMemo</code></a>.</section><section id="how-to-memoize-calculations"class="level3"><h3>Comment mÃ©moÃ¯ser les calculsÂ ?</h3><p>Le Hook <a href="./hooks-reference.html#usememo"><code>useMemo</code></a> vous permet de mettre en cache les calculs Ã  travers les rendus en Â«Â se souvenantÂ Â» du dernier calculÂ :<pre class="language-js"><code class="language-js"><span class="token keyword">const</span> memoizedValue <span class="token operator">=</span> <span class="token function">useMemo</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token function">computeExpensiveValue</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>a<span class="token punctuation">,</span> b<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>Ce code appelle <code>computeExpensiveValue(a, b)</code>. Mais si les dÃ©pendances <code>[a, b]</code> n'ont pas changÃ© depuis la derniÃ¨re fois, <code>useMemo</code> saute le second appel et rÃ©utilise simplement la derniÃ¨re valeur renvoyÃ©e.<p>Rappelez-vous que la fonction passÃ©e Ã  <code>useMemo</code> s'exÃ©cute pendant le rendu. Nâ€˜y faites rien que vous ne feriez normalement pendant le rendu. Par exemple, les effets de bord sont du ressort de <code>useEffect</code>, pas de <code>useMemo</code>.<p><strong>Vous pouvez vous appuyer sur <code>useMemo</code> pour les optimisations de performances, mais pas comme une garantie sÃ©mantique.</strong> Ã€ l'avenir, React pourrait trÃ¨s bien choisir Â«Â d'oublierÂ Â» certaines valeurs prÃ©alablement mÃ©moÃ¯sÃ©es et de les recalculer lors du rendu suivant, par exemple pour libÃ©rer de la mÃ©moire pour les composants non visibles. Ã‰crivez votre code de faÃ§on Ã  ce qu'il fonctionne toujours sans <code>useMemo</code>, et ajoutez-le ensuite pour optimiser les performances. (Pour les rares cas oÃ¹ une valeur ne doit <em>jamais</em> Ãªtre recalculÃ©e, vous pouvez <a href="#how-to-create-expensive-objects-lazily">lâ€™initialiser paresseusement</a> dans une ref.)<p>Vous pouvez aussi utiliser <code>useMemo</code> pour Ã©viter le rafraÃ®chissement coÃ»teux d'un enfantÂ :<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Parent</span></span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> a<span class="token punctuation">,</span> b <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// Nâ€™est rafraÃ®chi que si `a` changeÂ :</span>
  <span class="token keyword">const</span> child1 <span class="token operator">=</span> <span class="token function">useMemo</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token operator">&#x3C;</span><span class="token maybe-class-name">Child1</span> a<span class="token operator">=</span><span class="token punctuation">{</span>a<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">,</span> <span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// Nâ€™est rafraÃ®chi que si `b` changeÂ :</span>
  <span class="token keyword">const</span> child2 <span class="token operator">=</span> <span class="token function">useMemo</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token operator">&#x3C;</span><span class="token maybe-class-name">Child2</span> b<span class="token operator">=</span><span class="token punctuation">{</span>b<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">,</span> <span class="token punctuation">[</span>b<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword control-flow">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&#x3C;</span><span class="token operator">></span>
      <span class="token punctuation">{</span>child1<span class="token punctuation">}</span>
      <span class="token punctuation">{</span>child2<span class="token punctuation">}</span>
    <span class="token operator">&#x3C;</span><span class="token operator">/</span><span class="token operator">></span>
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre><p>Remarquez que cette approche ne fonctionne pas dans une boucle car les appels aux Hooks <a href="./hooks-rules.html">ne doivent pas</a> Ãªtre placÃ©s dans des boucles. Mais vous pouvez extraire la liste dans un composant Ã  part, et appeler <code>useMemo</code> sur celui-ci.</section><section id="how-to-create-expensive-objects-lazily"class="level3"><h3>Comment crÃ©er paresseusement des objets coÃ»teuxÂ ?</h3><p><code>useMemo</code> vous permet de <a href="#how-to-memoize-calculations">mÃ©moÃ¯ser un calcul coÃ»teux</a> si les dÃ©pendances sont les mÃªmes. Cependant, il n'est lÃ  que pour aider, et ne <em>garantit</em> pas que le calcul ne sera pas refait. Mais parfois vous devez vous assurer qu'un objet n'est crÃ©Ã© qu'une seule fois.<p><strong>Le principal cas d'utilisation concerne la crÃ©ation d'un Ã©tat initial coÃ»teuxÂ :</strong><pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Table</span></span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// âš ï¸ createRows() est appelÃ©e Ã  chaque rendu</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>rows<span class="token punctuation">,</span> setRows<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token function">createRows</span><span class="token punctuation">(</span>props<span class="token punctuation">.</span><span class="token property-access">count</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span></code></pre><p>Pour Ã©viter de recrÃ©er l'Ã©tat initial ignorÃ©, nous pouvons passer une <strong>fonction</strong> Ã  <code>useState</code>Â :<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Table</span></span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// âœ… createRows() n'est appelÃ©e qu'une seule fois</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>rows<span class="token punctuation">,</span> setRows<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token function">createRows</span><span class="token punctuation">(</span>props<span class="token punctuation">.</span><span class="token property-access">count</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span></code></pre><p>React n'appelera cette fonction que lors du premier rendu. Vous trouverez de plus amples dÃ©tails dans l'<a href="./hooks-reference.html#usestate">API de rÃ©fÃ©rence de <code>useState</code></a>.<p><strong>Vous pouvez aussi vouloir occasionnellement Ã©viter de recrÃ©er la valeur initiale de <code>useRef()</code>.</strong> Par exemple, vous voulez peut-Ãªtre vous assurer qu'une instance de classe impÃ©rative n'est crÃ©Ã©e qu'une seule foisÂ :<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Image</span></span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// âš ï¸ IntersectionObserver est crÃ©Ã© Ã  chaque rendu</span>
  <span class="token keyword">const</span> ref <span class="token operator">=</span> <span class="token function">useRef</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">IntersectionObserver</span><span class="token punctuation">(</span>onIntersect<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span></code></pre><p><code>useRef</code> <strong>n'accepte pas</strong> un argument de fonction spÃ©cial comme pour <code>useState</code>. Au lieu de Ã§a, vous pouvez Ã©crire votre propre fonction qui la crÃ©e et la dÃ©finit paresseusementÂ :<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Image</span></span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> ref <span class="token operator">=</span> <span class="token function">useRef</span><span class="token punctuation">(</span><span class="token keyword null nil">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// âœ… IntersectionObserver est crÃ©Ã© paresseusement une seule fois</span>
  <span class="token keyword">function</span> <span class="token function">getObserver</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>ref<span class="token punctuation">.</span><span class="token property-access">current</span> <span class="token operator">===</span> <span class="token keyword null nil">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      ref<span class="token punctuation">.</span><span class="token property-access">current</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">IntersectionObserver</span><span class="token punctuation">(</span>onIntersect<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword control-flow">return</span> ref<span class="token punctuation">.</span><span class="token property-access">current</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// Quand vous en avez besoin, appelez getObserver()</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span></code></pre><p>Ã‡a permet d'Ã©viter de recrÃ©er un objet coÃ»teux tant quâ€™il n'est pas nÃ©cessaire. Si vous utilisez Flow ou TypeScript, vous pouvez aussi donner Ã  <code>getObserver()</code> un type non-nullable pour un typage plus fin.</section><section id="are-hooks-slow-because-of-creating-functions-in-render"class="level3"><h3>La crÃ©ation de fonctions Ã  la volÃ©e pendant le rendu ralentit-elle les HooksÂ ?</h3><p>Non. Dans les navigateurs modernes, les performances brutes des fermetures lexicales comparÃ©es Ã  celles des classes diffÃ¨rent peu, sauf dans des scÃ©narios extrÃªmes.<p>Par ailleurs, gardez Ã  l'esprit que la conception de Hooks est plus efficace pour deux raisonsÂ :<ul><li>Les Hooks permettent d'Ã©viter une grande partie de la Â«Â graisseÂ Â» amenÃ©e par les classes, comme le coÃ»t de la crÃ©ation d'instances et la liaison des gestionnaires d'Ã©vÃ©nements dans le constructeur.<li><strong>Le code idiomatique utilisant des Hooks n'a pas besoin d'une imbrication profonde de composants</strong> qui prÃ©vaudrait dans des projets utilisant des composants d'ordre supÃ©rieur, des props de rendu et des contextes. Avec des arborescences plus petites, React a moins de travail Ã  faire.</ul><p>Traditionnellement, les problÃ©matiques de performance associÃ©es aux fonctions dÃ©finies Ã  la volÃ©e en React sont liÃ©es au fait que passer de nouvelles fonctions de rappel Ã  chaque rendu empÃªche les optimisations basÃ©es sur <code>shouldComponentUpdate</code> dans les composants enfants. Les Hooks abordent ce problÃ¨me sous trois angles.<ul><li><p>Le Hook <a href="./hooks-reference.html#usecallback"><code>useCallback</code></a> vous permet de rÃ©fÃ©rencer la mÃªme fonction de rappel dâ€™un rendu Ã  lâ€™autre afin que <code>shouldComponentUpdate</code> puisse continuer Ã  fonctionnerÂ :<pre class="language-js{2}"><code class="language-js{2}">// Ne changera pas sauf si `a` ou `b` change
const memoizedCallback = useCallback(() => {
  doSomething(a, b);
}, [a, b]);</code></pre><li><p>Le <a href="./hooks-faq.html#how-to-memoize-calculations">Hook <code>useMemo</code></a> permet de contrÃ´ler plus facilement les mises Ã  jour des enfants, rÃ©duisant le besoin de composants purs.<li><p>Enfin, le Hook <a href="./hooks-reference.html#usereducer"><code>useReducer</code></a> rÃ©duit le besoin de passer en profondeur des fonctions de rappel, comme expliquÃ© ci-dessous.</ul></section><section id="how-to-avoid-passing-callbacks-down"class="level3"><h3>Comment Ã©viter de transmettre des fonctions de rappelÂ ?</h3><p>Nous nous sommes aperÃ§u que la majoritÃ© des gens n'aiment pas passer des fonctions de rappel Ã  travers chaque niveau de l'arborescence. MÃªme si c'est plus explicite, Ã§a fait franchement Â«Â plomberieÂ Â».<p>Dans de grandes arborescences de composants, nous conseillons plutÃ´t de transmettre une fonction <code>dispatch</code> issue de <a href="./hooks-reference.html#usereducer"><code>useReducer</code></a> via le contexteÂ :<pre class="language-js{4,5}"><code class="language-js{4,5}">const TodosDispatch = React.createContext(null);

function TodosApp() {
  // RemarqueÂ : `dispatch` ne va pas changer d'un rendu Ã  l'autre
  const [todos, dispatch] = useReducer(todosReducer);

  return (
    &#x3C;TodosDispatch.Provider value={dispatch}>
      &#x3C;DeepTree todos={todos} />
    &#x3C;/TodosDispatch.Provider>
  );
}</code></pre><p>Nâ€™importe quel enfant de l'arborescence de <code>TodosApp</code> peut utiliser la fonction <code>dispatch</code> pour remonter des actions Ã  <code>TodosApp</code>Â :<pre class="language-js{2,3}"><code class="language-js{2,3}">function DeepChild(props) {
  // Si nous voulons exÃ©cuter une action, nous pouvons rÃ©cupÃ©rer dispatch depuis le contexte.
  const dispatch = useContext(TodosDispatch);

  function handleClick() {
    dispatch({ type: 'add', text: 'salut' });
  }

  return (
    &#x3C;button onClick={handleClick}>Ajouter une tÃ¢che&#x3C;/button>
  );
}</code></pre><p>C'est Ã  la fois plus pratique d'un point de vue maintenance (pas besoin de continuer Ã  passer des fonctions de rappel), et Ã§a rÃ¨gle au passage le problÃ¨me (de mÃ©moÃ¯sation) des fonctions de rappel. Pour les mises Ã  jour dÃ©clenchÃ©es en profondeur, nous conseillons de transmettre <code>dispatch</code> de cette faÃ§on.<p>Remarquez que vous pouvez toujours choisir de transmettre l'<em>Ã©tat</em> applicatif comme props (plus explicite) ou comme contexte (plus pratique pour les mises Ã  jour trÃ¨s profondes). Si vous utilisez le contexte pour transmettre Ã©galement l'Ã©tat local, utilisez deux types de contexte diffÃ©rentsÂ : la donnÃ©e de contexte <code>dispatch</code> ne changera jamais, donc les composants qui l'utilisent n'ont pas besoin de se rafraÃ®chir Ã  moins qu'ils nâ€™aient aussi besoin de l'Ã©tat applicatif.</section><section id="how-to-read-an-often-changing-value-from-usecallback"class="level3"><h3>Comment lire une valeur changeant frÃ©quemment avec <code>useCallback</code>Â ?</h3><blockquote><p>Remarque<p>Nous recommandons de <a href="#how-to-avoid-passing-callbacks-down">transmettre <code>dispatch</code> dans le contexte</a> plutÃ´t que des fonctions de rappel individuelles dans les props. L'approche ci-dessous n'est mentionnÃ©e que par souci d'exhaustivitÃ© et Ã  titre d'Ã©chappatoire.<p>Notez aussi que cette approche peut causer des problÃ¨mes avec le <a href="/blog/2018/03/27/update-on-async-rendering.html">mode concurrent</a>. Nous prÃ©voyons de proposer des alternatives plus ergonomiques Ã  l'avenir, mais la solution la plus sÃ»re pour l'instant consiste Ã  toujours invalider la fonction de rappel si des valeurs dont elle dÃ©pend changent.</blockquote><p>Dans de rares cas vous pourriez avoir besoin de mÃ©moÃ¯ser une fonction de rappel avec <a href="./hooks-reference.html#usecallback"><code>useCallback</code></a> mais la mÃ©moÃ¯sation ne fonctionne pas trÃ¨s bien parce que la fonction interne a tout de mÃªme trop souvent besoin d'Ãªtre recrÃ©Ã©e. Si la fonction que vous mÃ©moÃ¯sez est un gestionnaire d'Ã©vÃ©nements et n'est pas utilisÃ©e pendant le rendu, vous pouvez utiliser une <a href="#is-there-something-like-instance-variables">ref comme variable d'instance</a>, et y stocker manuellement la derniÃ¨re valeur renvoyÃ©eÂ :<pre class="language-js{6,10}"><code class="language-js{6,10}">function Form() {
  const [text, updateText] = useState('');
  const textRef = useRef();

  useLayoutEffect(() => {
    textRef.current = text; // Ã‰crit dans la ref
  });

  const handleSubmit = useCallback(() => {
    const currentText = textRef.current; // Lit depuis la ref
    alert(currentText);
  }, [textRef]); // Ne recrÃ©e pas handleSubmit comme `[text]` le ferait

  return (
    &#x3C;>
      &#x3C;input value={text} onChange={e => updateText(e.target.value)} />
      &#x3C;ExpensiveTree onSubmit={handleSubmit} />
    &#x3C;/>
  );
}</code></pre><p>C'est une approche un peu biscornue mais Ã§a montre que vous pouvez faire cette optimisation en dernier ressort, si vous en avez vraiment besoin. Vous pouvez en masquer les dÃ©tails dÃ©rangeants en l'extrayant dans un Hook personnalisÃ©Â :<pre class="language-js{4,16}"><code class="language-js{4,16}">function Form() {
  const [text, updateText] = useState('');
  // Sera mÃ©moÃ¯sÃ© mÃªme si `text` changeÂ :
  const handleSubmit = useEventCallback(() => {
    alert(text);
  }, [text]);

  return (
    &#x3C;>
      &#x3C;input value={text} onChange={e => updateText(e.target.value)} />
      &#x3C;ExpensiveTree onSubmit={handleSubmit} />
    &#x3C;/>
  );
}

function useEventCallback(fn, dependencies) {
  const ref = useRef(() => {
    throw new Error('Cannot call an event handler while rendering.');
  });

  useEffect(() => {
    ref.current = fn;
  }, [fn, ...dependencies]);

  return useCallback(() => {
    const fn = ref.current;
    return fn();
  }, [ref]);
}</code></pre><p>Dans les deux cas, nous <strong>dÃ©conseillons cette approche</strong> et ne lâ€™illustrons ici que dans un souci d'exhaustivitÃ©. Au lieu de Ã§a, il est prÃ©fÃ©rable d'<a href="#how-to-avoid-passing-callbacks-down">Ã©viter de transmettre des fonctions de rappel en profondeur</a>.</section></section><section id="under-the-hood"class="level2"><h2>Sous le capot</h2><section id="how-does-react-associate-hook-calls-with-components"class="level3"><h3>Comment React associe-t-il les appels de Hooks avec les composantsÂ ?</h3><p>React garde trace du composant en cours de rendu. GrÃ¢ce aux <a href="./hooks-rules.html">rÃ¨gles des Hooks</a>, nous savons que les Hooks sont uniquement appelÃ©s depuis des composants React (ou des Hooks personnalisÃ©s, qui sont aussi uniquement appelÃ©s depuis des composants React).<p>Il existe une liste interne de Â«Â cellules mÃ©moireÂ Â» associÃ©es Ã  chaque composant. Ce sont juste des objets JavaScript oÃ¹ nous stockons quelques donnÃ©es. Quand vous appelez un Hook tel que <code>useState()</code>, il lit la cellule courante (ou l'initialise pendant le premier rendu), et dÃ©place alors le pointeur sur la prochaine. C'est ainsi que de multiples appels Ã  <code>useState()</code> peuvent avoir chacun un Ã©tat local distinct.</section><section id="what-is-the-prior-art-for-hooks"class="level3"><h3>Quelles sont les sources d'inspiration des HooksÂ ?</h3><p>Les Hooks font la synthÃ¨se dâ€™idÃ©es issues de plusieurs sourcesÂ :<ul><li>Nos prÃ©cÃ©dentes expÃ©riences autour dâ€™API fonctionnelles dans le dÃ©pÃ´t <a href="https://github.com/reactjs/react-future/tree/master/07%20-%20Returning%20State">react-future</a>.<li>Les expÃ©riences de la communautÃ© React avec les API de props de rendu, notamment le <a href="https://github.com/reactions/component">composant Reactions</a> de <a href="https://github.com/ryanflorence">Ryan Florence</a>.<li>La proposition de <a href="https://gist.github.com/trueadm/17beb64288e30192f3aa29cad0218067">mot-clÃ© <code>adopt</code></a> de <a href="https://github.com/trueadm">Dominic Gannaway</a> comme sucre syntaxique pour les props de rendu.<li>Les <a href="http://displayscript.org/introduction.html">variables d'Ã©tat et les cellules Ã  Ã©tat en DisplayScript</a>.<li>Les <a href="https://reasonml.github.io/reason-react/docs/fr/state-actions-reducer.html">composants rÃ©ducteurs</a> de ReasonReact.<li>Les <a href="http://reactivex.io/rxjs/class/es6/Subscription.js~Subscription.html">abonnements</a> <em>(Subscriptions, NdT)</em> en Rx.<li>Les <a href="https://github.com/ocamllabs/ocaml-effects-tutorial#2-effectful-computations-in-a-pure-setting">effets algÃ©briques</a> de OCaml Multicore.</ul><p><a href="https://github.com/sebmarkbage">Sebastian MarkbÃ¥ge</a> a proposÃ© la conception initiale des Hooks, peaufinÃ©e ensuite par <a href="https://github.com/acdlite">Andrew Clark</a>, <a href="https://github.com/sophiebits">Sophie Alpert</a>, <a href="https://github.com/trueadm">Dominic Gannaway</a> et d'autres membres de l'Ã©quipe React. <span style="float:footnote"><a href="./index.html#toc">Go to TOC</a></span></section></section></section>