<!doctype html>
<html lang="fr">
  <head>
    <meta charset="utf-8">
    <title>FAQ des Hooks</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="https://raw.githubusercontent.com/shinokada/prism-coy-theme/main/theme_common.css">
  </head>
  <body>
    <section id="faq-des-hooks" class="level1">
      <h1>FAQ des Hooks</h1>
      <p>Les <em>Hooks</em> sont une nouveauté de React 16.8. Ils permettent de bénéficier d’un état local et d'autres fonctionnalités de React sans avoir à écrire de classes.</p>
      <p>Cette page contient les réponses aux questions les plus fréquentes sur les <a href="./hooks-overview.html">Hooks</a>.</p><!--
        if you ever need to regenerate this, this snippet in the devtools console might help:
      
        $$('.anchor').map(a =>
          `${' '.repeat(2 * +a.parentNode.nodeName.slice(1))}` +
          `[${a.parentNode.textContent}](${a.getAttribute('href')})`
        ).join('\n')
      -->
      <ul>
        <li><strong><a href="#adoption-strategy">Stratégie d'adoption</a></strong>
          <ul>
            <li><a href="#which-versions-of-react-include-hooks">Quelles versions de React incluent les Hooks ?</a></li>
            <li><a href="#do-i-need-to-rewrite-all-my-class-components">Dois-je réécrire tous mes composants à base de classe ?</a></li>
            <li><a href="#what-can-i-do-with-hooks-that-i-couldnt-with-classes">Que puis-je faire avec les Hooks qu'il est impossible de faire avec des classes ?</a></li>
            <li><a href="#how-much-of-my-react-knowledge-stays-relevant">Quelle proportion de mes connaissances en React reste pertinente ?</a></li>
            <li><a href="#should-i-use-hooks-classes-or-a-mix-of-both">Dois-je utiliser des Hooks, des classes ou un mélange des deux ?</a></li>
            <li><a href="#do-hooks-cover-all-use-cases-for-classes">Est-ce que les Hooks couvrent tous les cas d'utilisation des classes ?</a></li>
            <li><a href="#do-hooks-replace-render-props-and-higher-order-components">Est-ce que les Hooks remplacent les props de rendu et les composants d'ordre supérieur ?</a></li>
            <li><a href="#what-do-hooks-mean-for-popular-apis-like-redux-connect-and-react-router">Qu'est-ce que les Hooks changent pour les API populaires telles que Redux <code>connect()</code> et React Router ?</a></li>
            <li><a href="#do-hooks-work-with-static-typing">Est-ce que les Hooks sont compatibles avec le typage statique ?</a></li>
            <li><a href="#how-to-test-components-that-use-hooks">Comment tester des composants utilisant des Hooks ?</a></li>
            <li><a href="#what-exactly-do-the-lint-rules-enforce">Qu'est-ce que les règles de linting imposent ?</a></li>
          </ul>
        </li>
        <li><strong><a href="#from-classes-to-hooks">Des classes aux Hooks</a></strong>
          <ul>
            <li><a href="#how-do-lifecycle-methods-correspond-to-hooks">Quelles sont les correspondances entre les méthodes de cycle de vie et les Hooks ?</a></li>
            <li><a href="#how-can-i-do-data-fetching-with-hooks">Comment charger des données distantes avec les Hooks ?</a></li>
            <li><a href="#is-there-something-like-instance-variables">Existe-t-il un équivalent aux variables d'instances ?</a></li>
            <li><a href="#should-i-use-one-or-many-state-variables">Dois-je utiliser une ou plusieurs variables d'état local ?</a></li>
            <li><a href="#can-i-run-an-effect-only-on-updates">Puis-je exécuter un effet seulement lors des mises à jour ?</a></li>
            <li><a href="#how-to-get-the-previous-props-or-state">Comment récupérer les props ou l'état local précédents ?</a></li>
            <li><a href="#why-am-i-seeing-stale-props-or-state-inside-my-function">Pourquoi vois-je des props ou un état local obsolètes dans ma fonction ?</a></li>
            <li><a href="#how-do-i-implement-getderivedstatefromprops">Comment puis-je implémenter <code>getDerivedStateFromProps</code> ?</a></li>
            <li><a href="#is-there-something-like-forceupdate">Existe-t-il un équivalent à <code>forceUpdate</code> ?</a></li>
            <li><a href="#can-i-make-a-ref-to-a-function-component">Puis-je créer une ref vers une fonction composant ?</a></li>
            <li><a href="#how-can-i-measure-a-dom-node">Comment puis-je mesurer un nœud DOM ?</a></li>
            <li><a href="#what-does-const-thing-setthing--usestate-mean">Que signifie <code>const [thing, setThing] = useState()</code> ?</a></li>
          </ul>
        </li>
        <li><strong><a href="#performance-optimizations">Optimisations des performances</a></strong>
          <ul>
            <li><a href="#can-i-skip-an-effect-on-updates">Puis-je sauter un effet lors des mises à jour ?</a></li>
            <li><a href="#is-it-safe-to-omit-functions-from-the-list-of-dependencies">Est-il acceptable d’omettre les fonctions du tableau de dépendances ?</a></li>
            <li><a href="#what-can-i-do-if-my-effect-dependencies-change-too-often">Que faire quand mes dépendances d’effet changent trop souvent ?</a></li>
            <li><a href="#how-do-i-implement-shouldcomponentupdate">Comment puis-je implémenter <code>shouldComponentUpdate</code> ?</a></li>
            <li><a href="#how-to-memoize-calculations">Comment mémoïser les calculs ?</a></li>
            <li><a href="#how-to-create-expensive-objects-lazily">Comment créer paresseusement des objets coûteux ?</a></li>
            <li><a href="#are-hooks-slow-because-of-creating-functions-in-render">La création de fonctions à la volée pendant le rendu ralentit-elle les Hooks ?</a></li>
            <li><a href="#how-to-avoid-passing-callbacks-down">Comment éviter de transmettre des fonctions de rappel ?</a></li>
            <li><a href="#how-to-read-an-often-changing-value-from-usecallback">Comment lire une valeur changeant fréquemment avec <code>useCallback</code> ?</a></li>
          </ul>
        </li>
        <li><strong><a href="#under-the-hood">Sous le capot</a></strong>
          <ul>
            <li><a href="#how-does-react-associate-hook-calls-with-components">Comment React associe-t-il les appels de Hooks avec les composants ?</a></li>
            <li><a href="#what-is-the-prior-art-for-hooks">Quelles sont les sources d'inspiration des Hooks ?</a></li>
          </ul>
        </li>
      </ul>
      <section id="adoption-strategy" class="level2">
        <h2>Stratégie d'adoption</h2>
        <section id="which-versions-of-react-include-hooks" class="level3">
          <h3>Quelles versions de React incluent les Hooks ?</h3>
          <p>Depuis la version 16.8.0, React embarque une implémentation stable de React Hooks pour :</p>
          <ul>
            <li>React DOM</li>
            <li>React Native</li>
            <li>React DOM Server</li>
            <li>Le moteur de rendu de test de React</li>
            <li>Le moteur de rendu superficiel de React</li>
          </ul>
          <p>Remarquez que <strong>pour activer les Hooks, tous les paquets React doivent être en version 16.8.0 ou supérieure</strong>. Les Hooks ne fonctionneront pas si vous oubliez de mettre à jour React DOM, par exemple.</p>
          <p><a href="https://reactnative.dev/blog/2019/03/12/releasing-react-native-059">React Native 0.59</a> et ultérieurs prennent en charge les Hooks.</p>
        </section>
        <section id="do-i-need-to-rewrite-all-my-class-components" class="level3">
          <h3>Dois-je réécrire tous mes composants à base de classe ?</h3>
          <p>Non. Il n'est <a href="./hooks-intro.html#gradual-adoption-strategy">pas prévu</a> de retirer les classes de React : nous avons tous besoin de continuer à livrer nos produits et ne pouvons pas nous permettre de réécrire tout le code. Nous recommandons d'essayer les Hooks dans de nouveaux composants et projets.</p>
        </section>
        <section id="what-can-i-do-with-hooks-that-i-couldnt-with-classes" class="level3">
          <h3>Que puis-je faire avec les Hooks qu'il est impossible de faire avec des classes ?</h3>
          <p>Les Hooks offrent un nouveau moyen puissant et expressif de réutiliser des fonctionnalités entre composants. <a href="./hooks-custom.html">« Contruire vos propres Hooks »</a> offre un aperçu des possibilités. <a href="https://medium.com/@dan_abramov/making-sense-of-react-hooks-fdbde8803889">Cet article</a> (en anglais) écrit par un membre de l'équipe noyau de React explore plus en détail les nouvelles possibilités apportées par les Hooks.</p>
        </section>
        <section id="how-much-of-my-react-knowledge-stays-relevant" class="level3">
          <h3>Quelle proportion de mes connaissances en React reste pertinente ?</h3>
          <p>Les Hooks sont un moyen plus direct d'utiliser les fonctionnalités de React que vous connaissez déjà, telles que l’état local, le cycle de vie, le contexte et les refs. Ils ne changent pas fondamentalement la façon dont React fonctionne, et vos connaissances des composants, des props, et du flux de données descendant sont toujours valides.</p>
          <p>Les Hooks ont tout de même une courbe d'apprentissage. Si quelque chose manque dans leur documentation, <a href="https://github.com/reactjs/reactjs.org/issues/new">créez un ticket</a> sur le dépôt GitHub et nous essaierons de vous aider.</p>
        </section>
        <section id="should-i-use-hooks-classes-or-a-mix-of-both" class="level3">
          <h3>Dois-je utiliser des Hooks, des classes ou un mélange des deux ?</h3>
          <p>Quand vous serez prêt·e, nous vous conseillons de commencer à essayer les Hooks dans les nouveaux composants que vous écrirez. Assurez-vous que chaque membre de votre équipe soit partant·e pour les utiliser, et à l’aise avec cette documentation. Nous déconseillons de réécrire vos classes existantes avec les Hooks, sauf si vous aviez déjà prévu de les réécrire de toute façon (ex. pour corriger des bugs).</p>
          <p>Vous ne pouvez pas utiliser les Hooks <em>à l'intérieur</em> d'un composant à base de classe, mais vous pouvez complètement mélanger classes et fonctions composants utilisant des Hooks dans une même arborescence. Qu'un composant soit une classe ou une fonction utilisant les Hooks ne constitue qu’un détail d'implémentation de ce composant. Sur le long terme, nous nous attendons à ce que l’essentiel des composants React soient écrits à base de Hooks.</p>
        </section>
        <section id="do-hooks-cover-all-use-cases-for-classes" class="level3">
          <h3>Est-ce que les Hooks couvrent tous les cas d'utilisation des classes ?</h3>
          <p>Notre but est que les Hooks couvrent tous les cas d'utilisation des classes dès que possible. Il n’existe pas pour l'instant d'équivalent en Hook pour les méthodes de cycle de vie moins courantes que sont <code>getSnapshotBeforeUpdate</code>, <code>getDerivedStateFromError</code> et <code>componentDidCatch</code>, mais nous prévoyons de les ajouter rapidement.</p>
          <p>Les Hooks en sont encore à leur débuts, et quelques bibliothèques tierces peuvent ne pas être compatibles avec les Hooks à l'heure actuelle.</p>
        </section>
        <section id="do-hooks-replace-render-props-and-higher-order-components" class="level3">
          <h3>Est-ce que les Hooks remplacent les props de rendu et les composants d'ordre supérieur ?</h3>
          <p>Souvent, les props de rendu et les composants d'ordre supérieur n’affichent qu’un seul enfant. Nous pensons que les Hooks simplifient ce cas d'utilisation. Ces deux approches restent pertinentes (par exemple, un composant de défilement virtuel pourrait avoir une prop <code>renderItem</code>, ou un composant de conteneur visuel pourrait avoir sa propre structure DOM). Mais dans la plupart des cas, les Hooks seront suffisants et pourront aider à réduire l'imbrication dans votre arborescence de composants.</p>
        </section>
        <section id="what-do-hooks-mean-for-popular-apis-like-redux-connect-and-react-router" class="level3">
          <h3>Qu'est-ce que les Hooks changent pour les API populaires telles que Redux <code>connect()</code> et React Router ?</h3>
          <p>Vous pouvez continuer à utiliser les mêmes API que d'habitude ; elles fonctionneront toujours comme avant.</p>
          <p>Depuis sa version v7.1.0, React-Redux <a href="https://react-redux.js.org/api/hooks">prend en charge l'API des Hooks</a> et fournit des Hooks tels que <code>useDispatch</code> et <code>useSelector</code>.</p>
          <p>React Router <a href="https://reacttraining.com/react-router/web/api/Hooks">prend en charge les Hooks</a> depuis sa v5.1.</p>
          <p>D’autres bibliothèques pourront prendre en charge les Hooks à l’avenir.</p>
        </section>
        <section id="do-hooks-work-with-static-typing" class="level3">
          <h3>Est-ce que les Hooks sont compatibles avec le typage statique ?</h3>
          <p>Les Hooks ont été conçus avec le typage statique à l'esprit. Comme ce sont des fonctions, il est plus facile de les typer correctement que d'autres approches telles que les composants d'ordre supérieur. Les dernières définitions Flow et TypeScript pour React prennent en charge les Hooks React.</p>
          <p>Surtout, les Hooks personnalisés vous donnent la possibilité de restreindre l'API React si vous souhaitez les typer de façon plus stricte. React vous fournit des primitives, mais vous pouvez les combiner de façons différentes de celles que nous fournissons d'entrée de jeu.</p>
        </section>
        <section id="how-to-test-components-that-use-hooks" class="level3">
          <h3>Comment tester des composants utilisant des Hooks ?</h3>
          <p>Du point de vue de React, un composant utilisant des Hooks est un composant normal. Si votre solution de test ne repose pas sur des fonctionnements internes de React, tester des composants avec des Hooks ne devrait pas être différent de la façon dont vous testez vos composants habituellement.</p>
          <blockquote>
            <p>Note</p>
            <p><a href="./testing-recipes.html">Testing Recipes</a> inclut plusieurs exemples que vous pouvez copier-coller.</p>
          </blockquote>
          <p>Par exemple, prenons ce composant de comptage :</p>
          <pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Example</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>count<span class="token punctuation">,</span> setCount<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
    <span class="token dom variable">document</span><span class="token punctuation">.</span><span class="token property-access">title</span> <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Vous avez cliqué </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>count<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> fois</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword control-flow">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&#x3C;</span>div<span class="token operator">></span>
      <span class="token operator">&#x3C;</span>p<span class="token operator">></span><span class="token maybe-class-name">Vous</span> avez cliqué <span class="token punctuation">{</span>count<span class="token punctuation">}</span> fois<span class="token operator">&#x3C;</span><span class="token operator">/</span>p<span class="token operator">></span>
      <span class="token operator">&#x3C;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token function">setCount</span><span class="token punctuation">(</span>count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token operator">></span>
        <span class="token maybe-class-name">Cliquez</span> ici
      <span class="token operator">&#x3C;</span><span class="token operator">/</span>button<span class="token operator">></span>
    <span class="token operator">&#x3C;</span><span class="token operator">/</span>div<span class="token operator">></span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
          <p>Nous le testerons en utilisant React DOM. Pour être certains que le comportement correspond à ce qui se passerait dans le navigateur, nous enroberons le code d'affichage et de mise à jour par des appels à <a href="./test-utils.html#act"><code>ReactTestUtils.act()</code></a> :</p>
          <pre class="language-js{3,20-22,29-31}"><code class="language-js{3,20-22,29-31}">import React from 'react';
import ReactDOM from 'react-dom';
import { act } from 'react-dom/test-utils';
import Counter from './Counter';

let container;

beforeEach(() => {
  container = document.createElement('div');
  document.body.appendChild(container);
});

afterEach(() => {
  document.body.removeChild(container);
  container = null;
});

it('can render and update a counter', () => {
  // Test du premier rendu et de son effet
  act(() => {
    ReactDOM.render(&#x3C;Counter />, container);
  });
  const button = container.querySelector('button');
  const label = container.querySelector('p');
  expect(label.textContent).toBe('Vous avez cliqué 0 fois');
  expect(document.title).toBe('Vous avez cliqué 0 fois');

  // Test du second rendu et de son effet
  act(() => {
    button.dispatchEvent(new MouseEvent('click', {bubbles: true}));
  });
  expect(label.textContent).toBe('Vous avez cliqué 1 fois');
  expect(document.title).toBe('Vous avez cliqué 1 fois');
});</code></pre>
          <p>Les appels à <code>act()</code> vont aussi traiter les effets qu'ils contiennent.</p>
          <p>Si vous souhaitez tester un Hook personnalisé, c'est possible en créant un composant dans votre test, et en utilisant le Hook depuis celui-ci. Vous pourrez alors tester le composant que vous venez de créer.</p>
          <p>Pour réduire le code générique, nous vous conseillons d'utiliser <a href="https://testing-library.com/react">React Testing Library</a> qui est conçu de manière à encourager l'écriture de tests utilisant les composants comme le feraient les utilisateurs finaux.</p>
          <p>Pour plus d'information, consultez <a href="./testing-recipes.html">Testing Recipes</a>.</p>
        </section>
        <section id="what-exactly-do-the-lint-rules-enforce" class="level3">
          <h3>Qu'est-ce que les <a href="https://www.npmjs.com/package/eslint-plugin-react-hooks">règles de linting</a> imposent ?</h3>
          <p>Nous mettons à disposition un <a href="https://www.npmjs.com/package/eslint-plugin-react-hooks">plugin ESlint</a> qui impose <a href="./hooks-rules.html">les règles des Hooks</a> pour éviter les bugs. Il part du principe que toute fonction commençant par "<code>use</code>" suivi d'une lettre majuscule est un Hook. Nous admettons que cette heuristique n'est pas parfaite et peut déclencher des faux positifs, mais sans convention au niveau de l'écosystème, il n'existe aucun moyen de faire fonctionner les Hooks correctement—et des noms plus longs décourageront l'adoption des Hooks ou le respect des conventions par la communauté.</p>
          <p>En particulier, la règle impose que :</p>
          <ul>
            <li>Les appels de Hooks soient situés soit à l'intérieur d'une fonction nommée en casse <code>PascalCase</code> (supposée être un composant) ou d'une autre fonction <code>useSomething</code> (supposée être un Hook personnalisé).</li>
            <li>Les Hooks soient appelés dans le même ordre à chaque rendu.</li>
          </ul>
          <p>Il existe quelques autres heuristiques, et elles changeront peut-être avec le temps, au fur et à mesure que nous peaufinons la règle pour améliorer la découverte de bugs tout en évitant les faux positifs.</p>
        </section>
      </section>
      <section id="from-classes-to-hooks" class="level2">
        <h2>Des classes aux Hooks</h2>
        <section id="how-do-lifecycle-methods-correspond-to-hooks" class="level3">
          <h3>Quelles sont les correspondances entre les méthodes de cycle de vie et les Hooks ?</h3>
          <ul>
            <li><code>constructor</code> : les fonctions composants n'ont pas besoin d'un constructeur. Vous pouvez initialiser l'état local lors de l'appel à <a href="./hooks-reference.html#usestate"><code>useState</code></a>. Si le calcul de l'état local initial est trop coûteux, vous pouvez passer une fonction à <code>useState</code>.</li>
            <li><code>getDerivedStateFromProps</code> : planifiez plutôt une mise à jour <a href="#how-do-i-implement-getderivedstatefromprops">pendant le rendu</a>.</li>
            <li><code>shouldComponentUpdate</code> : voyez <code>React.memo</code> <a href="#how-do-i-implement-shouldcomponentupdate">ci-dessous</a>.</li>
            <li><code>render</code> : c'est le corps-même de la fonction composant.</li>
            <li><code>componentDidMount</code>, <code>componentDidUpdate</code>, <code>componentWillUnmount</code> : le <a href="./hooks-reference.html#useeffect">Hook <code>useEffect</code></a> peut exprimer toutes les combinaisons de celles-ci (y compris des cas <a href="#can-i-skip-an-effect-on-updates">moins</a> <a href="#can-i-run-an-effect-only-on-updates">fréquents</a>).</li>
            <li><code>getSnapshotBeforeUpdate</code>, <code>componentDidCatch</code> et <code>getDerivedStateFromError</code> : il n'existe pas encore de Hook équivalent pour ces méthodes, mais ils seront ajoutés prochainement.</li>
          </ul>
        </section>
        <section id="how-can-i-do-data-fetching-with-hooks" class="level3">
          <h3>Comment charger des données distantes avec les Hooks ?</h3>
          <p>Voici une <a href="https://codesandbox.io/s/jvvkoo8pq3">petite démo</a> pour vous aider à démarrer. Pour en apprendre davantage, jetez un œil à <a href="https://www.robinwieruch.de/react-hooks-fetch-data/">cet article</a> (en anglais) sur le chargement de données distantes avec les Hooks.</p>
        </section>
        <section id="is-there-something-like-instance-variables" class="level3">
          <h3>Existe-t-il un équivalent aux variables d'instances ?</h3>
          <p>Oui ! Le Hook <a href="./hooks-reference.html#useref"><code>useRef()</code></a> n'est pas seulement pour les refs au DOM. L'objet "ref" est un conteneur générique dont la propriété <code>current</code> est modifiable et peut contenir n'importe quelle valeur, de la même façon qu'une propriété d'instance dans une classe.</p>
          <p>Vous pouvez lui affecter une valeur depuis <code>useEffect</code> :</p>
          <pre class="language-js{2,8}"><code class="language-js{2,8}">function Timer() {
  const intervalRef = useRef();

  useEffect(() => {
    const id = setInterval(() => {
      // ...
    });
    intervalRef.current = id;
    return () => {
      clearInterval(intervalRef.current);
    };
  });

  // ...
}</code></pre>
          <p>Si nous avions juste voulu définir une horloge, nous n'aurions pas eu besoin de la ref (<code>id</code> pouvait rester local à l'effet) mais ça peut être utile si nous voulons arrêter l'horloge depuis un gestionnaire d’événements.</p>
          <pre class="language-js{3}"><code class="language-js{3}">  // ...
  function handleCancelClick() {
    clearInterval(intervalRef.current);
  }
  // ...</code></pre>
          <p>Conceptuellement, vous pouvez vous représenter les refs comme des variables d'instance dans une classe. À moins que vous n'ayez recours à de l'<a href="#how-to-create-expensive-objects-lazily">initialisation paresseuse</a>, évitez d’écrire dans vos refs pendant le rendu : ça peut donner des comportements hasardeux. Au lieu de ça, vous voudrez généralement modifier les refs au sein de gestionnaires d'événements ou d’effets.</p>
        </section>
        <section id="should-i-use-one-or-many-state-variables" class="level3">
          <h3>Dois-je utiliser une ou plusieurs variables d'état local ?</h3>
          <p>Si vous avez l'habitude des classes, vous serez peut-être tenté·e de toujours appeler <code>useState()</code> une seule fois, en mettant tout l'état local dans un unique objet. Si vous y tenez, c'est tout à fait possible. Voici un exemple d'un composant qui piste le mouvement de la souris. Nous gardons sa position et sa taille dans l'état local :</p>
          <pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Box</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>state<span class="token punctuation">,</span> setState<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token literal-property property">left</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token literal-property property">top</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token literal-property property">width</span><span class="token operator">:</span> <span class="token number">100</span><span class="token punctuation">,</span> <span class="token literal-property property">height</span><span class="token operator">:</span> <span class="token number">100</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span></code></pre>
          <p>Maintenant, disons que nous voulons écrire un bout de code pour modifier <code>left</code> et <code>top</code> quand l'utilisateur bouge la souris. Voyez comme nous devons fusionner manuellement ces champs dans l'état local précédent :</p>
          <pre class="language-js{4,5}"><code class="language-js{4,5}">  // ...
  useEffect(() => {
    function handleWindowMouseMove(e) {
      // La décomposition de "...state" permet de s’assurer qu’on ne « perd » pas width et height
      setState(state => ({ ...state, left: e.pageX, top: e.pageY }));
    }
    // Remarque : cette implémentation est un peu simplifiée
    window.addEventListener('mousemove', handleWindowMouseMove);
    return () => window.removeEventListener('mousemove', handleWindowMouseMove);
  }, []);
  // ...</code></pre>
          <p>C'est dû au fait que lorsque nous mettons à jour une variable de l'état local, nous <em>remplaçons</em> sa valeur, alors qu’avec <code>this.setState</code> dans une classe, on <em>fusionne</em> les champs mis à jour dans l'objet.</p>
          <p>Si la fusion automatique vous manque, vous pouvez écrire un Hook personnalisé <code>useLegacyState</code> qui fusionne les mises à jour de l'état local. Cependant, <strong>nous recommandons plutôt de séparer l'état local en de multiple variables d'état en se basant sur celles qui ont tendance à changer de valeur ensemble</strong>.</p>
          <p>Par exemple, nous pourrions découper l'état local de notre composant en deux objets <code>position</code> et <code>size</code>, et toujours remplacer la <code>position</code> sans avoir besoin de fusionner :</p>
          <pre class="language-js{2,7}"><code class="language-js{2,7}">function Box() {
  const [position, setPosition] = useState({ left: 0, top: 0 });
  const [size, setSize] = useState({ width: 100, height: 100 });

  useEffect(() => {
    function handleWindowMouseMove(e) {
      setPosition({ left: e.pageX, top: e.pageY });
    }
    // ...</code></pre>
          <p>Séparer les variables d'état indépendantes présente un intérêt supplémentaire : il devient facile d'extraire une partie de la logique dans un Hook personnalisé, par exemple :</p>
          <pre class="language-js{2,7}"><code class="language-js{2,7}">function Box() {
  const position = useWindowPosition();
  const [size, setSize] = useState({ width: 100, height: 100 });
  // ...
}

function useWindowPosition() {
  const [position, setPosition] = useState({ left: 0, top: 0 });
  useEffect(() => {
    // ...
  }, []);
  return position;
}</code></pre>
          <p>Remarquez comme nous avons pu déplacer l'appel à <code>useState</code> pour la variable d'état local <code>position</code> et l'effet associé dans un Hook personnalisé sans rien changer au code. Si tout l'état local était un unique objet, extraire cet aspect aurait été plus difficile.</p>
          <p>Les deux approches sont possibles : mettre tout l'état local dans un unique appel à <code>useState</code> ou avoir un appel à <code>useState</code> par champ. La lisibilité des composants sera fonction de l'équilibre que vous trouverez entre ces deux extrêmes, et du regroupement des états locaux associés en quelques variables d'état indépendantes. Si la logique de l'état local devient trop complexe, nous vous conseillons de plutôt la <a href="./hooks-reference.html#usereducer">gérer avec un réducteur</a> ou un Hook personnalisé.</p>
        </section>
        <section id="can-i-run-an-effect-only-on-updates" class="level3">
          <h3>Puis-je exécuter un effet seulement lors des mises à jour ?</h3>
          <p>C'est un cas d'utilisation assez rare. Si vous en avez besoin, vous pouvez <a href="#is-there-something-like-instance-variables">utiliser une ref modifiable</a> pour stocker manuellement un booléen indiquant si vous êtes sur le premier rendu ou un rendu postérieur, et vérifier ensuite ce drapeau dans votre effet. (Si vous faites ça régulièrement, vous voudrez sans doute créer un Hook personnalisé pour ça.)</p>
        </section>
        <section id="how-to-get-the-previous-props-or-state" class="level3">
          <h3>Comment récupérer les props ou l'état local précédents ?</h3>
          <p>Actuellement, vous pouvez le faire manuellement <a href="#is-there-something-like-instance-variables">avec une ref</a> :</p>
          <pre class="language-js{6,8}"><code class="language-js{6,8}">function Counter() {
  const [count, setCount] = useState(0);

  const prevCountRef = useRef();
  useEffect(() => {
    prevCountRef.current = count;
  });
  const prevCount = prevCountRef.current;

  return &#x3C;h1>Maintenant : {count}, avant : {prevCount}&#x3C;/h1>;
}</code></pre>
          <p>Ça peut sembler un peu biscornu mais vous pouvez l'extraire dans un Hook personnalisé :</p>
          <pre class="language-js{3,7}"><code class="language-js{3,7}">function Counter() {
  const [count, setCount] = useState(0);
  const prevCount = usePrevious(count);
  return &#x3C;h1>Maintenant : {count}, avant : {prevCount}&#x3C;/h1>;
}

function usePrevious(value) {
  const ref = useRef();
  useEffect(() => {
    ref.current = value;
  });
  return ref.current;
}</code></pre>
          <p>Remaquez que ça fonctionne pour les props, l'état local, et toute autre valeur calculée.</p>
          <pre class="language-js{5}"><code class="language-js{5}">function Counter() {
  const [count, setCount] = useState(0);

  const calculation = count + 100;
  const prevCalculation = usePrevious(calculation);
  // ...</code></pre>
          <p>Il est possible qu’à l'avenir React fournisse un Hook <code>usePrevious</code> prêt à l'emploi, puisque c'est un cas d'usage assez fréquent.</p>
          <p>Voir aussi <a href="#how-do-i-implement-getderivedstatefromprops">l’approche recommandée pour un état local dérivé</a>.</p>
        </section>
        <section id="why-am-i-seeing-stale-props-or-state-inside-my-function" class="level3">
          <h3>Pourquoi vois-je des props ou un état local obsolètes dans ma fonction ?</h3>
          <p>Toute fonction au sein d'un composant, y compris les gestionnaires d'événements et les effets, « voit » les props et l'état local en vigueur lors du rendu qui les a créées. Par exemple, prenez ce genre de code :</p>
          <pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Example</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>count<span class="token punctuation">,</span> setCount<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">function</span> <span class="token function">handleAlertClick</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
      <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'Vous avez cliqué à '</span> <span class="token operator">+</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword control-flow">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&#x3C;</span>div<span class="token operator">></span>
      <span class="token operator">&#x3C;</span>p<span class="token operator">></span><span class="token maybe-class-name">Vous</span> avez cliqué <span class="token punctuation">{</span>count<span class="token punctuation">}</span> fois<span class="token operator">&#x3C;</span><span class="token operator">/</span>p<span class="token operator">></span>
      <span class="token operator">&#x3C;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token function">setCount</span><span class="token punctuation">(</span>count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token operator">></span>
        <span class="token maybe-class-name">Cliquez</span> ici
      <span class="token operator">&#x3C;</span><span class="token operator">/</span>button<span class="token operator">></span>
      <span class="token operator">&#x3C;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span>handleAlertClick<span class="token punctuation">}</span><span class="token operator">></span>
        <span class="token maybe-class-name">Afficher</span> un message
      <span class="token operator">&#x3C;</span><span class="token operator">/</span>button<span class="token operator">></span>
    <span class="token operator">&#x3C;</span><span class="token operator">/</span>div<span class="token operator">></span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
          <p>Si vous cliquez d’abord sur « Afficher un message » puis incrémentez tout de suite le compteur, le message affichera la variable <code>count</code> <strong>telle qu’elle était lors du clic sur le bouton « Afficher un message »</strong>. Ça évite les bugs causés par du code qui suppose que les props et l'état local ne changent pas.</p>
          <p>Si vous souhaitez explicitement lire le <strong>tout dernier</strong> état depuis une fonction de rappel asynchrone, vous pouvez le conserver dans <a href="./hooks-faq.html#is-there-something-like-instance-variables">une ref</a>, la modifier puis la relire.</p>
          <p>Pour finir, une autre explication possible pour vos props ou votre état périmés résiderait dans votre utilisation incorrecte de l’optimisation du hook par « tableau de dépendances », auquel il manquerait certaines valeurs. Par exemple, si un effet indique <code>[]</code> comme deuxième argument mais lit <code>someProp</code> en interne, il continuera à « voir » la valeur initiale de <code>someProp</code>. La solution consiste soit à retirer l'argument de tableau de dépendances, soit à le corriger. Voici <a href="#is-it-safe-to-omit-functions-from-the-list-of-dependencies">comment y gérer des fonctions</a> ainsi que <a href="#what-can-i-do-if-my-effect-dependencies-change-too-often">d’autres stratégies habituelles</a> pour exécuter des effets moins souvent sans ignorer à tort des dépendances.</p>
          <blockquote>
            <p>Remarque</p>
            <p>Nous proposons une règle ESLint <a href="https://github.com/facebook/react/issues/14920"><code>exhaustive-deps</code></a> dans le cadre du module <a href="https://www.npmjs.com/package/eslint-plugin-react-hooks#installation"><code>eslint-plugin-react-hooks</code></a>. Elle vous avertit lorsque les dépendances spécifiées semblent incorrectes et vous propose un correctif.</p>
          </blockquote>
        </section>
        <section id="how-do-i-implement-getderivedstatefromprops" class="level3">
          <h3>Comment puis-je implémenter <code>getDerivedStateFromProps</code> ?</h3>
          <p>Même si vous n'en avez probablement <a href="/blog/2018/06/07/you-probably-dont-need-derived-state.html">pas besoin</a>, dans les rares cas où c'est nécessaire (comme implémenter un composant <code>&#x3C;Transition></code>) vous pouvez mettre à jour l'état local en plein rendu. React va rafraîchir le composant avec l'état local mis à jour immédiatement après être sorti du premier rendu afin que ça ne soit pas trop coûteux.</p>
          <p>Ici, nous stockons la valeur précédente de la prop <code>row</code> dans une variable de l'état local afin que nous puissions les comparer :</p>
          <pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">ScrollView</span></span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span>row<span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>isScrollingDown<span class="token punctuation">,</span> setIsScrollingDown<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>prevRow<span class="token punctuation">,</span> setPrevRow<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token keyword null nil">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>row <span class="token operator">!==</span> prevRow<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// Row a changé depuis le dernier rendu. Met à jour isScrollingDown.</span>
    <span class="token function">setIsScrollingDown</span><span class="token punctuation">(</span>prevRow <span class="token operator">!==</span> <span class="token keyword null nil">null</span> <span class="token operator">&#x26;&#x26;</span> row <span class="token operator">></span> prevRow<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">setPrevRow</span><span class="token punctuation">(</span>row<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword control-flow">return</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">On défile vers le bas : </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>isScrollingDown<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
          <p>Ça peut sembler étrange à première vue, mais <code>getDerivedStateFromProps</code> avait précisément été conçue pour des mises à jour pendant le rendu.</p>
        </section>
        <section id="is-there-something-like-forceupdate" class="level3">
          <h3>Existe-t-il un équivalent à forceUpdate ?</h3>
          <p>Les deux Hooks <code>useState</code> et <code>useReducer</code> <a href="./hooks-reference.html#bailing-out-of-a-state-update">abandonnent la mise à jour</a> si la valeur suivante est la même que la valeur précédente. Modifier l'état local en place et appeler <code>setState</code> ne causera pas de rafraîchissement.</p>
          <p>Généralement, vous ne devez pas modifier l'état local directement en React. Cependant, à titre d'échappatoire, vous pouvez maintenir un compteur incrémental pour forcer un rafraîchissement même si l'état local n'a pas changé :</p>
          <pre class="language-js"><code class="language-js">  <span class="token keyword">const</span> <span class="token punctuation">[</span>ignored<span class="token punctuation">,</span> forceUpdate<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useReducer</span><span class="token punctuation">(</span><span class="token parameter">x</span> <span class="token arrow operator">=></span> x <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">function</span> <span class="token function">handleClick</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">forceUpdate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span></code></pre>
          <p>Évitez autant que possible d'utiliser cette approche.</p>
        </section>
        <section id="can-i-make-a-ref-to-a-function-component" class="level3">
          <h3>Puis-je créer une ref vers une fonction composant ?</h3>
          <p>Vous ne devriez pas en avoir besoin souvent, mais vous pouvez exposer quelques méthodes impératives à un composant parent avec le Hook <a href="./hooks-reference.html#useimperativehandle"><code>useImperativeHandle</code></a>.</p>
        </section>
        <section id="how-can-i-measure-a-dom-node" class="level3">
          <h3>Comment puis-je mesurer un nœud DOM ?</h3>
          <p>Une façon rudimentaire de mesurer la position ou les dimensions d’un nœud DOM consiste à utiliser une <a href="./refs-and-the-dom.html#callback-refs">ref avec fonction de rappel</a>. React appellera la fonction de rappel chaque fois que la ref est attachée à un nœud différent. Voici une <a href="https://codesandbox.io/s/l7m0v5x4v9">petite démo</a> :</p>
          <pre class="language-js{4-8,12}"><code class="language-js{4-8,12}">function MeasureExample() {
  const [height, setHeight] = useState(0);

  const measuredRef = useCallback(node => {
    if (node !== null) {
      setHeight(node.getBoundingClientRect().height);
    }
  }, []);

  return (
    &#x3C;>
      &#x3C;h1 ref={measuredRef}>Bonjour, monde&#x3C;/h1>
      &#x3C;h2>L’en-tête ci-dessus fait {Math.round(height)}px de haut&#x3C;/h2>
    &#x3C;/>
  );
}</code></pre>
          <p>Nous avons évité <code>useRef</code> dans cet exemple parce qu’un objet ref ne nous notifie pas des <em>changements</em> de la valeur actuelle de la ref. Une ref avec fonction de rappel garantit que <a href="https://codesandbox.io/s/818zzk8m78">même si un composant enfant affiche ultérieurement le nœud DOM mesuré</a> (ex. en réaction à un clic), nous serons quand même notifiés dans le composant parent et pourrons mettre les mesures à jour.</p>
          <p>Remarquez que nous passons <code>[]</code> comme tableau de dépendances à <code>useCallback</code>. C’est pour nous assurer que notre ref à fonction de rappel ne change pas d’un rendu à l’autre, afin que React ne nous appelle pas pour rien.</p>
          <p>Dans cet exemple, la ref avec fonction de rappel ne sera appelée que lors du montage et du démontage du composant, puisque le composant <code>&#x3C;h1></code> reste présent d’un rendu au suivant. Si vous souhaitez être notifié·e à chaque redimensionnement, vous voudrez peut-être utiliser <a href="https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserver"><code>ResizeObserver</code></a> ou un Hook tiers basé dessus.</p>
          <p>Si vous le souhaitez, vous pouvez <a href="https://codesandbox.io/s/m5o42082xy">extraire cette logique</a> dans un Hook réutilisable :</p>
          <pre class="language-js{2}"><code class="language-js{2}">function MeasureExample() {
  const [rect, ref] = useClientRect();
  return (
    &#x3C;>
      &#x3C;h1 ref={ref}>Bonjour, monde&#x3C;/h1>
      {rect !== null &#x26;&#x26;
        &#x3C;h2>L’en-tête ci-dessus fait {Math.round(rect.height)}px de haut&#x3C;/h2>
      }
    &#x3C;/>
  );
}

function useClientRect() {
  const [rect, setRect] = useState(null);
  const ref = useCallback(node => {
    if (node !== null) {
      setRect(node.getBoundingClientRect());
    }
  }, []);
  return [rect, ref];
}</code></pre>
        </section>
        <section id="what-does-const-thing-setthing--usestate-mean" class="level3">
          <h3>Que signifie <code>const [thing, setThing] = useState()</code> ?</h3>
          <p>Si vous n’avez pas l'habitude de cette syntaxe, allez voir l'<a href="./hooks-state.html#tip-what-do-square-brackets-mean">explication</a> dans la documentation du Hook d’état.</p>
        </section>
      </section>
      <section id="performance-optimizations" class="level2">
        <h2>Optimisations des performances</h2>
        <section id="can-i-skip-an-effect-on-updates" class="level3">
          <h3>Puis-je sauter un effet lors des mises à jour ?</h3>
          <p>Oui. Reportez-vous au <a href="./hooks-reference.html#conditionally-firing-an-effect">déclenchement conditionnel d'un effet</a>. Remarquez qu'oublier de gérer des mises à jour est souvent <a href="./hooks-effect.html#explanation-why-effects-run-on-each-update">source de bugs</a>, ce qui explique pourquoi ce n'est pas le comportement par défaut.</p>
        </section>
        <section id="is-it-safe-to-omit-functions-from-the-list-of-dependencies" class="level3">
          <h3>Est-il acceptable d’omettre les fonctions du tableau de dépendances ?</h3>
          <p>En règle générale, non.</p>
          <pre class="language-js{3,8}"><code class="language-js{3,8}">function Example({ someProp }) {
  function doSomething() {
    console.log(someProp);
  }

  useEffect(() => {
    doSomething();
  }, []); // 🔴 Ce n’est pas fiable (ça appelle `doSomething` qui utilise `someProp`)
}</code></pre>
          <p>Il n’est pas facile de se souvenir du détail des props et de l'état local utilisés par les fonctions hors de l'effet. C'est pourquoi <strong>vous voudrez généralement déclarer les fonctions dont votre effet a besoin <em>à l’intérieur de celui-ci</em>.</strong> Il devient alors facile de voir de quelles valeurs de la portée du composant dépend cet effet :</p>
          <pre class="language-js{4,8}"><code class="language-js{4,8}">function Example({ someProp }) {
  useEffect(() => {
    function doSomething() {
      console.log(someProp);
    }

    doSomething();
  }, [someProp]); // ✅ OK (notre effet n’utilise que `someProp`)
}</code></pre>
          <p>Si après ça vous n’utilisez toujours pas de valeurs issues de la portée du composant, vous pouvez sans problème spécifier <code>[]</code> :</p>
          <pre class="language-js{7}"><code class="language-js{7}">useEffect(() => {
  function doSomething() {
    console.log('bonjour');
  }

  doSomething();
}, []); // ✅ OK dans ce cas précis car nous n’utilisons *aucune* valeur de la portée du composant</code></pre>
          <p>Selon votre cas, vous trouverez quelques options supplémentaires plus bas dans cette page.</p>
          <blockquote>
            <p>Remarque</p>
            <p>Nous mettons à disposition la règle ESLint <a href="https://github.com/facebook/react/issues/14920"><code>exhaustive-deps</code></a> dans le cadre du module <a href="https://www.npmjs.com/package/eslint-plugin-react-hooks#installation"><code>eslint-plugin-react-hooks</code></a>. Elle vous aide à trouver les composants qui ne gèrent pas correctement les mises à jour.</p>
          </blockquote>
          <p>Voyons en quoi c’est important.</p>
          <p>Si vous précisez une <a href="./hooks-reference.html#conditionally-firing-an-effect">liste de dépendances</a> comme dernier argument de <code>useEffect</code>, <code>useLayoutEffet</code>, <code>useMemo</code>, <code>useCallback</code>, ou <code>useImperativeHandle</code>, cette liste doit inclure toutes les valeurs utilisées dans la fonction passée qui participent au flux de données de React. Ça inclut les props, l'état local, et toute valeur qui en découle.</p>
          <p>Le <strong>seul cas</strong> pour lequel vous pouvez sereinement omettre une fonction de la liste des dépendances, c'est lorsque rien à l'intérieur (y compris dans les autres fonctions qu'elle appelle) ne référence les props, l'état local ou des valeurs qui en découlent. L'exemple suivant a ce problème :</p>
          <pre class="language-js{5,12}"><code class="language-js{5,12}">function ProductPage({ productId }) {
  const [product, setProduct] = useState(null);

  async function fetchProduct() {
    const response = await fetch('http://myapi/product/' + productId); // Utilise la prop productId
    const json = await response.json();
    setProduct(json);
  }

  useEffect(() => {
    fetchProduct();
  }, []); // 🔴 Erroné car `fetchProduct` utilise `productId`
  // ...
}</code></pre>
          <p><strong>Le correctif recommandé consiste à déplacer la fonction <em>dans</em> votre effet</strong>. Ça facilite le repérage des props et variables d'état que votre effet utilise, pour garantir qu'elles sont toutes déclarées :</p>
          <pre class="language-js{5-10,13}"><code class="language-js{5-10,13}">function ProductPage({ productId }) {
  const [product, setProduct] = useState(null);

  useEffect(() => {
    // En déplaçant cette fonction dans l'effet, on voit clairement quelles valeurs il utilise.
    async function fetchProduct() {
      const response = await fetch('http://myapi/product/' + productId);
      const json = await response.json();
      setProduct(json);
    }

    fetchProduct();
  }, [productId]); // ✅ Correct car notre effet n’utilise que `productId`
  // ...
}</code></pre>
          <p>Ça permet aussi de gérer les réponses trop tardives grâce à des variables locales à l'effet :</p>
          <pre class="language-js{2,6,10}"><code class="language-js{2,6,10}">  useEffect(() => {
    let ignore = false;
    async function fetchProduct() {
      const response = await fetch('http://myapi/product/' + productId);
      const json = await response.json();
      if (!ignore) setProduct(json);
    }

    fetchProduct();
    return () => { ignore = true };
  }, [productId]);</code></pre>
          <p>Nous avons déplacé la fonction dans l'effet, donc cette variable n'a pas à figurer dans la liste des dépendances.</p>
          <blockquote>
            <p>Astuce</p>
            <p>Jetez un coup d’œil à <a href="https://codesandbox.io/s/jvvkoo8pq3">cette petite démo</a> et <a href="https://www.robinwieruch.de/react-hooks-fetch-data/">cet article</a> (en anglais) pour en apprendre davantage sur le chargement de données distantes avec les Hooks.</p>
          </blockquote>
          <p><strong>Si pour une raison ou une autre vous ne <em>pouvez pas</em> déplacer la fonction dans l'effet, vous avez d'autres options :</strong></p>
          <ul>
            <li><strong>Vous pouvez essayer de déplacer la fonction hors du composant</strong>. Dans ce cas, vous êtes sûr·e qu’elle ne pourra pas référencer des props ou variables d'état, et qu’elle n'a donc pas besoin de figurer dans la liste des dépendances.</li>
            <li>Si la fonction que vous appelez est un calcul pur et qu'on peut sereinement l'appeler pendant le rendu, vous pouvez <strong>l'appeler plutôt hors de l'effet</strong> et faire dépendre l'effet de la valeur qu'elle renvoie.</li>
            <li>En dernier recours, vous pouvez <strong>ajouter une fonction aux dépendances de l'effet mais <em>enrober sa définition</em></strong> dans un Hook <a href="./hooks-reference.html#usecallback"><code>useCallback</code></a>. Ça garantit qu'elle ne changera pas à chaque rendu sauf si <em>ses propres</em> dépendances changent aussi :</li>
          </ul>
          <pre class="language-js{2-5}"><code class="language-js{2-5}">function ProductPage({ productId }) {
  // ✅ Enrobe avec useCallback pour éviter de changer à chaque rendu
  const fetchProduct = useCallback(() => {
    // ... Fait un truc avec productId ...
  }, [productId]); // ✅ Toutes les dépendances de useCallback sont spécifiées

  return &#x3C;ProductDetails fetchProduct={fetchProduct} />;
}

function ProductDetails({ fetchProduct }) {
  useEffect(() => {
    fetchProduct();
  }, [fetchProduct]); // ✅ Toutes les dépendances de useEffect sont spécifiées
  // ...
}</code></pre>
          <p>Remarquez que dans cet exemple nous <strong>devons</strong> garder la fonction dans la liste des dépendances. On s'assure ainsi qu'une modification à la prop <code>productId</code> de <code>ProductPage</code> déclenchera automatiquement un nouveau chargement de données distantes dans le composant <code>ProductDetails</code>.</p>
        </section>
        <section id="what-can-i-do-if-my-effect-dependencies-change-too-often" class="level3">
          <h3>Que faire quand mes dépendances d’effet changent trop souvent ?</h3>
          <p>Il arrive que votre effet utilise un état qui change trop fréquemment. Vous pourriez alors être tenté·e d’omettre cet état de la liste des dépendances, mais ça engendre souvent des bugs :</p>
          <pre class="language-js{6,9}"><code class="language-js{6,9}">function Counter() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    const id = setInterval(() => {
      setCount(count + 1); // Cet effet dépend de l’état `count`
    }, 1000);
    return () => clearInterval(id);
  }, []); // 🔴 Bug : `count` n’est pas listé comme dépendance

  return &#x3C;h1>{count}&#x3C;/h1>;
}</code></pre>
          <p>La liste de dépendances vide, <code>[]</code>, singifie que l’effet ne sera exécuté qu’une fois au montage du composant, et non à chaque rafraîchissement. Le problème vient du fait que dans la fonction de rappel passée à <code>setInterval</code>, la valeur de <code>count</code> ne va pas changer, car on a créé une fermeture lexicale <em>(closure, NdT)</em> avec <code>count</code> à <code>0</code>, tel qu’elle était lorsque la fonction de rappel de l’effet s’est exécutée. À chaque seconde, cette fonction appelle <code>setCount(0 + 1)</code>, de sorte que le compteur ne dépasse jamais 1.</p>
          <p>On pourrait corriger le bug en spécifiant <code>[count]</code> comme liste de dépendances, mais ça réinitialiserait notre horloge à chaque modification. En pratique, chaque <code>setInterval</code> aurait une chance de s’exécuter avant d’être réinitialisé (comme pour un <code>setTimeout</code>). Ce n’est peut-être pas souhaitable. Pour corriger ça, nous pouvons utiliser <a href="./hooks-reference.html#functional-updates">la version basée fonction de <code>setState</code></a>. Elle nous permet d’indiquer <em>comment</em> l’état change, sans référencer l’état <em>actuel</em> :</p>
          <pre class="language-js{6,9}"><code class="language-js{6,9}">function Counter() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    const id = setInterval(() => {
      setCount(c => c + 1); // ✅ Ça ne dépend pas de la variable `count` issue de la portée
    }, 1000);
    return () => clearInterval(id);
  }, []); // ✅ Notre effet n’utilise aucune variable issue de la portée du composant

  return &#x3C;h1>{count}&#x3C;/h1>;
}</code></pre>
          <p>(L’identité de la fonction <code>setCount</code> est garantie stable, il est donc naturel de l’omettre.)</p>
          <p>À présent, la fonction de rappel de <code>setInterval</code> est appelée une fois par seconde, mais à chaque fois l’appel interne à <code>setCount</code> peut utiliser une valeur à jour de <code>count</code> (appelée <code>c</code> dans la fonction de rappel ci-dessus).</p>
          <p>Pour des cas plus complexes (comme lorsqu’un état dépend d'un autre état), essayez de déplacer la logique de mise à jour de l'état hors de l'effet avec le <a href="./hooks-reference.html#usereducer">Hook <code>useReducer</code></a>. <a href="https://adamrackis.dev/state-and-use-reducer/">Cet article</a> (en anglais) vous donne un exemple de cette approche. <strong>L’identité de la fonction <code>dispatch</code> fournie par <code>useReducer</code> est garantie stable</strong>, même si la fonction de réduction est déclarée dans le composant et lit ses props.</p>
          <p>En dernier recours, si vous voulez quelque chose de similaire au <code>this</code> d’une classe, vous pouvez <a href="./hooks-faq.html#is-there-something-like-instance-variables">utiliser une ref</a> pour stocker une donnée modifiable. Vous pouvez alors y écrire et la relire. Par exemple :</p>
          <pre class="language-js{2-6,10-11,16}"><code class="language-js{2-6,10-11,16}">function Example(props) {
  // Garde les dernières props dans une ref.
  const latestProps = useRef(props);
  useEffect(() => {
    latestProps.current = props;
  });

  useEffect(() => {
    function tick() {
      // Lit les dernières props en vigueur
      console.log(latestProps.current);
    }

    const id = setInterval(tick, 1000);
    return () => clearInterval(id);
  }, []); // Cet effet n’est jamais ré-exécuté
}</code></pre>
          <p>Ne faites ça que si vous n'avez pas pu trouver de meilleure solution, car se reposer sur des mutations rend les composants plus imprévisibles. Si vous n'arrivez pas à trouver une approche adaptée pour votre besoin, <a href="https://github.com/facebook/react/issues/new">créez un ticket</a> avec un exemple exécutable de code pour que nous puissions essayer de vous aider.</p>
        </section>
        <section id="how-do-i-implement-shouldcomponentupdate" class="level3">
          <h3>Comment puis-je implémenter shouldComponentUpdate ?</h3>
          <p>Vous pouvez enrober une fonction composant avec <code>React.memo</code> pour comparer superficiellement ses props :</p>
          <pre class="language-js"><code class="language-js"><span class="token keyword">const</span> <span class="token maybe-class-name">Button</span> <span class="token operator">=</span> <span class="token maybe-class-name">React</span><span class="token punctuation">.</span><span class="token method function property-access">memo</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
  <span class="token comment">// votre composant</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
          <p>Ce n'est pas un Hook car ce n'est pas composable, alors que les Hooks le sont. <code>React.memo</code> est équivalent à <code>PureComponent</code>, mais ne compare que les props. (Vous pouvez aussi ajouter un second argument pour spécifier une fonction de comparaison personnalisée qui prendra en arguments les anciennes et nouvelles props. Si elle renvoie <code>true</code>, la mise à jour est évitée.)</p>
          <p><code>React.memo</code> ne compare pas l'état local car il n'y a pas d’unique objet d'état local à comparer. Mais vous pouvez rendre les descendants purs également, ou même <a href="./hooks-faq.html#how-to-memoize-calculations">optimiser les descendants individuellement avec <code>useMemo</code></a>.</p>
        </section>
        <section id="how-to-memoize-calculations" class="level3">
          <h3>Comment mémoïser les calculs ?</h3>
          <p>Le Hook <a href="./hooks-reference.html#usememo"><code>useMemo</code></a> vous permet de mettre en cache les calculs à travers les rendus en « se souvenant » du dernier calcul :</p>
          <pre class="language-js"><code class="language-js"><span class="token keyword">const</span> memoizedValue <span class="token operator">=</span> <span class="token function">useMemo</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token function">computeExpensiveValue</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>a<span class="token punctuation">,</span> b<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
          <p>Ce code appelle <code>computeExpensiveValue(a, b)</code>. Mais si les dépendances <code>[a, b]</code> n'ont pas changé depuis la dernière fois, <code>useMemo</code> saute le second appel et réutilise simplement la dernière valeur renvoyée.</p>
          <p>Rappelez-vous que la fonction passée à <code>useMemo</code> s'exécute pendant le rendu. N‘y faites rien que vous ne feriez normalement pendant le rendu. Par exemple, les effets de bord sont du ressort de <code>useEffect</code>, pas de <code>useMemo</code>.</p>
          <p><strong>Vous pouvez vous appuyer sur <code>useMemo</code> pour les optimisations de performances, mais pas comme une garantie sémantique.</strong> À l'avenir, React pourrait très bien choisir « d'oublier » certaines valeurs préalablement mémoïsées et de les recalculer lors du rendu suivant, par exemple pour libérer de la mémoire pour les composants non visibles. Écrivez votre code de façon à ce qu'il fonctionne toujours sans <code>useMemo</code>, et ajoutez-le ensuite pour optimiser les performances. (Pour les rares cas où une valeur ne doit <em>jamais</em> être recalculée, vous pouvez <a href="#how-to-create-expensive-objects-lazily">l’initialiser paresseusement</a> dans une ref.)</p>
          <p>Vous pouvez aussi utiliser <code>useMemo</code> pour éviter le rafraîchissement coûteux d'un enfant :</p>
          <pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Parent</span></span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> a<span class="token punctuation">,</span> b <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// N’est rafraîchi que si `a` change :</span>
  <span class="token keyword">const</span> child1 <span class="token operator">=</span> <span class="token function">useMemo</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token operator">&#x3C;</span><span class="token maybe-class-name">Child1</span> a<span class="token operator">=</span><span class="token punctuation">{</span>a<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">,</span> <span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// N’est rafraîchi que si `b` change :</span>
  <span class="token keyword">const</span> child2 <span class="token operator">=</span> <span class="token function">useMemo</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token operator">&#x3C;</span><span class="token maybe-class-name">Child2</span> b<span class="token operator">=</span><span class="token punctuation">{</span>b<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">,</span> <span class="token punctuation">[</span>b<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword control-flow">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&#x3C;</span><span class="token operator">></span>
      <span class="token punctuation">{</span>child1<span class="token punctuation">}</span>
      <span class="token punctuation">{</span>child2<span class="token punctuation">}</span>
    <span class="token operator">&#x3C;</span><span class="token operator">/</span><span class="token operator">></span>
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre>
          <p>Remarquez que cette approche ne fonctionne pas dans une boucle car les appels aux Hooks <a href="./hooks-rules.html">ne doivent pas</a> être placés dans des boucles. Mais vous pouvez extraire la liste dans un composant à part, et appeler <code>useMemo</code> sur celui-ci.</p>
        </section>
        <section id="how-to-create-expensive-objects-lazily" class="level3">
          <h3>Comment créer paresseusement des objets coûteux ?</h3>
          <p><code>useMemo</code> vous permet de <a href="#how-to-memoize-calculations">mémoïser un calcul coûteux</a> si les dépendances sont les mêmes. Cependant, il n'est là que pour aider, et ne <em>garantit</em> pas que le calcul ne sera pas refait. Mais parfois vous devez vous assurer qu'un objet n'est créé qu'une seule fois.</p>
          <p><strong>Le principal cas d'utilisation concerne la création d'un état initial coûteux :</strong></p>
          <pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Table</span></span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// ⚠️ createRows() est appelée à chaque rendu</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>rows<span class="token punctuation">,</span> setRows<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token function">createRows</span><span class="token punctuation">(</span>props<span class="token punctuation">.</span><span class="token property-access">count</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span></code></pre>
          <p>Pour éviter de recréer l'état initial ignoré, nous pouvons passer une <strong>fonction</strong> à <code>useState</code> :</p>
          <pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Table</span></span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// ✅ createRows() n'est appelée qu'une seule fois</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>rows<span class="token punctuation">,</span> setRows<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token function">createRows</span><span class="token punctuation">(</span>props<span class="token punctuation">.</span><span class="token property-access">count</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span></code></pre>
          <p>React n'appelera cette fonction que lors du premier rendu. Vous trouverez de plus amples détails dans l'<a href="./hooks-reference.html#usestate">API de référence de <code>useState</code></a>.</p>
          <p><strong>Vous pouvez aussi vouloir occasionnellement éviter de recréer la valeur initiale de <code>useRef()</code>.</strong> Par exemple, vous voulez peut-être vous assurer qu'une instance de classe impérative n'est créée qu'une seule fois :</p>
          <pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Image</span></span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// ⚠️ IntersectionObserver est créé à chaque rendu</span>
  <span class="token keyword">const</span> ref <span class="token operator">=</span> <span class="token function">useRef</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">IntersectionObserver</span><span class="token punctuation">(</span>onIntersect<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span></code></pre>
          <p><code>useRef</code> <strong>n'accepte pas</strong> un argument de fonction spécial comme pour <code>useState</code>. Au lieu de ça, vous pouvez écrire votre propre fonction qui la crée et la définit paresseusement :</p>
          <pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Image</span></span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> ref <span class="token operator">=</span> <span class="token function">useRef</span><span class="token punctuation">(</span><span class="token keyword null nil">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// ✅ IntersectionObserver est créé paresseusement une seule fois</span>
  <span class="token keyword">function</span> <span class="token function">getObserver</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>ref<span class="token punctuation">.</span><span class="token property-access">current</span> <span class="token operator">===</span> <span class="token keyword null nil">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      ref<span class="token punctuation">.</span><span class="token property-access">current</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">IntersectionObserver</span><span class="token punctuation">(</span>onIntersect<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword control-flow">return</span> ref<span class="token punctuation">.</span><span class="token property-access">current</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// Quand vous en avez besoin, appelez getObserver()</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span></code></pre>
          <p>Ça permet d'éviter de recréer un objet coûteux tant qu’il n'est pas nécessaire. Si vous utilisez Flow ou TypeScript, vous pouvez aussi donner à <code>getObserver()</code> un type non-nullable pour un typage plus fin.</p>
        </section>
        <section id="are-hooks-slow-because-of-creating-functions-in-render" class="level3">
          <h3>La création de fonctions à la volée pendant le rendu ralentit-elle les Hooks ?</h3>
          <p>Non. Dans les navigateurs modernes, les performances brutes des fermetures lexicales comparées à celles des classes diffèrent peu, sauf dans des scénarios extrêmes.</p>
          <p>Par ailleurs, gardez à l'esprit que la conception de Hooks est plus efficace pour deux raisons :</p>
          <ul>
            <li>Les Hooks permettent d'éviter une grande partie de la « graisse » amenée par les classes, comme le coût de la création d'instances et la liaison des gestionnaires d'événements dans le constructeur.</li>
            <li><strong>Le code idiomatique utilisant des Hooks n'a pas besoin d'une imbrication profonde de composants</strong> qui prévaudrait dans des projets utilisant des composants d'ordre supérieur, des props de rendu et des contextes. Avec des arborescences plus petites, React a moins de travail à faire.</li>
          </ul>
          <p>Traditionnellement, les problématiques de performance associées aux fonctions définies à la volée en React sont liées au fait que passer de nouvelles fonctions de rappel à chaque rendu empêche les optimisations basées sur <code>shouldComponentUpdate</code> dans les composants enfants. Les Hooks abordent ce problème sous trois angles.</p>
          <ul>
            <li>
              <p>Le Hook <a href="./hooks-reference.html#usecallback"><code>useCallback</code></a> vous permet de référencer la même fonction de rappel d’un rendu à l’autre afin que <code>shouldComponentUpdate</code> puisse continuer à fonctionner :</p>
              <pre class="language-js{2}"><code class="language-js{2}">// Ne changera pas sauf si `a` ou `b` change
const memoizedCallback = useCallback(() => {
  doSomething(a, b);
}, [a, b]);</code></pre>
            </li>
            <li>
              <p>Le <a href="./hooks-faq.html#how-to-memoize-calculations">Hook <code>useMemo</code></a> permet de contrôler plus facilement les mises à jour des enfants, réduisant le besoin de composants purs.</p>
            </li>
            <li>
              <p>Enfin, le Hook <a href="./hooks-reference.html#usereducer"><code>useReducer</code></a> réduit le besoin de passer en profondeur des fonctions de rappel, comme expliqué ci-dessous.</p>
            </li>
          </ul>
        </section>
        <section id="how-to-avoid-passing-callbacks-down" class="level3">
          <h3>Comment éviter de transmettre des fonctions de rappel ?</h3>
          <p>Nous nous sommes aperçu que la majorité des gens n'aiment pas passer des fonctions de rappel à travers chaque niveau de l'arborescence. Même si c'est plus explicite, ça fait franchement « plomberie ».</p>
          <p>Dans de grandes arborescences de composants, nous conseillons plutôt de transmettre une fonction <code>dispatch</code> issue de <a href="./hooks-reference.html#usereducer"><code>useReducer</code></a> via le contexte :</p>
          <pre class="language-js{4,5}"><code class="language-js{4,5}">const TodosDispatch = React.createContext(null);

function TodosApp() {
  // Remarque : `dispatch` ne va pas changer d'un rendu à l'autre
  const [todos, dispatch] = useReducer(todosReducer);

  return (
    &#x3C;TodosDispatch.Provider value={dispatch}>
      &#x3C;DeepTree todos={todos} />
    &#x3C;/TodosDispatch.Provider>
  );
}</code></pre>
          <p>N’importe quel enfant de l'arborescence de <code>TodosApp</code> peut utiliser la fonction <code>dispatch</code> pour remonter des actions à <code>TodosApp</code> :</p>
          <pre class="language-js{2,3}"><code class="language-js{2,3}">function DeepChild(props) {
  // Si nous voulons exécuter une action, nous pouvons récupérer dispatch depuis le contexte.
  const dispatch = useContext(TodosDispatch);

  function handleClick() {
    dispatch({ type: 'add', text: 'salut' });
  }

  return (
    &#x3C;button onClick={handleClick}>Ajouter une tâche&#x3C;/button>
  );
}</code></pre>
          <p>C'est à la fois plus pratique d'un point de vue maintenance (pas besoin de continuer à passer des fonctions de rappel), et ça règle au passage le problème (de mémoïsation) des fonctions de rappel. Pour les mises à jour déclenchées en profondeur, nous conseillons de transmettre <code>dispatch</code> de cette façon.</p>
          <p>Remarquez que vous pouvez toujours choisir de transmettre l'<em>état</em> applicatif comme props (plus explicite) ou comme contexte (plus pratique pour les mises à jour très profondes). Si vous utilisez le contexte pour transmettre également l'état local, utilisez deux types de contexte différents : la donnée de contexte <code>dispatch</code> ne changera jamais, donc les composants qui l'utilisent n'ont pas besoin de se rafraîchir à moins qu'ils n’aient aussi besoin de l'état applicatif.</p>
        </section>
        <section id="how-to-read-an-often-changing-value-from-usecallback" class="level3">
          <h3>Comment lire une valeur changeant fréquemment avec <code>useCallback</code> ?</h3>
          <blockquote>
            <p>Remarque</p>
            <p>Nous recommandons de <a href="#how-to-avoid-passing-callbacks-down">transmettre <code>dispatch</code> dans le contexte</a> plutôt que des fonctions de rappel individuelles dans les props. L'approche ci-dessous n'est mentionnée que par souci d'exhaustivité et à titre d'échappatoire.</p>
            <p>Notez aussi que cette approche peut causer des problèmes avec le <a href="/blog/2018/03/27/update-on-async-rendering.html">mode concurrent</a>. Nous prévoyons de proposer des alternatives plus ergonomiques à l'avenir, mais la solution la plus sûre pour l'instant consiste à toujours invalider la fonction de rappel si des valeurs dont elle dépend changent.</p>
          </blockquote>
          <p>Dans de rares cas vous pourriez avoir besoin de mémoïser une fonction de rappel avec <a href="./hooks-reference.html#usecallback"><code>useCallback</code></a> mais la mémoïsation ne fonctionne pas très bien parce que la fonction interne a tout de même trop souvent besoin d'être recréée. Si la fonction que vous mémoïsez est un gestionnaire d'événements et n'est pas utilisée pendant le rendu, vous pouvez utiliser une <a href="#is-there-something-like-instance-variables">ref comme variable d'instance</a>, et y stocker manuellement la dernière valeur renvoyée :</p>
          <pre class="language-js{6,10}"><code class="language-js{6,10}">function Form() {
  const [text, updateText] = useState('');
  const textRef = useRef();

  useLayoutEffect(() => {
    textRef.current = text; // Écrit dans la ref
  });

  const handleSubmit = useCallback(() => {
    const currentText = textRef.current; // Lit depuis la ref
    alert(currentText);
  }, [textRef]); // Ne recrée pas handleSubmit comme `[text]` le ferait

  return (
    &#x3C;>
      &#x3C;input value={text} onChange={e => updateText(e.target.value)} />
      &#x3C;ExpensiveTree onSubmit={handleSubmit} />
    &#x3C;/>
  );
}</code></pre>
          <p>C'est une approche un peu biscornue mais ça montre que vous pouvez faire cette optimisation en dernier ressort, si vous en avez vraiment besoin. Vous pouvez en masquer les détails dérangeants en l'extrayant dans un Hook personnalisé :</p>
          <pre class="language-js{4,16}"><code class="language-js{4,16}">function Form() {
  const [text, updateText] = useState('');
  // Sera mémoïsé même si `text` change :
  const handleSubmit = useEventCallback(() => {
    alert(text);
  }, [text]);

  return (
    &#x3C;>
      &#x3C;input value={text} onChange={e => updateText(e.target.value)} />
      &#x3C;ExpensiveTree onSubmit={handleSubmit} />
    &#x3C;/>
  );
}

function useEventCallback(fn, dependencies) {
  const ref = useRef(() => {
    throw new Error('Cannot call an event handler while rendering.');
  });

  useEffect(() => {
    ref.current = fn;
  }, [fn, ...dependencies]);

  return useCallback(() => {
    const fn = ref.current;
    return fn();
  }, [ref]);
}</code></pre>
          <p>Dans les deux cas, nous <strong>déconseillons cette approche</strong> et ne l’illustrons ici que dans un souci d'exhaustivité. Au lieu de ça, il est préférable d'<a href="#how-to-avoid-passing-callbacks-down">éviter de transmettre des fonctions de rappel en profondeur</a>.</p>
        </section>
      </section>
      <section id="under-the-hood" class="level2">
        <h2>Sous le capot</h2>
        <section id="how-does-react-associate-hook-calls-with-components" class="level3">
          <h3>Comment React associe-t-il les appels de Hooks avec les composants ?</h3>
          <p>React garde trace du composant en cours de rendu. Grâce aux <a href="./hooks-rules.html">règles des Hooks</a>, nous savons que les Hooks sont uniquement appelés depuis des composants React (ou des Hooks personnalisés, qui sont aussi uniquement appelés depuis des composants React).</p>
          <p>Il existe une liste interne de « cellules mémoire » associées à chaque composant. Ce sont juste des objets JavaScript où nous stockons quelques données. Quand vous appelez un Hook tel que <code>useState()</code>, il lit la cellule courante (ou l'initialise pendant le premier rendu), et déplace alors le pointeur sur la prochaine. C'est ainsi que de multiples appels à <code>useState()</code> peuvent avoir chacun un état local distinct.</p>
        </section>
        <section id="what-is-the-prior-art-for-hooks" class="level3">
          <h3>Quelles sont les sources d'inspiration des Hooks ?</h3>
          <p>Les Hooks font la synthèse d’idées issues de plusieurs sources :</p>
          <ul>
            <li>Nos précédentes expériences autour d’API fonctionnelles dans le dépôt <a href="https://github.com/reactjs/react-future/tree/master/07%20-%20Returning%20State">react-future</a>.</li>
            <li>Les expériences de la communauté React avec les API de props de rendu, notamment le <a href="https://github.com/reactions/component">composant Reactions</a> de <a href="https://github.com/ryanflorence">Ryan Florence</a>.</li>
            <li>La proposition de <a href="https://gist.github.com/trueadm/17beb64288e30192f3aa29cad0218067">mot-clé <code>adopt</code></a> de <a href="https://github.com/trueadm">Dominic Gannaway</a> comme sucre syntaxique pour les props de rendu.</li>
            <li>Les <a href="http://displayscript.org/introduction.html">variables d'état et les cellules à état en DisplayScript</a>.</li>
            <li>Les <a href="https://reasonml.github.io/reason-react/docs/fr/state-actions-reducer.html">composants réducteurs</a> de ReasonReact.</li>
            <li>Les <a href="http://reactivex.io/rxjs/class/es6/Subscription.js~Subscription.html">abonnements</a> <em>(Subscriptions, NdT)</em> en Rx.</li>
            <li>Les <a href="https://github.com/ocamllabs/ocaml-effects-tutorial#2-effectful-computations-in-a-pure-setting">effets algébriques</a> de OCaml Multicore.</li>
          </ul>
          <p>
            <a href="https://github.com/sebmarkbage">Sebastian Markbåge</a> a proposé la conception initiale des Hooks, peaufinée ensuite par <a href="https://github.com/acdlite">Andrew Clark</a>, <a href="https://github.com/sophiebits">Sophie Alpert</a>, <a href="https://github.com/trueadm">Dominic Gannaway</a> et d'autres membres de l'équipe React.
            <span style="float: footnote;"><a href="./index.html#toc">Go to TOC</a></span>
          </p>
        </section>
      </section>
    </section>
  </body>
</html>
