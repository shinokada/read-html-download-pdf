<!doctypehtml><html lang="pl"><meta charset="utf-8"><title>Hooki w piguÅ‚ce</title><meta name="viewport"content="width=device-width,initial-scale=1"><link rel="stylesheet"href="https://raw.githubusercontent.com/shinokada/prism-coy-theme/main/theme_common.css"><section id="hooki-w-piguÅ‚ce"class="level1"><h1>Hooki w piguÅ‚ce</h1><p><em>Hooki</em> sÄ… nowym dodatkiem w Reakcie 16.8. PozwalajÄ… one uÅ¼ywaÄ‡ stanu i innych funkcjonalnoÅ›ci Reacta, bez uÅ¼ycia klas.<p>Hooki sÄ… <a href="./hooks-intro.html#no-breaking-changes">kompatybilne wstecznie</a>. Ten rozdziaÅ‚ zawiera szybki przeglÄ…d wiedzy o hookach i przeznaczony jest dla doÅ›wiadczonych uÅ¼ytkownikÃ³w Reacta. JeÅ¼eli w ktÃ³rymÅ› momencie siÄ™ zgubisz, szukaj Å¼Ã³Å‚tych ramek, takich jak ta poniÅ¼ej:<blockquote><p>SzczegÃ³Å‚owe wyjaÅ›nienie<p>Przeczytaj podrozdziaÅ‚ pt. <a href="./hooks-intro.html#motivation">â€Motywacjaâ€</a>, aby dowiedzieÄ‡ siÄ™, dlaczego dodaliÅ›my hooki</blockquote><p><strong>â†‘â†‘â†‘ KaÅ¼dy podrozdziaÅ‚ zakoÅ„czony jest takÄ… Å¼Ã³Å‚tÄ… ramkÄ….</strong> ZawierajÄ… one linki do szczegÃ³Å‚owych objaÅ›nieÅ„.<section id="state-hook"class="level2"><h2>ğŸ“Œ Hook stanu</h2><p>Ten przykÅ‚ad renderuje licznik. Kiedy wciskasz przycisk, zwiÄ™ksza on wartoÅ›Ä‡ w stanie.<pre class="language-js{1,4,5}"><code class="language-js{1,4,5}">import React, { useState } from 'react';

function Example() {
  // Zadeklaruj nowÄ… zmiennÄ… stanu, ktÃ³rÄ… nazwiemy â€countâ€
  const [count, setCount] = useState(0);

  return (
    &#x3C;div>
      &#x3C;p>NaciÅ›niÄ™to {count} razy&#x3C;/p>
      &#x3C;button onClick={() => setCount(count + 1)}>
        NaciÅ›nij mnie
      &#x3C;/button>
    &#x3C;/div>
  );
}</code></pre><p>W tym przykÅ‚adzie <code>useState</code> jest <em>hookiem</em> (za chwilÄ™ wyjaÅ›nimy, co to znaczy). WywoÅ‚ujemy go z wewnÄ…trz komponentu funkcyjnego, aby wzbogaciÄ‡ go o lokalny stan. React zachowa ten stan pomiÄ™dzy kolejnymi renderowaniami. <code>useState</code> zwraca parÄ™: <em>aktualnÄ…</em> wartoÅ›Ä‡ stanu i funkcjÄ™, ktÃ³ra pozwala go aktualizowaÄ‡. MoÅ¼esz wywoÅ‚aÄ‡ tÄ™ funkcjÄ™ w procedurze obsÅ‚ugi zdarzenia albo z innego miejsca. DziaÅ‚a to mniej wiÄ™cej tak samo jak <code>this.setState</code> w komponencie klasowym, z tÄ… rÃ³Å¼nicÄ…, Å¼e nie scala on starych i nowych wartoÅ›ci. (Szerzej omawiamy te rÃ³Å¼nice w rozdziale pt. <a href="./hooks-state.html">â€UÅ¼ywanie hooka stanuâ€</a>.)<p>Jedynym argumentem funkcji <code>useState</code> jest stan poczÄ…tkowy. W przykÅ‚adzie powyÅ¼ej jest to <code>0</code>, poniewaÅ¼ nasz licznik startuje od zera. ZauwaÅ¼, Å¼e w przeciwieÅ„stwie do <code>this.state</code>, stan nie musi byÄ‡ obiektem. Nic jednak nie stoi na przeszkodzie, by nim byÅ‚. WartoÅ›Ä‡ argumentu ze stanem poczÄ…tkowym jest wykorzystywana tylko podczas pierwszego renderowania.<section id="declaring-multiple-state-variables"class="level4"><h4>Deklaracja kilku zmiennych stanu</h4><p>MoÅ¼esz uÅ¼yÄ‡ hooka stanu kilka razy w tym samym komponencie:<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">ExampleWithManyStates</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// Zadeklaruj kilka zmiennych stanu!</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>age<span class="token punctuation">,</span> setAge<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>fruit<span class="token punctuation">,</span> setFruit<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token string">'banana'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>todos<span class="token punctuation">,</span> setTodos<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">{</span> <span class="token literal-property property">text</span><span class="token operator">:</span> <span class="token string">'Learn Hooks'</span> <span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span></code></pre><p>DziÄ™ki skÅ‚adni <a href="https://developer.mozilla.org/pl/docs/Web/JavaScript/Referencje/Operatory/Destructuring_assignment#Destrukturyzacja_tablic">przypisania destrukturyzujÄ…cego tablic</a> moÅ¼emy nadaÄ‡ rÃ³Å¼ne nazwy zmiennym stanu, ktÃ³re zadeklarowaliÅ›my wywoÅ‚ujÄ…c funkcjÄ™ <code>useState</code>. Nazwy te nie sÄ… czÄ™Å›ciÄ… interfejsu API <code>useState</code>. Zamiast tego React zakÅ‚ada, Å¼e jeÅ¼eli wywoÅ‚ujesz funkcjÄ™ <code>useState</code> wielokrotnie, za kaÅ¼dym razem (przy kaÅ¼dym renderze) robisz to w tej samej kolejnoÅ›ci. W dalszej czÄ™Å›ci tego rozdziaÅ‚u omÃ³wimy, jak to dziaÅ‚a i dlaczego jest to przydatne.</section><section id="but-what-is-a-hook"class="level4"><h4>Ale czym jest hook?</h4><p>Hooki sÄ… to funkcje, ktÃ³re pozwalajÄ… â€zahaczyÄ‡ siÄ™â€ w mechanizmy stanu i cyklu Å¼ycia Reacta, z wewnÄ…trz komponentÃ³w funkcyjnych. Hooki nie dziaÅ‚ajÄ… w klasach -- zamiast tego pozwalajÄ… korzystaÄ‡ z Reacta bez klas. (<a href="./hooks-intro.html#gradual-adoption-strategy">Nie zalecamy</a> przepisywania istniejÄ…cych komponentÃ³w z dnia na dzieÅ„, ale jeÅ¼eli masz ochotÄ™, moÅ¼esz zaczÄ…Ä‡ korzystaÄ‡ z hookÃ³w w nowych komponentach.)<p>React dostarcza kilka wbudowanych hookÃ³w, miÄ™dzy innymi <code>useState</code>. Ale moÅ¼esz teÅ¼ stworzyÄ‡ wÅ‚asne hooki, by wspÃ³Å‚dzieliÄ‡ zachowanie zwiÄ…zane ze stanem pomiÄ™dzy komponentami. Najpierw rzuÄ‡my jednak okiem na wbudowane hooki.<blockquote><p>SzczegÃ³Å‚owe wyjaÅ›nienie<p>Hookowi stanu poÅ›wiÄ™ciliÅ›my caÅ‚y rozdziaÅ‚: <a href="./hooks-state.html">â€UÅ¼ywanie hooka stanuâ€</a>.</blockquote></section></section><section id="effect-hook"class="level2"><h2>âš¡ï¸ Hook efektÃ³w</h2><p>Najprawdopodobniej zdarzyÅ‚o ci siÄ™ juÅ¼ pobieraÄ‡ dane, obsÅ‚ugiwaÄ‡ subskrypcje lub rÄ™cznie modyfikowaÄ‡ drzewo DOM wewnÄ…trz komponentÃ³w reactowych. Tego typu operacje nazywamy <a href="https://pl.wikipedia.org/wiki/Skutek_uboczny_(informatyka)">â€efektami ubocznymiâ€</a> (ang. <em>side effects</em>), poniewaÅ¼ mogÄ… one wpÅ‚ywaÄ‡ na inne komponenty i nie mogÄ… zostaÄ‡ przeprowadzone podczas renderowania.<p>Hook efektÃ³w <code>useEffect</code> daje moÅ¼liwoÅ›Ä‡ przeprowadzania â€efektÃ³w ubocznychâ€ z wewnÄ…trz komponentu funkcyjnego. PeÅ‚ni on takÄ… samÄ… funkcjÄ™, jak <code>componentDidMount</code>, <code>componentDidUpdate</code> i <code>componentWillUnmount</code> w komponentach klasowych, ale uproszczonÄ… do jednego interfejsu API. (RÃ³Å¼nice miÄ™dzy nimi pokaÅ¼emy na przykÅ‚adach w rozdziale pt. <a href="./hooks-effect.html">â€UÅ¼ywanie hooka efektÃ³wâ€</a>.)<p>Na przykÅ‚ad, ten komponent ustawia tytuÅ‚ dokumentu HTML po tym, jak React zaktualizuje drzewo DOM:<pre class="language-js{1,6-10}"><code class="language-js{1,6-10}">import React, { useState, useEffect } from 'react';

function Example() {
  const [count, setCount] = useState(0);

  // Podobnie jak componentDidMount i componentDidUpdate:
  useEffect(() => {
    // Zaktualizuj tytuÅ‚ dokumentu, korzystajÄ…c z interfejsu API przeglÄ…darki
    document.title = `NaciÅ›niÄ™to ${count} razy`;
  });

  return (
    &#x3C;div>
      &#x3C;p>NaciÅ›niÄ™to {count} razy&#x3C;/p>
      &#x3C;button onClick={() => setCount(count + 1)}>
        NaciÅ›nij mnie
      &#x3C;/button>
    &#x3C;/div>
  );
}</code></pre><p>Kiedy wywoÅ‚ujesz funkcjÄ™ <code>useEffect</code>, mÃ³wisz Reactowi, Å¼eby uruchomiÅ‚ twÃ³j â€efektâ€, gdy oprÃ³Å¼ni (ang. <em>flush</em>) bufor zmian do drzewa DOM. Efekty sÄ… deklarowane wewnÄ…trz komponentu, wiÄ™c majÄ… dostÄ™p do jego wÅ‚aÅ›ciwoÅ›ci (ang. <em>props</em>) i stanu (ang. <em>state</em>). DomyÅ›lnie React uruchamia wszystkie efekty po kaÅ¼dym renderowaniu -- <em>wÅ‚Ä…cznie</em> z pierwszym. (RÃ³Å¼nice miÄ™dzy tym a metodami cyklu Å¼ycia komponentÃ³w klasowych omÃ³wimy w rozdziale pt. <a href="./hooks-effect.html">â€UÅ¼ywanie hooka efektÃ³wâ€</a>.)<p>Poprzez zwrÃ³cenie funkcji, efekty mogÄ… teÅ¼ okreÅ›laÄ‡, w jaki sposÃ³b naleÅ¼y po nich â€posprzÄ…taÄ‡â€. Na przykÅ‚ad, ten komponent uÅ¼ywa efektu, aby zasubskrybowaÄ‡ siÄ™ do informacji o dostÄ™pnoÅ›ci znajomego. A nastÄ™pnie sprzÄ…ta po sobie, anulujÄ…c tÄ™ subskrypcjÄ™.<pre class="language-js{10-16}"><code class="language-js{10-16}">import React, { useState, useEffect } from 'react';

function FriendStatus(props) {
  const [isOnline, setIsOnline] = useState(null);

  function handleStatusChange(status) {
    setIsOnline(status.isOnline);
  }

  useEffect(() => {
    ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);

    return () => {
      ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);
    };
  });

  if (isOnline === null) {
    return 'Åadowanie...';
  }
  return isOnline ? 'DostÄ™pny' : 'NiedostÄ™pny';
}</code></pre><p>W tym przykÅ‚adzie React anuluje subskrypcjÄ™ naszego <code>ChatAPI</code> w momencie, gdy komponent zostaje odmontowany. Zrobi to teÅ¼ przed kaÅ¼dym kolejnym uruchomieniem efektu (ktÃ³re nastÄ™puje przy kaÅ¼dym kolejnym renderowaniu komponentu). (JeÅ›li chcesz, moÅ¼esz <a href="./hooks-effect.html#tip-optimizing-performance-by-skipping-effects">powiedzieÄ‡ Reactowi Å¼eby tego nie robiÅ‚</a>, jeÅ›li wartoÅ›Ä‡ <code>props.friend.id</code>, ktÃ³rÄ… przekazaliÅ›my do <code>ChatAPI</code>, nie ulegÅ‚a zmianie.)<p>Podobnie jak z <code>useState</code>, moÅ¼esz uÅ¼yÄ‡ wiÄ™cej niÅ¼ jednego efektu w swoim komponencie:<pre class="language-js{3,8}"><code class="language-js{3,8}">function FriendStatusWithCounter(props) {
  const [count, setCount] = useState(0);
  useEffect(() => {
    document.title = `NaciÅ›niÄ™to ${count} razy`;
  });

  const [isOnline, setIsOnline] = useState(null);
  useEffect(() => {
    ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);
    return () => {
      ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);
    };
  });

  function handleStatusChange(status) {
    setIsOnline(status.isOnline);
  }
  // ...</code></pre><p>Hooki pozwalajÄ… organizowaÄ‡ kod wewnÄ…trz komponentu, bazujÄ…c na powiÄ…zanych ze sobÄ… fragmentach (takich jak dodawanie i anulowanie subskrypcji). Nie wymuszajÄ… sztucznego podziaÅ‚u, jak metody cyklu Å¼ycia (ang. <em>lifecycle methods</em>).<blockquote><p>SzczegÃ³Å‚owe wyjaÅ›nienie<p>MoÅ¼esz dowiedzieÄ‡ siÄ™ wiÄ™cej o <code>useEffect</code> w rozdziale pt. <a href="./hooks-effect.html">â€UÅ¼ywanie hooka efektÃ³wâ€</a>.</blockquote></section><section id="rules-of-hooks"class="level2"><h2>âœŒï¸ Zasady korzystania z hookÃ³w</h2><p>Hooki sÄ… funkcjami javascriptowymi, ale narzucajÄ… dwie dodatkowe zasady:<ul><li>WywoÅ‚uj hooki tylko <strong>z najwyÅ¼szego poziomu kodu</strong>. Nie wywoÅ‚uj hookÃ³w z wewnÄ…trz pÄ™tli, warunkÃ³w czy zagnieÅ¼dÅ¼onych funkcji.<li>WywoÅ‚uj hooki tylko <strong>z wewnÄ…trz reactowych komponentÃ³w funkcyjnych</strong>. Nie wywoÅ‚uj hookÃ³w z wewnÄ…trz zwykÅ‚ych javascriptowych funkcji. (Jest jeszcze tylko jedno miejsce, z ktÃ³rego moÅ¼esz wywoÅ‚ywaÄ‡ hooki -- twoje wÅ‚asne hooki. Za chwilÄ™ dowiemy siÄ™ o tym wiÄ™cej.)</ul><p>StworzyliÅ›my <a href="https://www.npmjs.com/package/eslint-plugin-react-hooks">wtyczkÄ™ do lintera</a>, ktÃ³ra automatycznie wymusza te zasady. Rozumiemy, Å¼e reguÅ‚y te mogÄ… z poczÄ…tku wydawaÄ‡ siÄ™ ograniczajÄ…ce i zagmatwane, ale sÄ… one niezbÄ™dne do prawidÅ‚owego funkcjonowania hookÃ³w.<blockquote><p>SzczegÃ³Å‚owe wyjaÅ›nienie<p>MoÅ¼esz dowiedzieÄ‡ siÄ™ wiÄ™cej o tych zasadach w rozdziale pt. <a href="./hooks-rules.html">â€Zasady korzystania z hookÃ³wâ€</a>.</blockquote></section><section id="building-your-own-hooks"class="level2"><h2>ğŸ’¡ Tworzenie wÅ‚asnych hookÃ³w</h2><p>Czasami zdarza siÄ™, Å¼e chcemy ponownie wykorzystaÄ‡ pewnÄ… logikÄ™ zwiÄ…zanÄ… ze stanem pomiÄ™dzy komponentami. W tradycyjnym podejÅ›ciu mieliÅ›my do dyspozycji dwa popularne rozwiÄ…zania tego problemu: <a href="./higher-order-components.html">komponenty wyÅ¼szego rzÄ™du (ang. <em>higher-order components</em>)</a> i <a href="./render-props.html">wÅ‚aÅ›ciwoÅ›ci renderujÄ…ce (ang. <em>render props</em>)</a>. WÅ‚asne hooki rozwiÄ…zujÄ… ten problem, bez koniecznoÅ›ci dodawania kolejnych komponentÃ³w do drzewa.<p>W jednym z poprzednich podrozdziaÅ‚Ã³w pokazaliÅ›my komponent <code>FriendStatus</code>, ktÃ³ry wykorzystuje hooki <code>useState</code> i <code>useEffect</code>, aby zasubskrybowaÄ‡ siÄ™ do informacji o dostÄ™pnoÅ›ci znajomego. ZaÅ‚Ã³Å¼my, Å¼e chcielibyÅ›my wykorzystaÄ‡ tÄ™ logikÄ™ w innym komponencie.<p>Na poczÄ…tek wydzielmy tÄ™ logikÄ™ do wÅ‚asnego hooka o nazwie <code>useFriendStatus</code>:<pre class="language-js{3}"><code class="language-js{3}">import React, { useState, useEffect } from 'react';

function useFriendStatus(friendID) {
  const [isOnline, setIsOnline] = useState(null);

  function handleStatusChange(status) {
    setIsOnline(status.isOnline);
  }

  useEffect(() => {
    ChatAPI.subscribeToFriendStatus(friendID, handleStatusChange);
    return () => {
      ChatAPI.unsubscribeFromFriendStatus(friendID, handleStatusChange);
    };
  });

  return isOnline;
}</code></pre><p>Jako argument przyjmuje on zmiennÄ… <code>friendID</code> i zwraca informacjÄ™ o tym, czy nasz znajomy jest dostÄ™pny.<p>Teraz moÅ¼emy go uÅ¼yÄ‡ w obu naszych komponentach:<pre class="language-js{2}"><code class="language-js{2}">function FriendStatus(props) {
  const isOnline = useFriendStatus(props.friend.id);

  if (isOnline === null) {
    return 'Åadowanie...';
  }
  return isOnline ? 'DostÄ™pny' : 'NiedostÄ™pny';
}</code></pre><pre class="language-js{2}"><code class="language-js{2}">function FriendListItem(props) {
  const isOnline = useFriendStatus(props.friend.id);

  return (
    &#x3C;li style={{ color: isOnline ? 'green' : 'black' }}>
      {props.friend.name}
    &#x3C;/li>
  );
}</code></pre><p>Stan kaÅ¼dego komponentu jest w peÅ‚ni niezaleÅ¼ny. Hooki sÄ… metodÄ… na wspÃ³Å‚dzielenie <em>logiki zwiÄ…zanej ze stanem</em>, nie zaÅ› samego stanu. Tak naprawdÄ™ to kaÅ¼de <em>wywoÅ‚anie</em> hooka tworzy kompletnie wyizolowany stan -- moÅ¼esz wiÄ™c uÅ¼yÄ‡ tego samego, wÅ‚asnego hooka kilkukrotnie w jednym komponencie.<p>WÅ‚asne hooki sÄ… bardziej konwencjÄ… niÅ¼ wbudowanym mechanizmem. JeÅ¼eli nazwa funkcji zaczyna siÄ™ od â€<code>use</code>â€ i wywoÅ‚uje ona inne hooki, mÃ³wimy Å¼e mamy do czynienia z wÅ‚asnym hookiem. Na tej konwencji nazewnictwa <code>useSomething</code> bazuje nasza wtyczka do lintera i pozwala jej to znaleÅºÄ‡ bÅ‚Ä™dy w kodzie korzystajÄ…cym z hookÃ³w.<p>MoÅ¼esz pisaÄ‡ wÅ‚asne hooki, ktÃ³re obejmujÄ… szereg rÃ³Å¼nych przypadkÃ³w - od obsÅ‚ugi animacji, deklaratywnych subskrypcji, licznikÃ³w, po wiele innych, o ktÃ³rych nie pomyÅ›leliÅ›my. Nie moÅ¼emy siÄ™ doczekaÄ‡, Å¼eby zobaczyÄ‡, na jakie pomysÅ‚y wykorzystania wÅ‚asnych hookÃ³w wpadnie spoÅ‚ecznoÅ›Ä‡ Reacta.<blockquote><p>SzczegÃ³Å‚owe wyjaÅ›nienie<p>MoÅ¼esz dowiedzieÄ‡ siÄ™ wiÄ™cej o wÅ‚asnych hookach w rozdziale pt. <a href="./hooks-custom.html">â€Tworzenie wÅ‚asnych hookÃ³wâ€</a>.</blockquote></section><section id="other-hooks"class="level2"><h2>ğŸ”Œ Inne hooki</h2><p>Istnieje kilka mniej popularnych, wbudowanych hookÃ³w, ktÃ³re mogÄ… ci siÄ™ spodobaÄ‡. Na przykÅ‚ad <a href="./hooks-reference.html#usecontext"><code>useContext</code></a> pozwala zasubskrybowaÄ‡ siÄ™ do zmian kontekstu (ang. <em>context</em>) bez wprowadzania zagnieÅ¼dÅ¼ania:<pre class="language-js{2,3}"><code class="language-js{2,3}">function Example() {
  const locale = useContext(LocaleContext);
  const theme = useContext(ThemeContext);
  // ...
}</code></pre><p>Z kolei <a href="./hooks-reference.html#usereducer"><code>useReducer</code></a> pozwala na zarzÄ…dzanie lokalnym stanem skomplikowanych komponentÃ³w przy uÅ¼yciu reduktora (ang. <em>reducer</em>):<pre class="language-js{2}"><code class="language-js{2}">function Todos() {
  const [todos, dispatch] = useReducer(todosReducer);
  // ...</code></pre><blockquote><p>SzczegÃ³Å‚owe wyjaÅ›nienie<p>WiÄ™cej informacji o wszystkich wbudowanych hookach znajdziesz w rozdziale pt. <a href="./hooks-reference.html">â€Hooki - interfejs APIâ€</a>.</blockquote></section><section id="next-steps"class="level2"><h2>Kolejne kroki</h2><p>Uff, to byÅ‚ wyczerpujÄ…co szybki przeglÄ…d! JeÅ¼eli coÅ› z tego, co napisaliÅ›my, nie miaÅ‚o dla ciebie sensu lub jeÅ›li chcesz po prostu dowiedzieÄ‡ siÄ™ wiÄ™cej, moÅ¼esz przeczytaÄ‡ kolejne rozdziaÅ‚y, zaczynajÄ…c od <a href="./hooks-state.html">â€UÅ¼ywanie hooka stanuâ€</a>.<p>MoÅ¼esz teÅ¼ zerknÄ…Ä‡ na rozdziaÅ‚y pt. <a href="./hooks-reference.html">â€Hooki - interfejs APIâ€</a> i <a href="./hooks-faq.html">â€Hooki - FAQâ€</a>.<p>I na koniec: nie zapomnij o rozdziale pt. <a href="./hooks-intro.html">â€Wprowadzenie do hookÃ³wâ€</a>, w ktÃ³rym wyjaÅ›niliÅ›my, dlaczego dodaliÅ›my hooki i jak zaczÄ…Ä‡ z nich korzystaÄ‡ rÃ³wnolegle z istniejÄ…cym kodem -- bez przepisywania aplikacji. <span style="float:footnote"><a href="./index.html#toc">Go to TOC</a></span></section></section>