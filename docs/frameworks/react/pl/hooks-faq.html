<!doctypehtml><html lang="pl"><meta charset="utf-8"><title>Hooki - FAQ</title><meta name="viewport"content="width=device-width,initial-scale=1"><link rel="stylesheet"href="https://raw.githubusercontent.com/shinokada/prism-coy-theme/main/theme_common.css"><section id="hooki---faq"class="level1"><h1>Hooki - FAQ</h1><p><em>Hooki</em> sÄ… nowym dodatkiem do Reacta w wersji 16.8. PozwalajÄ… na uÅ¼ycie stanu i innych funkcji Reacta bez koniecznoÅ›ci pisania klas.<p>Ta strona odpowiada na najczÄ™Å›ciej zadawane pytania odnoÅ›nie <a href="./hooks-overview.html">hookÃ³w</a>.<ul><li><strong><a href="#adoption-strategy">Strategia wdraÅ¼ania</a></strong><ul><li><a href="#which-versions-of-react-include-hooks">KtÃ³re wersje Reacta wspierajÄ… hooki?</a><li><a href="#do-i-need-to-rewrite-all-my-class-components">Czy muszÄ™ przepisaÄ‡ wszystkie komponenty klasowe?</a><li><a href="#what-can-i-do-with-hooks-that-i-couldnt-with-classes">Co mogÄ™ zrobiÄ‡ z hookami, czego nie moÅ¼na byÅ‚o zrobiÄ‡ z klasami?</a><li><a href="#how-much-of-my-react-knowledge-stays-relevant">Jaka czÄ™Å›Ä‡ mojej wiedzy o Reakcie jest nadal aktualna?</a><li><a href="#should-i-use-hooks-classes-or-a-mix-of-both">Czy lepiej uÅ¼ywaÄ‡ hookÃ³w, klas, czy moÅ¼e mieszaÄ‡ obydwa sposoby?</a><li><a href="#do-hooks-cover-all-use-cases-for-classes">Czy hooki obejmujÄ… wszystkie przypadki uÅ¼ycia, ktÃ³re sÄ… dostÄ™pne dla klas?</a><li><a href="#do-hooks-replace-render-props-and-higher-order-components">Czy hooki zastÄ™pujÄ… "wÅ‚aÅ›ciwoÅ›ci renderujÄ…ce" i komponenty wyÅ¼szego rzÄ™du?</a><li><a href="#what-do-hooks-mean-for-popular-apis-like-redux-connect-and-react-router">Co hooki oznaczajÄ… dla popularnych API, takich jak <code>connect()</code> z Reduxa lub React Router?</a><li><a href="#do-hooks-work-with-static-typing">Czy hooki wspÃ³Å‚pracujÄ… ze statycznym typowaniem?</a><li><a href="#how-to-test-components-that-use-hooks">Jak testowaÄ‡ komponenty, ktÃ³re uÅ¼ywajÄ… hookÃ³w?</a><li><a href="#what-exactly-do-the-lint-rules-enforce">Co dokÅ‚adnie narzucajÄ… reguÅ‚y lintera?</a></ul><li><strong><a href="#from-classes-to-hooks">Od klas do hookÃ³w</a></strong><ul><li><a href="#how-do-lifecycle-methods-correspond-to-hooks">Jak wyglÄ…dajÄ… metody cyklu Å¼ycia w odniesieniu do hookÃ³w?</a><li><a href="#how-can-i-do-data-fetching-with-hooks">Jak mogÄ™ pobraÄ‡ dane wykorzystujÄ…c hooki?</a><li><a href="#is-there-something-like-instance-variables">Czy istnieje coÅ› podobnego do zmiennych instancji?</a><li><a href="#should-i-use-one-or-many-state-variables">Lepiej uÅ¼ywaÄ‡ jednej czy wielu zmiennych stanu?</a><li><a href="#can-i-run-an-effect-only-on-updates">Czy mogÄ™ uruchomiÄ‡ efekt tylko podczas aktualizacji komponentu?</a><li><a href="#how-to-get-the-previous-props-or-state">Jak dostaÄ‡ poprzednie wÅ‚aÅ›ciwoÅ›ci lub stan?</a><li><a href="#why-am-i-seeing-stale-props-or-state-inside-my-function">Dlaczego widzÄ™ nieaktualne wÅ‚aÅ›ciwoÅ›ci lub stan wewnÄ…trz mojej funkcji?</a><li><a href="#how-do-i-implement-getderivedstatefromprops">Jak zaimplementowaÄ‡ <code>getDerivedStateFromProps</code>?</a><li><a href="#is-there-something-like-forceupdate">Czy istnieje coÅ› takiego jak forceUpdate?</a><li><a href="#can-i-make-a-ref-to-a-function-component">Czy mogÄ™ stworzyÄ‡ referencjÄ™ do komponentu funkcyjnego?</a><li><a href="#how-can-i-measure-a-dom-node">Jak mogÄ™ zmierzyÄ‡ wÄ™zeÅ‚ DOM?</a><li><a href="#what-does-const-thing-setthing--usestate-mean">Co oznacza <code>const [thing, setThing] = useState()</code>?</a></ul><li><strong><a href="#performance-optimizations">Optymalizacja wydajnoÅ›ci</a></strong><ul><li><a href="#can-i-skip-an-effect-on-updates">Czy mogÄ™ pominÄ…Ä‡ efekt podczas aktualizacji komponentu?</a><li><a href="#is-it-safe-to-omit-functions-from-the-list-of-dependencies">Czy bezpiecznie jest pomijaÄ‡ funkcje w liÅ›cie zaleÅ¼noÅ›ci?</a><li><a href="#what-can-i-do-if-my-effect-dependencies-change-too-often">Co zrobiÄ‡, gdy zaleÅ¼noÅ›ci mojego efektu zmieniajÄ… siÄ™ zbyt czÄ™sto?</a><li><a href="#how-do-i-implement-shouldcomponentupdate">Jak zaimplementowaÄ‡ <code>shouldComponentUpdate</code>?</a><li><a href="#how-to-memoize-calculations">Jak memoizowaÄ‡ obliczenia?</a><li><a href="#how-to-create-expensive-objects-lazily">Jak w leniwy sposÃ³b tworzyÄ‡ "ciÄ™Å¼kie" obiekty?</a><li><a href="#are-hooks-slow-because-of-creating-functions-in-render">Czy hooki sÄ… wolne z powodu tworzenia funkcji podczas renderowania?</a><li><a href="#how-to-avoid-passing-callbacks-down">Jak unikaÄ‡ przekazywania funkcji zwrotnych w dÃ³Å‚?</a><li><a href="#how-to-read-an-often-changing-value-from-usecallback">Jak odczytywaÄ‡ czÄ™sto zmieniajÄ…cÄ… siÄ™ wartoÅ›Ä‡ z <code>useCallback</code>?</a></ul><li><strong><a href="#under-the-hood">Pod maskÄ…</a></strong><ul><li><a href="#how-does-react-associate-hook-calls-with-components">Jak React Å‚Ä…czy wywoÅ‚ania hookÃ³w z komponentami?</a><li><a href="#what-is-the-prior-art-for-hooks">SkÄ…d wziÄ…Å‚ siÄ™ pomysÅ‚ na stworzenie hookÃ³w?</a></ul></ul><section id="adoption-strategy"class="level2"><h2>Strategia wdraÅ¼ania</h2><section id="which-versions-of-react-include-hooks"class="level3"><h3>KtÃ³re wersje Reacta wspierajÄ… hooki?</h3><p>ZaczynajÄ…c od wersji 16.8.0, React zawiera stabilnÄ… implementacjÄ™ hookÃ³w dla:<ul><li>React DOM<li>React Native<li>React DOM Server<li>React Test Renderer<li>React Shallow Renderer</ul><p>ZauwaÅ¼, Å¼e <strong>aby wÅ‚Ä…czyÄ‡ hooki, wszystkie paczki Reacta muszÄ… mieÄ‡ wersjÄ™ 16.8.0 lub wyÅ¼szÄ…</strong>. Hooki nie zadziaÅ‚ajÄ…, jeÅ¼eli zapomnisz zaktualizowaÄ‡, na przykÅ‚ad, React DOM.<p><a href="https://reactnative.dev/blog/2019/03/12/releasing-react-native-059">React Native wspiera hooki od wersji 0.59</a>.</section><section id="do-i-need-to-rewrite-all-my-class-components"class="level3"><h3>Czy muszÄ™ przepisaÄ‡ wszystkie komponenty klasowe?</h3><p>Nie. <a href="./hooks-intro.html#gradual-adoption-strategy">Nie ma planÃ³w</a> na usuniÄ™cie klas z Reacta -- wszyscy musimy stale dostarczaÄ‡ nasze produkty i nie moÅ¼emy sobie pozwoliÄ‡ na ich przepisywanie. ZachÄ™camy do wyprÃ³bowania hookÃ³w w nowym kodzie.</section><section id="what-can-i-do-with-hooks-that-i-couldnt-with-classes"class="level3"><h3>Co mogÄ™ zrobiÄ‡ z hookami, czego nie moÅ¼na byÅ‚o zrobiÄ‡ z klasami?</h3><p>Hooki oferujÄ… nowy, potÄ™Å¼ny i ekspresyjny sposÃ³b na wielokrotne uÅ¼ywanie funkcjonalnoÅ›ci w komponentach. RozdziaÅ‚ pt. <a href="./hooks-custom.html">"Tworzenie wÅ‚asnych hookÃ³w"</a> zawiera szybki wglÄ…d w to, co moÅ¼na za ich pomocÄ… zrobiÄ‡. <a href="https://medium.com/@dan_abramov/making-sense-of-react-hooks-fdbde8803889">Ten artykuÅ‚</a>, napisany przez jednego z gÅ‚Ã³wnych czÅ‚onkÃ³w zespoÅ‚u Reacta, zawiera bardziej szczegÃ³Å‚owe informacje o nowych moÅ¼liwoÅ›ciach, ktÃ³re pojawiÅ‚y siÄ™ wraz z hookami.</section><section id="how-much-of-my-react-knowledge-stays-relevant"class="level3"><h3>Jaka czÄ™Å›Ä‡ mojej wiedzy o Reakcie jest nadal aktualna?</h3><p>Hooki sÄ… bardziej bezpoÅ›rednim sposobem na uÅ¼ycie dobrze juÅ¼ znanych funkcjonalnoÅ›ci Reacta, takich jak na przykÅ‚ad: stan, cykl Å¼ycia (ang. <em>lifecycle</em>), kontekst i referencje (ang. <em>refs</em>). Nie zmieniajÄ… podstaw dziaÅ‚ania Reacta, dlatego teÅ¼ twoja wiedza na temat komponentÃ³w, wÅ‚aÅ›ciwoÅ›ci (ang. <em>props</em>) i przepÅ‚ywu danych z gÃ³ry w dÃ³Å‚ pozostaje ciÄ…gle aktualna.<p>Hooki, same w sobie, posiadajÄ… pewnÄ… krzywÄ… uczenia siÄ™. JeÅ¼eli brakuje czegoÅ› w tej dokumentacji, <a href="https://github.com/reactjs/reactjs.org/issues/new">zgÅ‚oÅ› problem</a>, a my postaramy siÄ™ pomÃ³c.</section><section id="should-i-use-hooks-classes-or-a-mix-of-both"class="level3"><h3>Czy lepiej uÅ¼ywaÄ‡ hookÃ³w, klas, czy moÅ¼e mieszaÄ‡ obydwa sposoby?</h3><p>ZachÄ™camy do wyprÃ³bowania hookÃ³w w nowych komponentach. Upewnij siÄ™, Å¼e wszyscy z twojego zespoÅ‚u wiedzÄ…, jak ich uÅ¼ywaÄ‡ i sÄ… zapoznani z tÄ… dokumentacjÄ…. Nie zalecamy przepisywania istniejÄ…cych klas na hooki, chyba Å¼e z jakiegoÅ› powodu i tak mieliÅ›cie to w planach (na przykÅ‚ad w celu naprawy istniejÄ…cych bÅ‚Ä™dÃ³w).<p>Nie moÅ¼esz uÅ¼ywaÄ‡ hookÃ³w <em>wewnÄ…trz</em> komponentÃ³w klasowych, jednakÅ¼e bez obaw moÅ¼esz mieszaÄ‡ komponenty klasowe i funkcyjne z hookami w tym samym drzewie. To, czy komponent jest klasowy, czy funkcyjny i uÅ¼ywa hookÃ³w, jest detalem implementacyjnym tego komponentu. W dÅ‚uÅ¼szej perspektywie oczekujemy, Å¼e hooki bÄ™dÄ… gÅ‚Ã³wnym sposobem pisania komponentÃ³w reactowych.</section><section id="do-hooks-cover-all-use-cases-for-classes"class="level3"><h3>Czy hooki obejmujÄ… wszystkie przypadki uÅ¼ycia, ktÃ³re sÄ… dostÄ™pne dla klas?</h3><p>Naszym celem dla hookÃ³w jest zapewnienie wszystkich przypadkÃ³w uÅ¼ycia klas, tak szybko jak to tylko moÅ¼liwe. Brakuje jeszcze odpowiednikÃ³w dla kilku rzadziej uÅ¼ywanych metod cyklu Å¼ycia komponentu, takich jak <code>getSnapshotBeforeUpdate</code>, <code>getDerivedStateFromError</code> i <code>componentDidCatch</code>, ale zamierzamy je wkrÃ³tce dodaÄ‡.</section><section id="do-hooks-replace-render-props-and-higher-order-components"class="level3"><h3>Czy hooki zastÄ™pujÄ… "wÅ‚aÅ›ciwoÅ›ci renderujÄ…ce" i komponenty wyÅ¼szego rzÄ™du?</h3><p>Zazwyczaj wÅ‚aÅ›ciwoÅ›ci renderujace i komponenty wyÅ¼szego rzÄ™du renderujÄ… tylko pojedynczy komponent potomny. SÄ…dzimy, Å¼e hooki sÄ… prostszym sposobem na obsÅ‚ugÄ™ tego przypadku uÅ¼ycia. Nadal jest miejsce dla obu wzorcÃ³w (dla przykÅ‚adu, wirtualny komponent do obsÅ‚ugi suwaka moÅ¼e mieÄ‡ wÅ‚aÅ›ciwoÅ›Ä‡ <code>renderItem</code>, a prezentacyjny komponent kontenera moÅ¼e mieÄ‡ swojÄ… wÅ‚asnÄ… strukturÄ™ DOM). Jednak w wiÄ™kszoÅ›ci przypadkÃ³w hooki w zupeÅ‚noÅ›ci wystarczÄ…, a przy okazji pomogÄ… zmniejszyÄ‡ liczbÄ™ zagnieÅ¼dÅ¼eÅ„ w drzewie.</section><section id="what-do-hooks-mean-for-popular-apis-like-redux-connect-and-react-router"class="level3"><h3>Co hooki oznaczajÄ… dla popularnych API, takich jak Redux connect() i React Router?</h3><p>MoÅ¼esz uÅ¼ywaÄ‡ tych samych API, co do tej pory - bÄ™dÄ… nadal dziaÅ‚aÄ‡.<p>React Redux od wersji v7.1.0 <a href="https://react-redux.js.org/api/hooks">posiada wsparcie dla API hookÃ³w</a> i udostÄ™pnia takie funkcje, jak <code>useDispatch</code> czy <code>useSelector</code>.<p>React Router <a href="https://reacttraining.com/react-router/web/api/Hooks">wspiera hooki</a> od wersji 5.1.<p>W przyszÅ‚oÅ›ci byÄ‡ moÅ¼e takÅ¼e inne biblioteki zacznÄ… wspieraÄ‡ hooki.</section><section id="do-hooks-work-with-static-typing"class="level3"><h3>Czy hooki wspÃ³Å‚pracujÄ… ze statycznym typowaniem?</h3><p>Hooki zostaÅ‚y zaprojektowane z myÅ›lÄ… o statycznym typowaniu. DziÄ™ki temu, Å¼e sÄ… funkcjami, Å‚atwiej jest je poprawnie otypowaÄ‡, w odrÃ³Å¼nieniu od wzorcÃ³w takich jak komponenty wyÅ¼szego rzÄ™du. Najnowsze definicje Reacta dla Flow i TypeScriptu wspierajÄ… hooki.<p>Co waÅ¼ne, przy pomocy bardziej restrykcyjnych typÃ³w moÅ¼esz ograniczyÄ‡ API Reacta we wÅ‚asnych hookach. React dostarcza podstawowe elementy, ale moÅ¼esz je Å‚Ä…czyÄ‡ na rÃ³Å¼ne sposoby, odmienne od tych, ktÃ³re zawarliÅ›my w standardzie.</section><section id="how-to-test-components-that-use-hooks"class="level3"><h3>Jak testowaÄ‡ komponenty, ktÃ³re uÅ¼ywajÄ… hookÃ³w?</h3><p>Z punktu widzenia Reacta komponent wykorzystujÄ…cy hooki jest zwyczajnym komponentem. JeÅ¼eli twoje narzÄ™dzie do testÃ³w nie opiera siÄ™ na wewnÄ™trznej implementacji Reacta, to testowanie komponentÃ³w, ktÃ³re uÅ¼ywajÄ… hookÃ³w, nie powinno rÃ³Å¼niÄ‡ siÄ™ od tego, co robisz zazwyczaj.<blockquote><p>Uwaga<p>W rozdziale pt. <a href="./testing-recipes.html">"Testy: PrzykÅ‚ady i dobre praktyki"</a> znajdziesz wiele przykÅ‚adÃ³w gotowych do uÅ¼ycia.</blockquote><p>Dla przykÅ‚adu, zaÅ‚Ã³Å¼my, Å¼e mamy komponent licznika:<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Example</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>count<span class="token punctuation">,</span> setCount<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
    <span class="token dom variable">document</span><span class="token punctuation">.</span><span class="token property-access">title</span> <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">KlikniÄ™to </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>count<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> razy</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword control-flow">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&#x3C;</span>div<span class="token operator">></span>
      <span class="token operator">&#x3C;</span>p<span class="token operator">></span><span class="token maybe-class-name">KlikniÄ™to</span> <span class="token punctuation">{</span>count<span class="token punctuation">}</span> razy<span class="token operator">&#x3C;</span><span class="token operator">/</span>p<span class="token operator">></span>
      <span class="token operator">&#x3C;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token function">setCount</span><span class="token punctuation">(</span>count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token operator">></span>
        <span class="token maybe-class-name">Kliknij</span> mnie
      <span class="token operator">&#x3C;</span><span class="token operator">/</span>button<span class="token operator">></span>
    <span class="token operator">&#x3C;</span><span class="token operator">/</span>div<span class="token operator">></span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>Przetestujemy go uÅ¼ywajÄ…c React DOM. Aby upewniÄ‡ siÄ™, Å¼e zachowanie komponentu odzwierciedla to w przeglÄ…darce, opakujemy kod renderujÄ…cy i aktualizujÄ…cy w funkcjÄ™ <a href="./test-utils.html#act"><code>ReactTestUtils.act()</code></a>:<pre class="language-js{3,20-22,29-31}"><code class="language-js{3,20-22,29-31}">import React from 'react';
import ReactDOM from 'react-dom/client';
import { act } from 'react-dom/test-utils';
import Counter from './Counter';

let container;

beforeEach(() => {
  container = document.createElement('div');
  document.body.appendChild(container);
});

afterEach(() => {
  document.body.removeChild(container);
  container = null;
});

it('potrafi wyrenderowaÄ‡ i zaktualizowaÄ‡ licznik', () => {
  // Testuje pierwsze renderowanie i efekt
  act(() => {
    ReactDOM.createRoot(container).render(&#x3C;Counter />);
  });
  const button = container.querySelector('button');
  const label = container.querySelector('p');
  expect(label.textContent).toBe('KlikniÄ™to 0 razy');
  expect(document.title).toBe('KlikniÄ™to 0 razy');

  // Testuje drugie renderowanie i efekt
  act(() => {
    button.dispatchEvent(new MouseEvent('click', {bubbles: true}));
  });
  expect(label.textContent).toBe('KlikniÄ™to 1 razy');
  expect(document.title).toBe('KlikniÄ™to 1 razy');
});</code></pre><p>WywoÅ‚anie funkcji <code>act()</code> oprÃ³Å¼ni bufor efektÃ³w znajdujÄ…cych siÄ™ wewnÄ…trz.<p>JeÅ¼eli musisz przetestowaÄ‡ wÅ‚asny hook, moÅ¼esz stworzyÄ‡ komponent w teÅ›cie i wywoÅ‚aÄ‡ ten hook w ciele jego funkcji. NastÄ™pnie moÅ¼esz napisaÄ‡ test do stworzonego w ten sposÃ³b komponentu.<p>Aby zmniejszyÄ‡ powtarzalnoÅ›Ä‡ kodu, zalecamy uÅ¼yÄ‡ biblioteki <a href="https://git.io/react-testing-library"><code>react-testing-library</code></a>. ZostaÅ‚a ona zaprojektowana tak, aby zachÄ™caÄ‡ do pisania testÃ³w uÅ¼ywajÄ…cych komponentÃ³w w sposÃ³b podobny do zachowania docelowych uÅ¼ytkownikÃ³w aplikacji.<p>Po wiÄ™cej informacji zajrzyj do rozdziaÅ‚u pt. <a href="./testing-recipes.html">"Testy: PrzykÅ‚ady i dobre praktyki</a>.</section><section id="what-exactly-do-the-lint-rules-enforce"class="level3"><h3>Co dokÅ‚adnie narzucajÄ… <a href="https://www.npmjs.com/package/eslint-plugin-react-hooks">reguÅ‚y lintera</a>?</h3><p>StworzyliÅ›my <a href="https://www.npmjs.com/package/eslint-plugin-react-hooks">wtyczkÄ™ do ESLinta</a>, ktÃ³ra zmusza do przestrzegania <a href="./hooks-rules.html">zasad hookÃ³w</a> w celu unikniÄ™cia potencjalnych bÅ‚Ä™dÃ³w. ZakÅ‚adajÄ… one, Å¼e kaÅ¼da funkcja zaczynajÄ…ca siÄ™ od "<code>use</code>" i zaraz po tym wielkiej litery jest hookiem. Zdajemy sobie sprawÄ™, Å¼e ta heurystyka nie jest idealna i moÅ¼e wywoÅ‚aÄ‡ wiele faÅ‚szywych alarmÃ³w. Ale bez wprowadzenia wspÃ³lnej dla caÅ‚ego ekosystemu konwencji, nie ma moÅ¼liwoÅ›ci, aby hooki dziaÅ‚aÅ‚y poprawnie -- dÅ‚uÅ¼sze nazwy zniechÄ™cÄ… ludzi do uÅ¼ywania hookÃ³w lub do przestrzegania tej konwencji.<p>W szczegÃ³lnoÅ›ci, reguÅ‚y te wymuszajÄ…, aby:<ul><li>WywoÅ‚ania hookÃ³w znajdowaÅ‚y siÄ™ wewnÄ…trz funkcji pisanej stylem <code>PascalCase</code> (zakÅ‚adajÄ…, Å¼e jest to komponent) lub innej funkcji <code>useSomething</code> (zakÅ‚adajÄ…, Å¼e jest to wÅ‚asny hook).<li>Hooki przy kaÅ¼dym renderowaniu sÄ… wywoÅ‚ywane w tej samej kolejnoÅ›ci.</ul><p>Jest jeszcze kilka innych heurystyk i mogÄ… siÄ™ one z czasem zmieniÄ‡, gdy dostroimy reguÅ‚y tak, aby zbalansowaÄ‡ wyszukiwanie bÅ‚Ä™dÃ³w i zmniejszyÄ‡ liczbÄ™ faÅ‚szywych alarmÃ³w.</section></section><section id="from-classes-to-hooks"class="level2"><h2>Od klas do hookÃ³w</h2><section id="how-do-lifecycle-methods-correspond-to-hooks"class="level3"><h3>Jak wyglÄ…dajÄ… metody cyklu Å¼ycia w odniesieniu do hookÃ³w?</h3><ul><li><p><code>constructor</code>: Komponenty funkcyjne nie potrzebujÄ… konstruktora. Stan jest inicjalizowany poprzez wywoÅ‚anie <a href="./hooks-reference.html#usestate"><code>useState</code></a>. JeÅ¼eli obliczenie stanu poczÄ…tkowego jest kosztowne obliczeniowo, moÅ¼esz do <code>useState</code> przekazaÄ‡ funkcjÄ™.<li><p><code>getDerivedStateFromProps</code>: Zamiast tego zaplanuj aktualizacjÄ™ <a href="#how-do-i-implement-getderivedstatefromprops">podczas renderowania</a>.<li><p><code>shouldComponentUpdate</code>: SpÃ³jrz na <code>React.memo</code> <a href="#how-do-i-implement-shouldcomponentupdate">poniÅ¼ej</a>.<li><p><code>render</code>: Jest to ciaÅ‚o komponentu funkcyjnego.<li><p><code>componentDidMount</code>, <code>componentDidUpdate</code>, <code>componentWillUnmount</code>: Hook <a href="./hooks-reference.html#useeffect"><code>useEffect</code></a> moÅ¼e z powodzeniem zastÄ…piÄ‡ wszelkie kombinacje tych metod (wÅ‚Ä…czajÄ…c w to <a href="#can-i-skip-an-effect-on-updates">mniej</a> <a href="#can-i-run-an-effect-only-on-updates">znane</a> przypadki).<li><p><code>getSnapshotBeforeUpdate</code>, <code>componentDidCatch</code> i <code>getDerivedStateFromError</code>: W tej chwili nie istnieje hook odzwierciedlajÄ…cy dziaÅ‚anie tych metod, ale zostanie wkrÃ³tce dodany.</ul></section><section id="how-can-i-do-data-fetching-with-hooks"class="level3"><h3>Jak mogÄ™ pobraÄ‡ dane wykorzystujÄ…c hooki?</h3><p>Tutaj znajdziesz <a href="https://codesandbox.io/s/jvvkoo8pq3">maÅ‚e demo</a>, ktÃ³re w tym pomoÅ¼e. Aby dowiedzieÄ‡ siÄ™ wiÄ™cej, przeczytaj artykuÅ‚ <a href="https://www.robinwieruch.de/react-hooks-fetch-data/">o pobieraniu danych z wykorzystaniem hookÃ³w</a>.</section><section id="is-there-something-like-instance-variables"class="level3"><h3>Czy istnieje coÅ› podobnego do zmiennych instancji?</h3><p>Tak! Hook <a href="./hooks-reference.html#useref"><code>useRef()</code></a> nie sÅ‚uÅ¼y tylko do przechowywania referencji DOM. Obiekt "ref" jest generycznym kontenerem, ktÃ³rego wÅ‚aÅ›ciwoÅ›Ä‡ <code>current</code> jest zmienna i moÅ¼e przechowywaÄ‡ kaÅ¼dÄ… wartoÅ›Ä‡, tak samo jak wÅ‚aÅ›ciwoÅ›ci instancji w klasach.<p>MoÅ¼esz do niej coÅ› zapisaÄ‡ z wnÄ™trza <code>useEffect</code>:<pre class="language-js{2,8}"><code class="language-js{2,8}">function Timer() {
  const intervalRef = useRef();

  useEffect(() => {
    const id = setInterval(() => {
      // ...
    });
    intervalRef.current = id;
    return () => {
      clearInterval(intervalRef.current);
    };
  });

  // ...
}</code></pre><p>JeÅ¼eli chcielibyÅ›my po prostu ustawiÄ‡ interwaÅ‚, nie potrzebowalibyÅ›my referencji (<code>id</code> mogÅ‚oby byÄ‡ lokalne dla efektu), jednakÅ¼e jest to uÅ¼yteczne w przypadku, gdy chcielibyÅ›my wyczyÅ›ciÄ‡ interwaÅ‚ z wnÄ™trza procedury obsÅ‚ugi zdarzenia:<pre class="language-js{3}"><code class="language-js{3}">  // ...
  function handleCancelClick() {
    clearInterval(intervalRef.current);
  }
  // ...</code></pre><p>DziaÅ‚anie referencji jest takie samo jak uÅ¼ycie zmiennych instancji w klasie. JeÅ›li nie korzystasz z <a href="#how-to-create-expensive-objects-lazily">leniwej inicjalizacji</a>, unikaj uÅ¼ywania referencji podczas renderowania -- moÅ¼e to prowadziÄ‡ do niepoÅ¼Ä…danych zachowaÅ„. Zamiast tego modyfikuj referencje wewnÄ…trz efektÃ³w lub procedur obsÅ‚ugi zdarzeÅ„.</section><section id="should-i-use-one-or-many-state-variables"class="level3"><h3>Lepiej uÅ¼ywaÄ‡ jednej czy wielu zmiennych stanu?</h3><p>JeÅ¼eli na co dzieÅ„ piszesz komponenty klasowe, kuszÄ…ce moÅ¼e okazaÄ‡ siÄ™ wywoÅ‚ywanie <code>useState()</code> jednokrotnie i umieszczanie caÅ‚ego stanu wewnÄ…trz pojedynczego obiektu. JeÅ¼eli chcesz, moÅ¼esz tak robiÄ‡. PoniÅ¼ej znajdziesz przykÅ‚ad komponentu, ktÃ³ry Å›ledzi ruchy kursora. Jego pozycja i stan sÄ… trzymane w lokalnym stanie:<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Box</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>state<span class="token punctuation">,</span> setState<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token literal-property property">left</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token literal-property property">top</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token literal-property property">width</span><span class="token operator">:</span> <span class="token number">100</span><span class="token punctuation">,</span> <span class="token literal-property property">height</span><span class="token operator">:</span> <span class="token number">100</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span></code></pre><p>Teraz przyjmimy, Å¼e chcemy napisaÄ‡ logikÄ™, ktÃ³ra zmienia <code>left</code> i <code>top</code>, kiedy uÅ¼ytkownik ruszy myszkÄ…. ZauwaÅ¼, Å¼e musimy rÄ™cznie scalaÄ‡ te pola z poprzednim obiektem stanu:<pre class="language-js{4,5}"><code class="language-js{4,5}">  // ...
  useEffect(() => {
    function handleWindowMouseMove(e) {
      // Rozszczepienie "...state" zapewnia, Å¼e nie "stracimy" szerokoÅ›ci i wysokoÅ›ci
      setState(state => ({ ...state, left: e.pageX, top: e.pageY }));
    }
    // Uwaga: ta implementacja jest doÅ›Ä‡ uproszczona
    window.addEventListener('mousemove', handleWindowMouseMove);
    return () => window.removeEventListener('mousemove', handleWindowMouseMove);
  }, []);
  // ...</code></pre><p>Gdy aktualizujemy zmiennÄ… stanu, <em>zamieniamy</em> jej wartoÅ›Ä‡. RÃ³Å¼ni siÄ™ to od <code>this.setState</code> w klasach, ktÃ³re <em>scala</em> zaktualizowane pola do obiektu stanu.<p>JeÅ¼eli tÄ™sknisz za automatycznym scalaniem, moÅ¼esz napisaÄ‡ wÅ‚asny hook <code>useLegacyState</code>, ktÃ³ry scala aktualizacje obiektu stanu. Jednak <strong>zalecamy podzielenie stanu na wiele zmiennych stanu, bazujÄ…c na tym, ktÃ³re wartoÅ›ci majÄ… tendencjÄ™ do zmieniania siÄ™ jednoczeÅ›nie.</strong><p>Dla przykÅ‚adu, moÅ¼emy podzieliÄ‡ stan naszego komponentu na obiekty <code>position</code> oraz <code>size</code> i zawsze nadpisywaÄ‡ wartoÅ›Ä‡ <code>position</code>, bez koniecznoÅ›ci scalania stanu z poprzednim:<pre class="language-js{2,7}"><code class="language-js{2,7}">function Box() {
  const [position, setPosition] = useState({ left: 0, top: 0 });
  const [size, setSize] = useState({ width: 100, height: 100 });

  useEffect(() => {
    function handleWindowMouseMove(e) {
      setPosition({ left: e.pageX, top: e.pageY });
    }
    // ...</code></pre><p>Oddzielanie niezaleÅ¼nych zmiennych stanu ma takÅ¼e innÄ… zaletÄ™. Pozwala w przyszÅ‚oÅ›ci Å‚atwo wyodrÄ™bniÄ‡ powiÄ…zanÄ… logikÄ™ do wÅ‚asnego hooka, na przykÅ‚ad:<pre class="language-js{2,7}"><code class="language-js{2,7}">function Box() {
  const position = useWindowPosition();
  const [size, setSize] = useState({ width: 100, height: 100 });
  // ...
}

function useWindowPosition() {
  const [position, setPosition] = useState({ left: 0, top: 0 });
  useEffect(() => {
    // ...
  }, []);
  return position;
}</code></pre><p>ZauwaÅ¼, jak mogliÅ›my przenieÅ›Ä‡ wywoÅ‚anie <code>useState</code> dla zmiennej stanu <code>position</code> i powiÄ…zany z niÄ… efekt do wÅ‚asnego hooka, bez koniecznoÅ›ci zmiany jego kodu. JeÅ¼eli caÅ‚y stan znajdowaÅ‚by siÄ™ w pojedynczym obiekcie, wyodrÄ™bnienie go byÅ‚oby trudniejsze.<p>ZarÃ³wno umieszczanie caÅ‚ego stanu wewnÄ…trz pojedynczego wywoÅ‚ania <code>useState</code>, jak i wywoÅ‚ywanie <code>useState</code> dla kaÅ¼dego pola, bÄ™dzie dziaÅ‚aÄ‡. Komponenty bÄ™dÄ… najbardziej czytelne, jeÅ¼eli osiÄ…gniesz rÃ³wnowagÄ™ pomiÄ™dzy tymi dwoma skrajnoÅ›ciami i pogrupujesz powiÄ…zane ze sobÄ… zmienne stany. JeÅ¼eli logika stanu stanie siÄ™ zbyt zÅ‚oÅ¼ona, zalecamy <a href="./hooks-reference.html#usereducer">uÅ¼ycie reduktora</a> lub napisanie wÅ‚asnego hooka.</section><section id="can-i-run-an-effect-only-on-updates"class="level3"><h3>Czy mogÄ™ uruchomiÄ‡ efekt tylko podczas aktualizacji komponentu?</h3><p>Jest to rzadki przypadek. JeÅ¼eli masz takÄ… potrzebÄ™, moÅ¼esz <a href="#is-there-something-like-instance-variables">uÅ¼yÄ‡ zmiennej referencji</a>, aby przechowaÄ‡ wartoÅ›Ä‡ logicznÄ…, okreÅ›lajÄ…cÄ… czy jest to pierwsze, czy kolejne renderowanie, a nastÄ™pnie sprawdzaÄ‡ tÄ™ flagÄ™ w efekcie. (JeÅ¼eli okaÅ¼e siÄ™, Å¼e robisz to czÄ™sto, moÅ¼esz w tym celu stworzyÄ‡ wÅ‚asnego hooka.)</section><section id="how-to-get-the-previous-props-or-state"class="level3"><h3>Jak dostaÄ‡ poprzednie wÅ‚aÅ›ciwoÅ›ci lub stan?</h3><p>Poprzednich wÅ‚aÅ›ciwoÅ›ci i stanu moÅ¼esz potrzebowaÄ‡ w dwÃ³ch przypadkach.<p>Czasami bÄ™dziesz potrzebowaÄ‡ poprzednich wÅ‚aÅ›ciwoÅ›ci, aby <strong>posprzÄ…taÄ‡ po efekcie</strong>. PrzykÅ‚ad: masz efekt, ktÃ³ry subskrybuje siÄ™ do socketu na podstawie wÅ‚aÅ›ciwoÅ›ci <code>userId</code>. JeÅ›li wartoÅ›Ä‡ <code>userId</code> zmieni siÄ™, naleÅ¼aÅ‚oby anulowaÄ‡ subskrypcjÄ™ z <em>poprzednim</em> <code>userId</code> i stworzyÄ‡ nowÄ… z <em>nastÄ™pnÄ…</em> wartoÅ›ciÄ…. Aby to zrobiÄ‡, nie potrzeba niczego nadzwyczajnego:<pre class="language-js"><code class="language-js"><span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
  <span class="token maybe-class-name">ChatAPI</span><span class="token punctuation">.</span><span class="token method function property-access">subscribeToSocket</span><span class="token punctuation">(</span>props<span class="token punctuation">.</span><span class="token property-access">userId</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword control-flow">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token maybe-class-name">ChatAPI</span><span class="token punctuation">.</span><span class="token method function property-access">unsubscribeFromSocket</span><span class="token punctuation">(</span>props<span class="token punctuation">.</span><span class="token property-access">userId</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>props<span class="token punctuation">.</span><span class="token property-access">userId</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>W powyÅ¼szym przykÅ‚adzie, jeÅ›li <code>userId</code> zmieni siÄ™ z <code>3</code> na <code>4</code>, najpierw wywoÅ‚a siÄ™ <code>ChatAPI.unsubscribeFromSocket(3)</code>, a nastÄ™pnie <code>ChatAPI.subscribeToSocket(4)</code>. Nie ma potrzeby dostÄ™pu do "poprzedniego" <code>userId</code>, poniewaÅ¼ funkcja sprzÄ…tajÄ…ca uchwyci go w domkniÄ™ciu (ang. <em>closure</em>).<p>Innym razem moÅ¼esz potrzebowaÄ‡ <strong>zaktualizowaÄ‡ stan przy jakiejÅ› zmianie wÅ‚aÅ›ciwoÅ›ci lub innego stanu</strong>. Rzadko siÄ™ tak zdarza i zwykle oznacza, Å¼e masz jakiÅ› zduplikowany lub niepotrzebny kawaÅ‚ek stanu. JeÅ›li jednak naprawdÄ™ potrzebujesz skorzystaÄ‡ z tego wzorca, moÅ¼esz <a href="#how-do-i-implement-getderivedstatefromprops">zapamiÄ™taÄ‡ w stanie poprzedniÄ… wartoÅ›Ä‡ jakiegoÅ› stanu lub wÅ‚aÅ›ciwoÅ›ci i aktualizowaÄ‡ jÄ… podczas renderowania</a>.<p>Poprzednio do przechowywania poprzedniej wartoÅ›ci zasugerowaliÅ›my skorzystanie z hooka o nazwie <code>usePrevious</code>. Mimo to zauwaÅ¼yliÅ›my, Å¼e w wiÄ™kszoÅ›ci przypadku mamy do czynienia z jednym z dwÃ³ch powyÅ¼szych schematÃ³w. JeÅ›li twÃ³j przypadek jest inny, moÅ¼esz <a href="#is-there-something-like-instance-variables">zapisaÄ‡ wartoÅ›Ä‡ w referencji (ang. <em>ref</em>)</a> i rÄ™cznie aktualizowaÄ‡ jÄ… w razie potrzeby. SprÃ³buj jednak unikaÄ‡ odczytywania i aktualizowania referencji podczas renderowania, gdyÅ¼ zmniejszy to przewidywalnoÅ›Ä‡ i czytelnoÅ›Ä‡ twojego komponentu.</section><section id="why-am-i-seeing-stale-props-or-state-inside-my-function"class="level3"><h3>Dlaczego widzÄ™ nieaktualne wÅ‚aÅ›ciwoÅ›ci lub stan wewnÄ…trz mojej funkcji?</h3><p>KaÅ¼da funkcja wewnÄ…trz komponentu, wÅ‚Ä…czajÄ…c w to procedury obsÅ‚ugi zdarzeÅ„ i efekty, "widzÄ…" wÅ‚aÅ›ciwoÅ›ci i stan z chwili renderowania, w ktÃ³rym zostaÅ‚y stworzone. Dla przykÅ‚adu rozwaÅ¼ poniÅ¼szy kod:<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Example</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>count<span class="token punctuation">,</span> setCount<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">function</span> <span class="token function">handleAlertClick</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
      <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'KlikniÄ™to: '</span> <span class="token operator">+</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword control-flow">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&#x3C;</span>div<span class="token operator">></span>
      <span class="token operator">&#x3C;</span>p<span class="token operator">></span><span class="token maybe-class-name">KlikniÄ™to</span> <span class="token punctuation">{</span>count<span class="token punctuation">}</span> razy<span class="token operator">&#x3C;</span><span class="token operator">/</span>p<span class="token operator">></span>
      <span class="token operator">&#x3C;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token function">setCount</span><span class="token punctuation">(</span>count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token operator">></span>
        <span class="token maybe-class-name">NaciÅ›nij</span> mnie
      <span class="token operator">&#x3C;</span><span class="token operator">/</span>button<span class="token operator">></span>
      <span class="token operator">&#x3C;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span>handleAlertClick<span class="token punctuation">}</span><span class="token operator">></span>
        <span class="token maybe-class-name">PokaÅ¼</span> okno ostrzegawcze
      <span class="token operator">&#x3C;</span><span class="token operator">/</span>button<span class="token operator">></span>
    <span class="token operator">&#x3C;</span><span class="token operator">/</span>div<span class="token operator">></span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>JeÅ¼eli najpierw klikniesz "PokaÅ¼ okno ostrzegawcze", a nastÄ™pnie zwiÄ™kszysz licznik, okno ostrzegawcze wyÅ›wietli wartoÅ›Ä‡ zmiennej <code>count</code> <strong>z momentu klikniÄ™cia na przycisk "PokaÅ¼ okno ostrzegawcze"</strong>. Zapobiega to bÅ‚Ä™dom powodowanym przez kod zakÅ‚adajÄ…cy, Å¼e wÅ‚aÅ›ciwoÅ›ci i stan nie zmieniÄ… siÄ™ w czasie.<p>JeÅ¼eli celowo chcesz odczytaÄ‡ <em>najÅ›wieÅ¼szy</em> stan z wnÄ™trza asynchronicznej funkcji zwrotnej, moÅ¼esz go przechowywaÄ‡, zmieniaÄ‡ i odczytywaÄ‡ korzystajÄ…c z <a href="./hooks-faq.html#is-there-something-like-instance-variables">referencji</a>.<p>Ostatecznie, innÄ… moÅ¼liwÄ… przyczynÄ… tego, Å¼e widzisz nieaktualne wÅ‚aÅ›ciwoÅ›ci lub stan, moÅ¼e byÄ‡ uÅ¼ycie "tablicy zaleÅ¼noÅ›ci" do optymalizacji, ale niepoprawne sprecyzowanie wszystkich zaleÅ¼noÅ›ci. Dla przykÅ‚adu, jeÅ¼eli efekt otrzymuje <code>[]</code> jako drugi argument, ale wewnÄ…trz odczytuje <code>someProp</code>, efekt bÄ™dzie stale "widziaÅ‚" poczÄ…tkowÄ… wartoÅ›Ä‡ <code>someProp</code>. RozwiÄ…zaniem jest usuniÄ™cie tablicy zaleÅ¼noÅ›ci lub naprawienie jej. Tutaj znajdziesz informacje, <a href="#is-it-safe-to-omit-functions-from-the-list-of-dependencies">jak poradziÄ‡ sobie z funkcjami</a>, a tutaj <a href="#what-can-i-do-if-my-effect-dependencies-change-too-often">inne powszechne sposoby na uruchamianie efektÃ³w rzadziej i bez bÅ‚Ä™dÃ³w w zaleÅ¼noÅ›ciach</a>.<blockquote><p>Uwaga<p>StworzyliÅ›my reguÅ‚Ä™ <a href="https://github.com/facebook/react/issues/14920"><code>exhaustive-deps</code></a> dla ESLinta i dodaliÅ›my jÄ… do paczki <a href="https://www.npmjs.com/package/eslint-plugin-react-hooks#installation"><code>eslint-plugin-react-hooks</code></a>. Wtyczka ostrzega, gdy zaleÅ¼noÅ›ci sÄ… sprecyzowane niepoprawnie i zaleca poprawienie kodu.</blockquote></section><section id="how-do-i-implement-getderivedstatefromprops"class="level3"><h3>Jak zaimplementowaÄ‡ <code>getDerivedStateFromProps</code>?</h3><p>Prawdopodobnie <a href="/blog/2018/06/07/you-probably-dont-need-derived-state.html">w ogÃ³le nie potrzebujesz tej funkcjonalnoÅ›ci</a>. W rzadkich przypadkach, w ktÃ³rych naprawdÄ™ bÄ™dziesz tego potrzebowaÄ‡ (na przykÅ‚ad implementacja komponentu <code>&#x3C;Transition></code>), moÅ¼esz zaktualizowaÄ‡ stan w trakcie renderowania. React wywoÅ‚a ponownie komponent z zaktualizowanym stanem natychmiast po pierwszym renderowaniu, wiÄ™c nie wpÅ‚ynie to znaczÄ…co na wydajnoÅ›Ä‡.<p>W poniÅ¼szym kodzie przechowujemy poprzedniÄ… wartoÅ›Ä‡ wÅ‚aÅ›ciwoÅ›ci <code>row</code> w zmiennej stanowej, dziÄ™ki czemu moÅ¼emy wykonaÄ‡ porÃ³wnanie:<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">ScrollView</span></span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span>row<span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>isScrollingDown<span class="token punctuation">,</span> setIsScrollingDown<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>prevRow<span class="token punctuation">,</span> setPrevRow<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token keyword null nil">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>row <span class="token operator">!==</span> prevRow<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// Wiersz zmieniÅ‚ siÄ™ od ostatniego renderowania. Zaktualizuj isScrollingDown.</span>
    <span class="token function">setIsScrollingDown</span><span class="token punctuation">(</span>prevRow <span class="token operator">!==</span> <span class="token keyword null nil">null</span> <span class="token operator">&#x26;&#x26;</span> row <span class="token operator">></span> prevRow<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">setPrevRow</span><span class="token punctuation">(</span>row<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword control-flow">return</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Przewijanie w dÃ³Å‚: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>isScrollingDown<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>Na pierwszy rzut oka moÅ¼e to wyglÄ…daÄ‡ dziwnie, ale aktualizacja podczas renderowania jest dokÅ‚adnie tym samym, czym w zaÅ‚oÅ¼eniu metoda <code>getDerivedStateFromProps</code> byÅ‚a od zawsze.</section><section id="is-there-something-like-forceupdate"class="level3"><h3>Czy istnieje coÅ› takiego jak <code>forceUpdate</code>?</h3><p>ZarÃ³wno <code>useState</code>, jak i <code>useReducer</code> <a href="./hooks-reference.html#bailing-out-of-a-state-update">wycofujÄ… siÄ™ z aktualizacji</a>, jeÅ¼eli kolejna wartoÅ›Ä‡ jest taka sama jak poprzednia. Zmiana stanu bez uÅ¼ycia <code>setState</code>, a nastÄ™pnie wywoÅ‚anie <code>setState</code> nie skutkuje ponownym renderowaniem komponentu.<p>Zazwyczaj nie powinno siÄ™ bezpoÅ›rednio modyfikowaÄ‡ lokalnego stanu w Reakcie. MoÅ¼esz jednak inkrementowaÄ‡ licznik, aby wymusiÄ‡ ponowne renderowanie, nawet jeÅ›li stan siÄ™ nie zmieniÅ‚:<pre class="language-js"><code class="language-js">  <span class="token keyword">const</span> <span class="token punctuation">[</span>ignored<span class="token punctuation">,</span> forceUpdate<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useReducer</span><span class="token punctuation">(</span><span class="token parameter">x</span> <span class="token arrow operator">=></span> x <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">function</span> <span class="token function">handleClick</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">forceUpdate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span></code></pre><p>JeÅ¼eli to moÅ¼liwe, staraj siÄ™ unikaÄ‡ tego wzorca.</section><section id="can-i-make-a-ref-to-a-function-component"class="level3"><h3>Czy mogÄ™ stworzyÄ‡ referencjÄ™ do komponentu funkcyjnego?</h3><p>Nie powinno siÄ™ tego robiÄ‡ zbyt czÄ™sto, jednak moÅ¼esz upubliczniÄ‡ niektÃ³re imperatywne metody dla komponentu rodzica uÅ¼ywajÄ…c hooka <a href="./hooks-reference.html#useimperativehandle"><code>useImperativeHandle</code></a>.</section><section id="how-can-i-measure-a-dom-node"class="level3"><h3>Jak mogÄ™ zmierzyÄ‡ wÄ™zeÅ‚ DOM?</h3><p>Aby zmierzyÄ‡ pozycjÄ™ lub rozmiar wÄ™zÅ‚a DOM, moÅ¼esz uÅ¼yÄ‡ <a href="./refs-and-the-dom.html#callback-refs">referencji z funkcjÄ… zwrotnÄ…</a>. React wywoÅ‚a funkcjÄ™ zwrotnÄ…, gdy referencja zostanie przypisana do innego wÄ™zÅ‚a. Tutaj znajdziesz <a href="https://codesandbox.io/s/l7m0v5x4v9">prosty przykÅ‚ad</a>:<pre class="language-js{4-8,12}"><code class="language-js{4-8,12}">function MeasureExample() {
  const [height, setHeight] = useState(0);

  const measuredRef = useCallback(node => {
    if (node !== null) {
      setHeight(node.getBoundingClientRect().height);
    }
  }, []);

  return (
    &#x3C;>
      &#x3C;h1 ref={measuredRef}>Witaj, Å›wiecie&#x3C;/h1>
      &#x3C;h2>PowyÅ¼szy nagÅ‚Ã³wek ma {Math.round(height)} pikseli wysokoÅ›ci&#x3C;/h2>
    &#x3C;/>
  );
}</code></pre><p>W tym przykÅ‚adzie nie zdecydowaliÅ›my siÄ™ uÅ¼yÄ‡ <code>useRef</code>, poniewaÅ¼ obiekt referencji nie powiadamia nas o <em>zmianach</em> jego aktualnej wartoÅ›ci. UÅ¼ycie referencji z funkcjÄ… zwrotnÄ… daje pewnoÅ›Ä‡, Å¼e <a href="https://codesandbox.io/s/818zzk8m78">nawet jeÅ›li komponent potomny wyÅ›wietli mierzony wÄ™zeÅ‚ pÃ³Åºniej</a> (np. w odpowiedzi na przyciÅ›niÄ™cie przycisku), komponent nadrzÄ™dny zostanie o tym powiadomiony i moÅ¼e zaktualizowaÄ‡ swÃ³j pomiar.<p>ZauwaÅ¼, Å¼e przekazaliÅ›my <code>[]</code> jako tablicÄ™ zaleÅ¼noÅ›ci do <code>useCallback</code>. Gwarantuje to nam niezmienialnoÅ›Ä‡ funkcji zwrotnej pomiedzy ponownymi renderowaniami oraz Å¼e React nie wywoÅ‚a jej bez potrzeby.<p>W tym przykÅ‚adzie funkcja zwrotna referencji zostanie wywoÅ‚ana tylko w momencie zamontowania i odmontowania komponentu. Dzieje siÄ™ tak dlatego, Å¼e komponent <code>&#x3C;h1></code> jest obecny w kaÅ¼dym renderowaniu. JeÅ›li chcesz otrzymywaÄ‡ powiadomienie przy kaÅ¼dej zmianie rozmiaru komponentu, proponujemy skorzystaÄ‡ z <a href="https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserver"><code>ResizeObserver</code></a> lub hooka z jakiejÅ› biblioteki zewnÄ™trznej opartej na tym mechanizmie.<p>W razie koniecznoÅ›ci moÅ¼na <a href="https://codesandbox.io/s/m5o42082xy">wyodrÄ™bniÄ‡ tÄ™ logikÄ™</a> do osobnego hooka i uÅ¼ywaÄ‡ wielokrotnie:<pre class="language-js{2}"><code class="language-js{2}">function MeasureExample() {
  const [rect, ref] = useClientRect();
  return (
    &#x3C;>
      &#x3C;h1 ref={ref}>Witaj, Å›wiecie&#x3C;/h1>
      {rect !== null &#x26;&#x26;
        &#x3C;h2>PowyÅ¼szy nagÅ‚Ã³wek ma {Math.round(rect.height)} pikseli wysokoÅ›ci&#x3C;/h2>
      }
    &#x3C;/>
  );
}

function useClientRect() {
  const [rect, setRect] = useState(null);
  const ref = useCallback(node => {
    if (node !== null) {
      setRect(node.getBoundingClientRect());
    }
  }, []);
  return [rect, ref];
}</code></pre></section><section id="what-does-const-thing-setthing--usestate-mean"class="level3"><h3>Co oznacza <code>const [thing, setThing] = useState()</code>?</h3><p>JeÅ¼eli nie rozpoznajesz tej skÅ‚adni, sprawdÅº <a href="./hooks-state.html#tip-what-do-square-brackets-mean">wyjaÅ›nienie</a> w dokumentacji hooka stanu.</section></section><section id="performance-optimizations"class="level2"><h2>Optymalizacja wydajnoÅ›ci</h2><section id="can-i-skip-an-effect-on-updates"class="level3"><h3>Czy mogÄ™ pominÄ…Ä‡ efekt podczas aktualizacji komponentu?</h3><p>Tak. Zapoznaj siÄ™ z <a href="./hooks-reference.html#conditionally-firing-an-effect">warunkowym uruchamianiem efektÃ³w</a>. PamiÄ™taj jednak, Å¼e pomijanie aktualizacji czÄ™sto <a href="./hooks-effect.html#explanation-why-effects-run-on-each-update">prowadzi do bÅ‚Ä™dÃ³w</a>, z tego teÅ¼ powodu nie jest to domyÅ›lnie dziaÅ‚anie.</section><section id="is-it-safe-to-omit-functions-from-the-list-of-dependencies"class="level3"><h3>Czy bezpiecznie jest pomijaÄ‡ funkcje w liÅ›cie zaleÅ¼noÅ›ci?</h3><p>OgÃ³lnie rzecz biorÄ…c, nie.<pre class="language-js{3,8}"><code class="language-js{3,8}">function Example({ someProp }) {
  function doSomething() {
    console.log(someProp);
  }

  useEffect(() => {
    doSomething();
  }, []); // ğŸ”´ Niebezpieczne (wywoÅ‚uje `doSomething`, ktÃ³re uÅ¼ywa `someProp`)
}</code></pre><p>Trudno jest pamiÄ™taÄ‡, ktÃ³re wÅ‚aÅ›ciwoÅ›ci lub stan sÄ… uÅ¼ywane przez funkcje poza efektem. Dlatego teÅ¼ <strong>zazwyczaj lepiej jest deklarowaÄ‡ funkcje <em>wewnÄ…trz</em> efektu.</strong> DziÄ™ki temu Å‚atwo moÅ¼na zauwaÅ¼yÄ‡, od ktÃ³rych wartoÅ›ci komponentu zaleÅ¼y efekt:<pre class="language-js{4,8}"><code class="language-js{4,8}">function Example({ someProp }) {
  useEffect(() => {
    function doSomething() {
      console.log(someProp);
    }

    doSomething();
  }, [someProp]); // âœ… OK (efekt uÅ¼ywa wyÅ‚Ä…cznie `someProp`)
}</code></pre><p>JeÅ¼eli po zmianach efekt nadal nie uÅ¼ywa wartoÅ›ci z zakresu komponentu, moÅ¼na bezpiecznie uÅ¼yÄ‡ <code>[]</code>:<pre class="language-js{7}"><code class="language-js{7}">useEffect(() => {
  function doSomething() {
    console.log('CzeÅ›Ä‡!');
  }

  doSomething();
}, []); // âœ… OK, poniewaÅ¼ *Å¼adne* wartoÅ›ci z zakresu komponentu nie sÄ… uÅ¼ywane wewnÄ…trz efektu</code></pre><p>W zaleÅ¼noÅ›ci od przypadku uÅ¼ycia, istnieje kilka dodatkowych opcji, ktÃ³re opisaliÅ›my poniÅ¼ej.<blockquote><p>Uwaga<p>StworzyliÅ›my reguÅ‚Ä™ <a href="https://github.com/facebook/react/issues/14920"><code>exhaustive-deps</code></a> (pol. <em>wyczerpujÄ…ce zaleÅ¼noÅ›ci</em>), bÄ™dÄ…cÄ… czÄ™Å›ciÄ… paczki <a href="https://www.npmjs.com/package/eslint-plugin-react-hooks#installation"><code>eslint-plugin-react-hooks</code></a>. Pomaga w znalezieniu komponentÃ³w, ktÃ³re nie obsÅ‚ugujÄ… aktualizacji w konsekwentny sposÃ³b.</blockquote><p>SpÃ³jrzmy, dlaczego ma to znaczenie.<p>Kiedy okreÅ›lasz <a href="./hooks-reference.html#conditionally-firing-an-effect">tablicÄ™ zaleÅ¼noÅ›ci</a>, ostatni argument dla <code>useEffect</code>, <code>useLayoutEffect</code>, <code>useMemo</code>, <code>useCallback</code>, lub <code>useImperativeHandle</code> powinien zawieraÄ‡ wszystkie wartoÅ›ci biorÄ…ce udziaÅ‚ w przepÅ‚ywie danych, wÅ‚Ä…czajÄ…c w to wÅ‚aÅ›ciwoÅ›ci, stan i wszystkie ich pochodne.<p>Jedynym <strong>bezpiecznym</strong> przypadkiem pominiÄ™cia argumentu w tablicy zaleÅ¼noÅ›ci jest przekazanie funkcji, ktÃ³ra w swoim wnÄ™trzu nie ma odniesieÅ„ do wÅ‚aÅ›ciwoÅ›ci, stanu lub wartoÅ›ci z nich dziedziczÄ…cych. PoniÅ¼szy przykÅ‚ad zawiera bÅ‚Ä…d:<pre class="language-js{5,12}"><code class="language-js{5,12}">function ProductPage({ productId }) {
  const [product, setProduct] = useState(null);

  async function fetchProduct() {
    const response = await fetch('http://myapi/product/' + productId); // UÅ¼ywa wÅ‚aÅ›ciwoÅ›ci productId
    const json = await response.json();
    setProduct(json);
  }

  useEffect(() => {
    fetchProduct();
  }, []); // ğŸ”´ BÅ‚Ä…d, poniewaÅ¼ `fetchProduct` uÅ¼ywa `productId`
  // ...
}</code></pre><p><strong>Zalecanym sposobem naprawienia tego, jest przeniesienie funkcji do <em>wnÄ™trza</em> efektu</strong>. DziÄ™ki temu Å‚atwiej bÄ™dzie nam dostrzec stan lub wÅ‚aÅ›ciwoÅ›ci, ktÃ³rych uÅ¼ywa efekt, i upewniÄ‡ siÄ™, Å¼e wszystkie z nich zostaÅ‚y zadeklarowane:<pre class="language-js{5-10,13}"><code class="language-js{5-10,13}">function ProductPage({ productId }) {
  const [product, setProduct] = useState(null);

  useEffect(() => {
    // Po przeniesienu funkcji do wnÄ™trza efektu, moÅ¼emy Å‚atwo dostrzec, ktÃ³rych wartoÅ›ci uÅ¼ywa.
    async function fetchProduct() {
      const response = await fetch('http://myapi/product/' + productId);
      const json = await response.json();
      setProduct(json);
    }

    fetchProduct();
  }, [productId]); // âœ… Poprawnie, poniewaÅ¼ efekt uÅ¼ywa wyÅ‚Ä…cznie productId
  // ...
}</code></pre><p>Pozwala to rÃ³wnieÅ¼ na obsÅ‚uÅ¼enie asynchronicznych odpowiedzi, stosujÄ…c zmiennÄ… lokalnÄ… wewnÄ…trz efektu:<pre class="language-js{2,6,10}"><code class="language-js{2,6,10}">  useEffect(() => {
    let ignore = false;
    async function fetchProduct() {
      const response = await fetch('http://myapi/product/' + productId);
      const json = await response.json();
      if (!ignore) setProduct(json);
    }

    fetchProduct();
    return () => { ignore = true };
  }, [productId]);</code></pre><p>PrzenieÅ›liÅ›my funkcjÄ™ do wnÄ™trza efektu, dlatego teÅ¼ nie musi ona znajdowaÄ‡ siÄ™ w tablicy zaleÅ¼noÅ›ci.<blockquote><p>WskazÃ³wka<p>Aby dowiedzieÄ‡ siÄ™ wiÄ™cej o pobieraniu danych za pomocÄ… hookÃ³w, sprawdÅº <a href="https://codesandbox.io/s/jvvkoo8pq3">ten przykÅ‚ad</a> i <a href="https://www.robinwieruch.de/react-hooks-fetch-data/">ten artykuÅ‚</a>.</blockquote><p><strong>JeÅ¼eli z jakichÅ› przyczyn <em>nie</em> moÅ¼esz przenieÅ›Ä‡ funkcji do wnÄ™trza efektu, istnieje kilka innych opcji:</strong><ul><li><strong>MoÅ¼esz sprÃ³bowaÄ‡ przenieÅ›Ä‡ funkcjÄ™ poza swÃ³j komponent</strong>. W tym przypadku funkcja nie bÄ™dzie odnosiÄ‡ siÄ™ do Å¼adnych wÅ‚aÅ›ciwoÅ›ci czy stanu, dlatego teÅ¼ nie bÄ™dzie potrzeby dodawania jej do tablicy zaleÅ¼noÅ›ci.<li>JeÅ¼eli funkcja, ktÃ³rÄ… wywoÅ‚ujesz, wykonuje jedynie obliczenia i moÅ¼na jÄ… bezpiecznie wywoÅ‚aÄ‡ podczas renderowania, moÅ¼esz zechcieÄ‡ <strong>wywoÅ‚aÄ‡ jÄ… poza efektem</strong> i uzaleÅ¼niÄ‡ efekt od zwrÃ³conej przez niÄ… wartoÅ›ci.<li>W ostatecznoÅ›ci, moÅ¼esz <strong>dodaÄ‡ funkcjÄ™ do zaleÅ¼noÅ›ci efektu poprzez <em>opakowanie jej definicji</em></strong>, korzystajÄ…c z hooka <a href="./hooks-reference.html#usecallback"><code>useCallback</code></a>. Zapewnia to niezmiennoÅ›Ä‡ podczas renderowania, dopÃ³ki nie zmieni siÄ™ rÃ³wnieÅ¼ <em>jej wÅ‚asna</em> tablica zaleÅ¼noÅ›ci:</ul><pre class="language-js{2-5}"><code class="language-js{2-5}">function ProductPage({ productId }) {
  // âœ… Opakowanie za pomocÄ… useCallback, aby uniknÄ…Ä‡ zmian przy kaÅ¼dym renderowaniu
  const fetchProduct = useCallback(() => {
    // ... Korzysta z productId ...
  }, [productId]); // âœ… Zdefiniowane zostaÅ‚y wszystkie zaleÅ¼noÅ›ci useCallback

  return &#x3C;ProductDetails fetchProduct={fetchProduct} />;
}

function ProductDetails({ fetchProduct }) {
  useEffect(() => {
    fetchProduct();
  }, [fetchProduct]); // âœ… Zdefiniowane zostaÅ‚y wszystkie zaleÅ¼noÅ›ci useEffect
  // ...
}</code></pre><p>ZauwaÅ¼, Å¼e w powyÅ¼szym przykÅ‚adzie <strong>musieliÅ›my</strong> przekazaÄ‡ funkcjÄ™ do tablicy zaleÅ¼noÅ›ci. DziÄ™ki temu zmiana wÅ‚aÅ›ciwoÅ›ci <code>productId</code> w <code>ProductPage</code> bÄ™dzie automatycznie uruchamiaÅ‚a ponowne pobranie danych w komponencie <code>ProductDetails</code>.</section><section id="what-can-i-do-if-my-effect-dependencies-change-too-often"class="level3"><h3>Co zrobiÄ‡, gdy zaleÅ¼noÅ›ci mojego efektu zmieniajÄ… siÄ™ zbyt czÄ™sto?</h3><p>Czasem twÃ³j efekt moÅ¼e korzystaÄ‡ ze stanu, ktÃ³ry zmienia siÄ™ zbyt czÄ™sto. MoÅ¼e ciÄ™ kusiÄ‡ usuniÄ™cie go z listy zaleÅ¼noÅ›ci, jednak zwykle prowadzi to do bÅ‚Ä™dÃ³w.:<pre class="language-js{6,9}"><code class="language-js{6,9}">function Counter() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    const id = setInterval(() => {
      setCount(count + 1); // Ten efekt zaleÅ¼y od wartoÅ›ci `count`
    }, 1000);
    return () => clearInterval(id);
  }, []); // ğŸ”´ BÅ‚Ä…d: Zmienna `count` nie zostaÅ‚a wymieniona w zaleÅ¼noÅ›ciach

  return &#x3C;h1>{count}&#x3C;/h1>;
}</code></pre><p>Pusty zbiÃ³r zaleÅ¼noÅ›ci, <code>[]</code>, oznacza, Å¼e efekt ten zostanie uruchomiony tylko jeden raz podczas montowania komponentu, ale juÅ¼ nie przy kolejnych renderowaniach. Problem polega na tym, iÅ¼ wartoÅ›Ä‡ zmiennej <code>count</code> wewnÄ…trz funkcji zwrotnej przekazanej do <code>setInterval</code> nie bÄ™dzie siÄ™ zmieniaÄ‡. Dzieje siÄ™ dlatego, Å¼e stworzyliÅ›my dla niej domkniÄ™cie (ang. <em>closure</em>), w ktÃ³rym <code>count</code> ma wartoÅ›Ä‡ <code>0</code>, poniewaÅ¼ z takÄ… wartoÅ›ciÄ… uruchomiono ten efekt. Co sekundÄ™ funkcja zwrotna bÄ™dzie wywoÅ‚ywaÅ‚a <code>setCount(0 + 1)</code>, przez co wartoÅ›Ä‡ licznika nigdy nie przekroczy 1.<p>Podanie <code>[count]</code> jako listy zaleÅ¼noÅ›ci mogÅ‚oby naprawiÄ‡ ten bÅ‚Ä…d, jednak spowodowaÅ‚oby to resetowanie siÄ™ interwaÅ‚u przy kaÅ¼dej zmianie stanu. W konsekwencji, kaÅ¼dy <code>setInterval</code> miaÅ‚by jednÄ… szansÄ™ na wykonanie, zanim zostaÅ‚by wyczyszczony (zachowanie podobne do <code>setTimeout</code>). Raczej nie o to nam chodzi. Aby temu zapobiec, moÅ¼emy skorzystaÄ‡ z <a href="./hooks-reference.html#functional-updates">funkcyjnego wariantu aktualizacji poprzez <code>setState</code></a>. Pozwoli to nam okreÅ›liÄ‡, <em>jak</em> stan powinien siÄ™ zmieniÄ‡, bez odnoszenia siÄ™ do konkretnego <em>aktualnego</em> stanu:<pre class="language-js{6,9}"><code class="language-js{6,9}">function Counter() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    const id = setInterval(() => {
      setCount(c => c + 1); // âœ… Nie zaleÅ¼y od zewnÄ™trznej zmiennej `count`
    }, 1000);
    return () => clearInterval(id);
  }, []); // âœ… Nasz efekt nie korzysta z Å¼adnych zmiennych z zakresu komponentu

  return &#x3C;h1>{count}&#x3C;/h1>;
}</code></pre><p>(StaÅ‚oÅ›Ä‡ referencyjna funkcji <code>setCount</code> jest zagwarantowana przez Reacta, wiÄ™c moÅ¼na jÄ… pominÄ…Ä‡ na liÅ›cie zaleÅ¼noÅ›ci.)<p>Teraz funkcja zwrotna przekazana do <code>setInterval</code> wywoÅ‚ywana jest co sekundÄ™, lecz za kaÅ¼dym razem wywoÅ‚anie <code>setCount</code> wewnÄ…trz korzysta z aktualnej wartoÅ›ci licznika <code>count</code> (nazwanej lokalnie jako <code>c</code>).<p>W bardziej zawiÅ‚ych przypadkach (np. gdy jeden stan zaleÅ¼y od drugiego), sprÃ³buj przenieÅ›Ä‡ logikÄ™ zmiany stanu poza efekt przy pomocy <a href="./hooks-reference.html#usereducer">hooka <code>useReducer</code></a>. <a href="https://adamrackis.dev/state-and-use-reducer/">W tym artykule</a> pokazano przykÅ‚ad jego zastosowania. <strong>ToÅ¼samoÅ›Ä‡ funkcji <code>dispatch</code> zwrÃ³conej przez <code>useReducer</code> jest zawsze stabilna</strong> â€” nawet jeÅ›li reduktor jest deklarowany wewnÄ…trz komponentu i odczytuje jego wÅ‚aÅ›ciwoÅ›ci.<p>Ostatecznie, jeÅ›li zechcesz skorzystaÄ‡ z czegoÅ› w rodzaju klasowego <code>this</code>, moÅ¼esz <a href="./hooks-faq.html#is-there-something-like-instance-variables">uÅ¼yÄ‡ referencji</a> do przechowania mutowalnej zmiennej. Wtedy moÅ¼liwe bÄ™dzie jej nadpisywanie i odczytywanie w dowolnym momencie. Na przykÅ‚ad:<pre class="language-js{2-6,10-11,16}"><code class="language-js{2-6,10-11,16}">function Example(props) {
  // Trzymamy ostatnie wÅ‚aÅ›ciwoÅ›ci w referencji.
  const latestProps = useRef(props);
  useEffect(() => {
    latestProps.current = props;
  });

  useEffect(() => {
    function tick() {
      // Odczytujemy ostatnie wÅ‚aÅ›ciwoÅ›ci w dowolnym momencie
      console.log(latestProps.current);
    }

    const id = setInterval(tick, 1000);
    return () => clearInterval(id);
  }, []); // Ten efekt nigdy nie uruchomi siÄ™ ponownie
}</code></pre><p>RÃ³b tak tylko, gdy nie znajdziesz lepszej alternatywy, poniewaÅ¼ poleganie na mutacjach negatywnie wpÅ‚ywa na przewidywalnoÅ›Ä‡ zachowania siÄ™ komponentÃ³w. JeÅ›li znasz jakiÅ› wzorzec, ktÃ³rego nie da siÄ™ w prosty sposÃ³b wyraziÄ‡ za pomocÄ… hookÃ³w, <a href="https://github.com/facebook/react/issues/new">zgÅ‚oÅ› to nam</a>, zaÅ‚Ä…czajÄ…c przykÅ‚ad dziaÅ‚ajÄ…cego kodu, a my postaramy siÄ™ pomÃ³c.</section><section id="how-do-i-implement-shouldcomponentupdate"class="level3"><h3>Jak zaimplementowaÄ‡ <code>shouldComponentUpdate</code>?</h3><p>MoÅ¼esz opakowaÄ‡ komponent funkcyjny za pomocÄ… <code>React.memo</code>, aby zastosowaÄ‡ pÅ‚ytkie porÃ³wnanie jego wÅ‚aÅ›ciwoÅ›ci:<pre class="language-js"><code class="language-js"><span class="token keyword">const</span> <span class="token maybe-class-name">Button</span> <span class="token operator">=</span> <span class="token maybe-class-name">React</span><span class="token punctuation">.</span><span class="token method function property-access">memo</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
  <span class="token comment">// twÃ³j komponent</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>Nie jest to hook, bo nie komponuje siÄ™ jak hooki. <code>React.memo</code> jest odpowiednikiem klasy <code>PureComponent</code>, jednak ogranicza siÄ™ do porÃ³wnywania wyÅ‚Ä…cznie wÅ‚aÅ›ciwoÅ›ci. (MoÅ¼esz takÅ¼e jako drugi argument przekazaÄ‡ funkcjÄ™ porÃ³wnujÄ…cÄ… poprzednie i aktualne wÅ‚aÅ›ciwoÅ›ci. JeÅ›li zwrÃ³ci <code>true</code>, aktualizacja komponentu zostanie pominiÄ™ta.)<p><code>React.memo</code> nie porÃ³wnuje stanu komponentu, poniewaÅ¼ komponenty funkcyjne nie majÄ… jednego jedynego obiektu stanu, jak to ma miejsce w komponentach klasowych. MoÅ¼esz jednak sprawiÄ‡, by komponenty potomne rÃ³wnieÅ¼ byÅ‚y "czystymi" komponentami (ang. <em>pure components</em>), a nawet <a href="./hooks-faq.html#how-to-memoize-calculations">zoptymalizowaÄ‡ poszczegÃ³lnych potomkÃ³w za pomocÄ… <code>useMemo</code></a>.</section><section id="how-to-memoize-calculations"class="level3"><h3>Jak memoizowaÄ‡ obliczenia?</h3><p>Za pomocÄ… hooka <a href="./hooks-reference.html#usememo"><code>useMemo</code></a> moÅ¼esz zapamiÄ™taÄ‡ wynik obliczeÅ„ pomiÄ™dzy kolejnymi renderowaniami:<pre class="language-js"><code class="language-js"><span class="token keyword">const</span> memoizedValue <span class="token operator">=</span> <span class="token function">useMemo</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token function">computeExpensiveValue</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>a<span class="token punctuation">,</span> b<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>PowyÅ¼szy kod wywoÅ‚uje funkcjÄ™ <code>computeExpensiveValue(a, b)</code>, ktÃ³ra wykonuje kosztowne obliczenia. JeÅ›li jednak zaleÅ¼noÅ›ci <code>[a, b]</code> nie zmieniÅ‚y siÄ™ od ostatniego razu, <code>useMemo</code> pominie kolejne wywoÅ‚anie funkcji i zamiast tego zwrÃ³ci ostatni wynik.<p>PamiÄ™taj, Å¼e funkcja przekazana do <code>useMemo</code> wywoÅ‚ywana jest podczas renderowania. Nie rÃ³b w niej niczego, czego normalnie nie robisz podczas renderowania. Oznacza to, Å¼e, na przykÅ‚ad, efekty uboczne naleÅ¼y umieszczaÄ‡ w <code>useEffect</code>, a nie w <code>useMemo</code>.<p><strong>Traktuj uÅ¼ycie <code>useMemo</code> jako optymalizacjÄ™ szybkoÅ›ci programu, a nie "gwarancjÄ™ semantycznÄ…" (ang. <em>semantic guarantee</em>).</strong> W przyszÅ‚oÅ›ci React byÄ‡ moÅ¼e bÄ™dzie "zapominaÅ‚" niektÃ³re zapisane wyniki i przeliczaÅ‚ je dopiero przy nastÄ™pnym renderowaniu, np. aby zwolniÄ‡ pamiÄ™Ä‡ przydzielonÄ… dla komponentÃ³w, ktÃ³rych nie widaÄ‡ na ekranie. Pisz swÃ³j kod tak, aby dziaÅ‚aÅ‚ bez uÅ¼ycia <code>useMemo</code> â€” a dopiero pÃ³Åºniej dodawaj ten hook w celach optymalizacyjnych. (W sporadycznych przypadkach, w ktÃ³rych wynik <em>nigdy</em> nie powinien byÄ‡ przeliczany na nowo, zalecamy skorzystaÄ‡ z <a href="#how-to-create-expensive-objects-lazily">leniwie inicjalizowanej referencji</a>.)<p>Co wiÄ™cej, <code>useMemo</code> pozwala takÅ¼e pominÄ…Ä‡ kosztowne renderowania komponentÃ³w potomnych:<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Parent</span></span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> a<span class="token punctuation">,</span> b <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// Ponownie renderowany tylko wtedy, gdy zmieni siÄ™ `a`:</span>
  <span class="token keyword">const</span> child1 <span class="token operator">=</span> <span class="token function">useMemo</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token operator">&#x3C;</span><span class="token maybe-class-name">Child1</span> a<span class="token operator">=</span><span class="token punctuation">{</span>a<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">,</span> <span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// Ponownie renderowany tylko wtedy, gdy zmieni siÄ™ `b`:</span>
  <span class="token keyword">const</span> child2 <span class="token operator">=</span> <span class="token function">useMemo</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token operator">&#x3C;</span><span class="token maybe-class-name">Child2</span> b<span class="token operator">=</span><span class="token punctuation">{</span>b<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">,</span> <span class="token punctuation">[</span>b<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword control-flow">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&#x3C;</span><span class="token operator">></span>
      <span class="token punctuation">{</span>child1<span class="token punctuation">}</span>
      <span class="token punctuation">{</span>child2<span class="token punctuation">}</span>
    <span class="token operator">&#x3C;</span><span class="token operator">/</span><span class="token operator">></span>
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre><p>PamiÄ™taj jednak, Å¼e to podejÅ›cie nie zadziaÅ‚a w pÄ™tli, poniewaÅ¼ <a href="./hooks-rules.html">hookÃ³w nie moÅ¼na wywoÅ‚ywaÄ‡ w pÄ™tlach</a>. MoÅ¼esz jednak wydzieliÄ‡ osobny komponent renderujÄ…cy element listy, a nastÄ™pnie wywoÅ‚aÄ‡ w nim <code>useMemo</code>.</section><section id="how-to-create-expensive-objects-lazily"class="level3"><h3>Jak w leniwy sposÃ³b tworzyÄ‡ "ciÄ™Å¼kie" obiekty?</h3><p><code>useMemo</code> pozwala na <a href="#how-to-memoize-calculations">memoizacjÄ™ kosztownych obliczeÅ„</a>, pod warunkiem, Å¼e ich zaleÅ¼noÅ›ci sÄ… takie same. Jest to jednak tylko wskazÃ³wka i nie <em>gwarantuje</em>, Å¼e obliczenia nie zostanÄ… uruchomione ponownie. Czasem jednak chcesz mieÄ‡ pewnoÅ›Ä‡, Å¼e obiekt zostanie stworzony dokÅ‚adnie raz.<p><strong>Pierwszy z czÄ™stych przypadkÃ³w dotyczy kosztownego tworzenia stanu poczÄ…tkowego:</strong><pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Table</span></span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// âš ï¸ Funkcja createRows() bÄ™dzie wywoÅ‚ywana przy kaÅ¼dym renderowaniu</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>rows<span class="token punctuation">,</span> setRows<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token function">createRows</span><span class="token punctuation">(</span>props<span class="token punctuation">.</span><span class="token property-access">count</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span></code></pre><p>Aby uniknÄ…Ä‡ ponownego tworzenia i tak ignorowanego stanu poczÄ…tkowego, moÅ¼emy do <code>useState</code> przekazaÄ‡ <strong>funkcjÄ™ inicjalizujÄ…cÄ…</strong>:<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Table</span></span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// âœ… Funkcja createRows() bÄ™dzie wywoÅ‚ana tylko raz</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>rows<span class="token punctuation">,</span> setRows<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token function">createRows</span><span class="token punctuation">(</span>props<span class="token punctuation">.</span><span class="token property-access">count</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span></code></pre><p>React wywoÅ‚a funkcjÄ™ tylko przy pierwszym renderowaniu. Po wiÄ™cej informacji zajrzyj do <a href="./hooks-reference.html#usestate">dokumentacji API hooka <code>useState</code></a>.<p><strong>Czasem moÅ¼esz chcieÄ‡ uniknÄ…Ä‡ wielokrotnego tworzenia wartoÅ›ci poczÄ…tkowej dla hooka <code>useRef()</code>.</strong> Na przykÅ‚ad, jeÅ›li chcesz mieÄ‡ pewnoÅ›Ä‡, Å¼e zostanie utworzona tylko jedna instancja danej klasy:<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Image</span></span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// âš ï¸ Instancja klasy IntersectionObserver bÄ™dzie tworzona przy kaÅ¼dym renderowaniu</span>
  <span class="token keyword">const</span> ref <span class="token operator">=</span> <span class="token function">useRef</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">IntersectionObserver</span><span class="token punctuation">(</span>onIntersect<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span></code></pre><p>Hook <code>useRef</code> <strong>nie przyjmuje</strong> alternatywnego argumentu w postaci funkcji, jak ma to miejsce w <code>useState</code>. Zamiast tego moÅ¼esz napisaÄ‡ wÅ‚asnÄ… funkcjÄ™, ktÃ³ra tworzy i ustawia wartoÅ›Ä‡ referencji w sposÃ³b leniwy:<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Image</span></span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> ref <span class="token operator">=</span> <span class="token function">useRef</span><span class="token punctuation">(</span><span class="token keyword null nil">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// âœ… Instancja klasy IntersectionObserver zostanie stworzona leniwie tylko raz</span>
  <span class="token keyword">function</span> <span class="token function">getObserver</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>ref<span class="token punctuation">.</span><span class="token property-access">current</span> <span class="token operator">===</span> <span class="token keyword null nil">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      ref<span class="token punctuation">.</span><span class="token property-access">current</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">IntersectionObserver</span><span class="token punctuation">(</span>onIntersect<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword control-flow">return</span> ref<span class="token punctuation">.</span><span class="token property-access">current</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// W razie potrzeby moÅ¼esz wywoÅ‚aÄ‡ getObserver()</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span></code></pre><p>Pozwala to uniknÄ…Ä‡ tworzenia kosztownych obiektÃ³w do czasu, aÅ¼ faktycznie bÄ™dÄ… potrzebne. JeÅ›li uÅ¼ywasz Flow lub TypeScriptu, moÅ¼esz dla pewnoÅ›ci dodatkowo nadaÄ‡ funkcji <code>getObserver()</code> typ nie dopuszczajÄ…cy wartoÅ›ci <code>null</code> (ang. <em>non-nullable type</em>).</section><section id="are-hooks-slow-because-of-creating-functions-in-render"class="level3"><h3>Czy hooki sÄ… wolne z powodu tworzenia funkcji podczas renderowania?</h3><p>Nie. We wspÃ³Å‚czesnych przeglÄ…darkach wydajnoÅ›Ä‡ domkniÄ™Ä‡ w porÃ³wnaniu z zastosowaniem klas nie rÃ³Å¼ni siÄ™ znaczÄ…co, za wyjÄ…tkiem sytuacji ekstremalnych.<p>Ponadto, warto zwrÃ³ciÄ‡ uwagÄ™, Å¼e sposÃ³b dziaÅ‚ania hookÃ³w jest bardziej wydajny pod kilkoma wzglÄ™dami:<ul><li><p>Hooki unikajÄ… sporej czÄ™Å›ci narzutu, jaki wprowadzajÄ… klasy - jak choÄ‡by koszt tworzenia instancji klasy czy dowiÄ…zywanie procedur obsÅ‚ugi zdarzeÅ„ w konstruktorze.<li><p><strong>Kod idiomatyczny uÅ¼ywajÄ…cy hookÃ³w nie wymaga gÅ‚Ä™bokiego zagnieÅ¼dÅ¼ania drzewa komponentÃ³w</strong>, co ma miejsce w kodzie korzystajÄ…cym z komponentÃ³w wyÅ¼szego rzÄ™du (ang. <em>higher-order components</em>), wÅ‚aÅ›ciwoÅ›ci renderujÄ…cych (ang. <em>render props</em>) i kontekstu. W mniejszych drzewach komponentÃ³w React ma mniej do roboty.</ul><p>Tradycyjnie juÅ¼, obawy dotyczÄ…ce wydajnoÅ›ci dla <em>funkcji inline</em> w Reakcie byÅ‚y zwiÄ…zane z sytuacjami, w ktÃ³rych przekazywanie kaÅ¼dorazowo nowych funkcji zwrotnych do komponentÃ³w potomnych niwelowaÅ‚o optymalizacjÄ™ zapewnionÄ… przez <code>shouldComponentUpdate</code> w potomkach. Hooki rozwiÄ…zujÄ… ten problem na trzy sposoby.<ul><li><p>Hook <a href="./hooks-reference.html#usecallback"><code>useCallback</code></a> pozwala na przechowywanie tej samej referencji do funkcji zwrotnej pomiÄ™dzy kolejnymi renderowaniami, dziÄ™ki czemu metoda <code>shouldComponentUpdate</code> moÅ¼e dziaÅ‚aÄ‡ poprawnie:<pre class="language-js{2}"><code class="language-js{2}">// Nie zmieni siÄ™, dopÃ³ki nie zmieniÄ… siÄ™ `a` lub `b`
const memoizedCallback = useCallback(() => {
  doSomething(a, b);
}, [a, b]);</code></pre><li><p>Hook <a href="./hooks-faq.html#how-to-memoize-calculations"><code>useMemo</code></a> uÅ‚atwia kontrolowanie tego, kiedy aktualizowane sÄ… poszczegÃ³lne komponenty potomne, zmniejszajÄ…c potrzebÄ™ stosowania czystych komponentÃ³w (ang. <em>pure components</em>).<li><p>Wreszcie hook <a href="./hooks-reference.html#usereducer"><code>useReducer</code></a> zmniejsza potrzebÄ™ przekazywania funkcji zwrotnych do dalekich potomkÃ³w, co wyjaÅ›niono poniÅ¼ej.</ul></section><section id="how-to-avoid-passing-callbacks-down"class="level3"><h3>Jak unikaÄ‡ przekazywania funkcji zwrotnych w dÃ³Å‚?</h3><p>Z naszych obserwacji wynika, Å¼e programiÅ›ci nie lubiÄ… rÄ™cznego przekazywania funkcji zwrotnych w dÃ³Å‚ przez kilka poziomÃ³w drzewa komponentÃ³w. Nawet jeÅ›li kod w ten sposÃ³b staje siÄ™ bardziej bezpoÅ›redni, moÅ¼emy odnieÅ›Ä‡ wraÅ¼enie, Å¼e zbyt duÅ¼o czasu poÅ›wiÄ™camy "hydraulice" programu.<p>W duÅ¼ych drzewach komponentÃ³w sugerujemy przekazywaÄ‡ funkcjÄ™ <code>dispatch</code>, zwrÃ³conÄ… przez hooka <a href="./hooks-reference.html#usereducer"><code>useReducer</code></a>, poprzez kontekst:<pre class="language-js{4,5}"><code class="language-js{4,5}">const TodosDispatch = React.createContext(null);

function TodosApp() {
  // Uwaga: `dispatch` nie zmieni siÄ™ pomiÄ™dzy renderowaniami
  const [todos, dispatch] = useReducer(todosReducer);

  return (
    &#x3C;TodosDispatch.Provider value={dispatch}>
      &#x3C;DeepTree todos={todos} />
    &#x3C;/TodosDispatch.Provider>
  );
}</code></pre><p>Dowolny komponent poddrzewa wewnÄ…trz <code>TodosApp</code> moÅ¼e uÅ¼yÄ‡ funkcji <code>dispatch</code>, aby uruchomiÄ‡ akcjÄ™ z <code>TodosApp</code>:<pre class="language-js{2,3}"><code class="language-js{2,3}">function DeepChild(props) {
  // JeÅ›li chcemy wykonaÄ‡ jakÄ…Å› akcjÄ™, moÅ¼emy wyciÄ…gnÄ…Ä‡ funkcjÄ™ `dispatch` z kontekstu.
  const dispatch = useContext(TodosDispatch);

  function handleClick() {
    dispatch({ type: 'add', text: 'zrobiÄ‡ pranie' });
  }

  return (
    &#x3C;button onClick={handleClick}>Dodaj zadanie&#x3C;/button>
  );
}</code></pre><p>Jest to wygodne zarÃ³wno z perspektywy utrzymania kodu (nie trzeba przekazywaÄ‡ funkcji zwrotnych w nieskoÅ„czonoÅ›Ä‡), jak i ogÃ³lnie unikniÄ™cia problemÃ³w z tego typu funkcjami. Sugerujemy zatem wykonywaÄ‡ wszelkie "odlegÅ‚e" aktualizacje za pomocÄ… przekazanej w dÃ³Å‚ funkcji <code>dispatch</code>.<p>PamiÄ™taj, Å¼e nadal moÅ¼esz wybraÄ‡ pomiÄ™dzy przekazywaniem <em>stanu</em> aplikacji w dÃ³Å‚ za pomocÄ… wÅ‚aÅ›ciwoÅ›ci (bardziej "wprost") lub za pomocÄ… kontekstu (wygodniejsze w przypadku "odlegÅ‚ych" aktualizacji). JeÅ›li chcesz uÅ¼yÄ‡ kontekstu takÅ¼e do przekazania stanu, sugerujemy skorzystaÄ‡ z dwÃ³ch niezaleÅ¼nych kontekstÃ³w. Kontekst przekazujÄ…cy <code>dispatch</code> nigdy siÄ™ nie zmienia, dziÄ™ki czemu uÅ¼ywajÄ…ce go komponenty nie muszÄ… byÄ‡ ponownie renderowane, o ile same w jawny sposÃ³b nie poproszÄ… o stan.</section><section id="how-to-read-an-often-changing-value-from-usecallback"class="level3"><h3>Jak odczytywaÄ‡ czÄ™sto zmieniajÄ…cÄ… siÄ™ wartoÅ›Ä‡ wewnÄ…trz <code>useCallback</code>?</h3><blockquote><p>Uwaga<p>Zalecamy <a href="#how-to-avoid-passing-callbacks-down">przekazywaÄ‡ w dÃ³Å‚ funkcjÄ™ <code>dispatch</code> za pomocÄ… kontekstu</a>, a nie poszczegÃ³lne funkcje zwrotne za pomocÄ… wÅ‚aÅ›ciwoÅ›ci. PoniÅ¼szy sposÃ³b zostaÅ‚ tu umieszczony tylko jako uzupeÅ‚nienie i "furtka awaryjna".</blockquote><p>W rzadkich przypadkach pojawia siÄ™ potrzeba memoizowania funkcji zwrotnej za pomocÄ… hooka <a href="./hooks-reference.html#usecallback"><code>useCallback</code></a>, lecz nie przynosi to Å¼adnej korzyÅ›ci, poniewaÅ¼ wewnÄ™trzna funkcja i tak tworzona jest zbyt czÄ™sto. JeÅ›li memoizowana funkcja jest procedurÄ… obsÅ‚ugi zdarzeÅ„ i nie jest wywoÅ‚ywana podczas renderowania, moÅ¼na stworzyÄ‡ <a href="#is-there-something-like-instance-variables">referencjÄ™ do zmiennej</a> i rÄ™cznie aktualizowaÄ‡ jej wartoÅ›Ä‡:<pre class="language-js{6,10}"><code class="language-js{6,10}">function Form() {
  const [text, updateText] = useState('');
  const textRef = useRef();

  useEffect(() => {
    textRef.current = text; // Nadpisz wartoÅ›Ä‡ referencji
  });

  const handleSubmit = useCallback(() => {
    const currentText = textRef.current; // Odczytaj wartoÅ›Ä‡ referencji
    alert(currentText);
  }, [textRef]); // Nie twÃ³rz ponownie `handleSubmit`, jak byÅ‚oby przy `[text]`

  return (
    &#x3C;>
      &#x3C;input value={text} onChange={e => updateText(e.target.value)} />
      &#x3C;ExpensiveTree onSubmit={handleSubmit} />
    &#x3C;/>
  );
}</code></pre><p>Metoda ta moÅ¼e wydawaÄ‡ siÄ™ mocno zagmatwana, lecz pokazuje, Å¼e moÅ¼na, w razie potrzeby, skorzystaÄ‡ z tego typu optymalizacji. Åatwiej z niej korzystaÄ‡ po wydzieleniu logiki do osobnego hooka:<pre class="language-js{4,16}"><code class="language-js{4,16}">function Form() {
  const [text, updateText] = useState('');
  // Podlega memoizacji, nawet gdy zmienia siÄ™ `text`:
  const handleSubmit = useEventCallback(() => {
    alert(text);
  }, [text]);

  return (
    &#x3C;>
      &#x3C;input value={text} onChange={e => updateText(e.target.value)} />
      &#x3C;ExpensiveTree onSubmit={handleSubmit} />
    &#x3C;/>
  );
}

function useEventCallback(fn, dependencies) {
  const ref = useRef(() => {
    throw new Error('Niedozwolone wywoÅ‚anie procedury obsÅ‚ugi zdarzeÅ„ podczas renderowania.');
  });

  useEffect(() => {
    ref.current = fn;
  }, [fn, ...dependencies]);

  return useCallback(() => {
    const fn = ref.current;
    return fn();
  }, [ref]);
}</code></pre><p>Tak czy inaczej, <strong>nie zalecamy korzystania z tego sposobu</strong>, a pokazujemy go tylko dla kompletnoÅ›ci dokumentacji. Zamiast tego lepiej jest <a href="#how-to-avoid-passing-callbacks-down">unikaÄ‡ przekazywania funkcji zwrotnych gÅ‚Ä™boko w dÃ³Å‚</a>.</section></section><section id="under-the-hood"class="level2"><h2>Pod maskÄ…</h2><section id="how-does-react-associate-hook-calls-with-components"class="level3"><h3>Jak React Å‚Ä…czy wywoÅ‚ania hookÃ³w z komponentami?</h3><p>React sprawuje kontrolÄ™ nad aktualnie renderowanym komponentem. DziÄ™ki <a href="./hooks-rules.html">zasadom korzystania z hookÃ³w</a> wiemy, Å¼e hooki mogÄ… byÄ‡ wywoÅ‚ywane tylko z wnÄ™trza komponentÃ³w reactowych (lub wÅ‚asnych hookÃ³w -- ktÃ³re rÃ³wnieÅ¼ moÅ¼na wywoÅ‚ywaÄ‡ tylko w komponentach reactowych).<p>Do kaÅ¼dego komponentu przypisana jest wewnÄ™trzna lista "komÃ³rek pamiÄ™ci". SÄ… to zwykÅ‚e obiekty javascriptowe, w ktÃ³rych przechowujemy jakieÅ› dane. Kiedy wywoÅ‚ujesz hook, np. <code>useState()</code>, odczytuje on aktualnÄ… zawartoÅ›Ä‡ komÃ³rki (lub tworzy nowÄ… podczas pierwszego renderowania), a nastÄ™pnie przesuwa "wskaÅºnik" na kolejnÄ… komÃ³rkÄ™. To dziÄ™ki temu kaÅ¼de z kilku wywoÅ‚aÅ„ <code>useState()</code> moÅ¼e zarzÄ…dzaÄ‡ niezaleÅ¼nÄ… porcjÄ… lokalnego stanu.</section><section id="what-is-the-prior-art-for-hooks"class="level3"><h3>SkÄ…d wziÄ…Å‚ siÄ™ pomysÅ‚ na stworzenie hookÃ³w?</h3><p>Hooki Å‚Ä…czÄ… pomysÅ‚y z wielu rÃ³Å¼nych ÅºrÃ³deÅ‚:<ul><li>Nasze stare eksperymenty z funkcyjnymi API w repozytorium <a href="https://github.com/reactjs/react-future/tree/master/07%20-%20Returning%20State">react-future</a>.<li>Eksperymenty spoÅ‚ecznoÅ›ci reactowej z interfejsami dla wÅ‚aÅ›ciwoÅ›ci renderujÄ…cych, wliczajÄ…c w to <a href="https://github.com/reactions/component">Reactions Component</a> autorstwa <a href="https://github.com/ryanflorence">Ryana Florence'a</a>.<li>PropozycjÄ™ <a href="https://github.com/trueadm">Dominica Gannawaya</a> dotyczÄ…cÄ… wprowadzenia <a href="https://gist.github.com/trueadm/17beb64288e30192f3aa29cad0218067">sÅ‚owa kluczowego <code>adopt</code></a> jako nowej skÅ‚adni dla wÅ‚aÅ›ciwoÅ›ci renderujÄ…cych.<li>Zmienne stanu i komÃ³rki stanu w jÄ™zyku <a href="http://displayscript.org/introduction.html">DisplayScript</a>.<li><a href="https://reasonml.github.io/reason-react/docs/en/state-actions-reducer.html">Komponenty redukujÄ…ce</a> w ReasonReact.<li><a href="http://reactivex.io/rxjs/class/es6/Subscription.js~Subscription.html">Subskrypcje</a> w Rx.<li><a href="https://github.com/ocamllabs/ocaml-effects-tutorial#2-effectful-computations-in-a-pure-setting">Efekty algebraiczne</a> w Multicore OCaml.</ul><p><a href="https://github.com/sebmarkbage">Sebastian MarkbÃ¥ge</a> wymyÅ›liÅ‚ pierwowzÃ³r hookÃ³w, ktÃ³ry pÃ³Åºniej zostaÅ‚ udoskonalony przez <a href="https://github.com/acdlite">Andrewa Clarka</a>, <a href="https://github.com/sophiebits">Sophie Alpert</a>, <a href="https://github.com/trueadm">Dominica Gannawaya</a> i innych czÅ‚onkÃ³w zespoÅ‚u Reacta. <span style="float:footnote"><a href="./index.html#toc">Go to TOC</a></span></section></section></section>