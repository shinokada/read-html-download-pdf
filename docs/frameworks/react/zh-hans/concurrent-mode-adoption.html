<!doctypehtml><html lang="zh-hans"><meta charset="utf-8"><title>使用 Concurrent 模式（实验性）</title><meta name="viewport"content="width=device-width,initial-scale=1"><link rel="stylesheet"href="https://raw.githubusercontent.com/shinokada/prism-coy-theme/main/theme_common.css"><section id="使用-concurrent-模式实验性"class="level1"><h1>使用 Concurrent 模式（实验性）</h1><style>.scary>blockquote{background-color:rgba(237,51,21,.2);border-left-color:#ed3315}</style><div class="scary"><blockquote><p>注意：<p>本章节所描述的功能还处于实验阶段，在稳定版本中尚不可用。它面向的人群是早期使用者以及好奇心较强的人。<p>本页面中许多信息现已过时，仅仅是为了存档而存在。欲了解最新信息，<strong>请参阅 <a href="/blog/2021/06/08/the-plan-for-react-18.html">React 18 Alpha 版公告</a></strong>。<p>在 React 18 发布前，我们将用稳定的文档替代此章节。</blockquote></div><ul><li><a href="#installation">安装</a><ul><li><a href="#who-is-this-experimental-release-for">此实验版本适用于谁？</a><li><a href="#enabling-concurrent-mode">开启 concurrent 模式</a></ul><li><a href="#what-to-expect">有何期望</a><ul><li><a href="#migration-step-blocking-mode">迁移步骤： blocking 模式</a><li><a href="#why-so-many-modes">为什么有这么多模式？</a><li><a href="#feature-comparison">特性对比</a></ul></ul><section id="installation"class="level2"><h2>安装</h2><p>concurrent 模式目前仅在 React 的<a href="/blog/2019/10/22/react-release-channels.html#experimental-channel">实验版本</a>可用。安装命令：<pre class="language-text"><code class="language-text">npm install react@experimental react-dom@experimental</code></pre><p><strong>实验版本与语义版本不同。</strong> 在 <code>@experimental</code> 版本，API 会随时增删改。<p><strong>实验版本经常会包含破坏性更改</strong><p>你可以在个人项目或新分支中尝试这些实验性功能，但我们并不建议在生产环境中使用它们。在 Facebook，我们<strong>确实</strong>在生产环境中使用它们，但我们在使用的同时也修复了 bug。<strong>再次强调，请不要在生产环境使用！</strong><section id="who-is-this-experimental-release-for"class="level3"><h3>此实验版本适用于谁？</h3><p>这个版本主要针对功能早期使用者、库作者和对此好奇的人。<p>我们在生产中使用这段代码，但是仍然有一些 bug、缺少许多特性，且文档存在缺陷。我们希望了解更多关于 concurrent 模式中的出现的问题，以便更好地为未来发布稳定版本做准备。</section><section id="enabling-concurrent-mode"class="level3"><h3>开启 concurrent 模式</h3><p>通常，当我们给 React 添加功能的时候，你可以立即使用。比如 Fragments，Context，甚至 Hook。你都可以直接在代码里使用他们，而不用修改之前的代码。<p>concurrent 模式并不是这样。它给引入了新的语义，改变了 React 的工作方式。否则<em>不能启用</em><a href="./concurrent-mode-patterns.html">这些新功能</a>。这就是它被分组到了新的模式，而不是相继的发布出来。<p>你不能为某个子树单独启用 concurrent 模式。你应该在 <code>ReactDOM.render()</code> 里启用它。<p><strong>这会在整个 <code>&#x3C;App /></code> 结构树里启用 concurrent 模式：</strong><pre class="language-js"><code class="language-js"><span class="token keyword module">import</span> <span class="token imports"><span class="token maybe-class-name">ReactDOM</span></span> <span class="token keyword module">from</span> <span class="token string">'react-dom'</span><span class="token punctuation">;</span>

<span class="token comment">// 如果你之前的代码是：</span>
<span class="token comment">//</span>
<span class="token comment">// ReactDOM.render(&#x3C;App />, document.getElementById('root'));</span>
<span class="token comment">//</span>
<span class="token comment">// 你可以用下面的代码引入 concurrent 模式：</span>

<span class="token maybe-class-name">ReactDOM</span><span class="token punctuation">.</span><span class="token method function property-access">unstable_createRoot</span><span class="token punctuation">(</span>
  <span class="token dom variable">document</span><span class="token punctuation">.</span><span class="token method function property-access">getElementById</span><span class="token punctuation">(</span><span class="token string">'root'</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token method function property-access">render</span><span class="token punctuation">(</span><span class="token operator">&#x3C;</span><span class="token maybe-class-name">App</span> <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><blockquote><p>注意：<p>concurrent 模式 API 如 <code>createRoot</code> 只存在于 React 实验版本。</blockquote><p>在 concurrent 模式下，生命周期<a href="/blog/2018/03/27/update-on-async-rendering.html">之前被标记过</a>为“不安全”是真的不安全，会比现在的 React 出现更多的 bug。在你的 app 完全兼容<a href="https://reactjs.org/docs/strict-mode.html">严格模式</a>之前，我们不建议使用 concurrent 模式。</section></section><section id="what-to-expect"class="level2"><h2>有何期望</h2><p>如果你有已完成的大型 app，或着你的 app 有大量第三方依赖，请不要立即使用 concurrent 模式。<strong>比如在 Facebook 我们在新网站的开发上使用 concurrent 模式，并没有打算在旧的网站开发上使用。</strong> 这是因为我们旧网站的代码里使用了不安全的生命周期方法、不兼容第三方库、与 concurrent 模式也不兼容。<p>根据我们的经验，使用常见的 React 开发模式，并且不依赖外部状态管理的代码最容易切换到 concurrent 模式。在接下来的几周内，我们会列出常见的问题和解决方案。<section id="migration-step-blocking-mode"class="level3"><h3>迁移步骤： blocking 模式</h3><p>对于较旧的代码库，concurrent 模式可能步子迈的太大。这就是我们在实验版本中提供“ blocking 模式”的原因。你可以通过使用 <code>createBlockingRoot</code> 代替 <code>createRoot</code> 尝试一下。它仅提供了 concurrent 模式的<em>小部分功能</em>，但它更接近于 React 今天的工作方式，可以作为迁移的一个步骤。<p>回顾：<ul><li><strong>legacy 模式：</strong> <code>ReactDOM.render(&#x3C;App />, rootNode)</code>。这是当前 React app 使用的方式。当前没有计划删除本模式，但是这个模式可能不支持这些新功能。<li><strong>blocking 模式：</strong> <code>ReactDOM.createBlockingRoot(rootNode).render(&#x3C;App />)</code>。目前正在实验中。作为迁移到 concurrent 模式的第一个步骤。<li><strong>concurrent 模式：</strong> <code>ReactDOM.createRoot(rootNode).render(&#x3C;App />)</code>。目前在实验中，未来稳定之后，打算作为 React 的默认开发模式。这个模式开启了<em>所有的</em>新功能。</ul></section><section id="why-so-many-modes"class="level3"><h3>为什么有这么多模式？</h3><p>我们认为提供<a href="./faq-versioning.html#commitment-to-stability">渐进的迁移策略</a>比进行破坏性的更改或者使 React 停滞不前是更好的选择。<p>实际上，我们希望今天使用 legacy 模式的大多数 app 至少能迁移到 blocking 模式（如果不能迁移到 concurrent 模式）。对于希望在短期内支持所有模式的库而言，碎片化可能是很讨厌的事情。但是组件将生态系统从 legacy 模式中移除，也会<em>解决</em>一些影响 React 主要库的问题。比如<a href="https://github.com/facebook/react/issues/14536">获取布局时令人迷惑的 Suspense 行为</a>和<a href="https://github.com/facebook/react/issues/15080">缺乏一致性的批处理</a>。legacy 模式下，如果不修改语义就无法修复的许多错误，在 blocking 模式和 concurrent 模式下就不存。<p>你可以把 blocking 模式当作 concurrent 模式的“优雅降级”版本。<strong>所以长远来看，模式的数量会收敛，不用考虑不同的模式。</strong>但就目前而言，模式是一项重要的迁移策略。能让每个人都能决定自己什么时候迁移，并按照自己的速度进行迁移。</section><section id="feature-comparison"class="level3"><h3>特性对比</h3><style>#feature-table table{border-collapse:collapse}#feature-table th{padding-right:30px}#feature-table tr{border-bottom:1px solid #eee}</style><div id="feature-table"><p>| | legacy 模式 | blocking 模式 | concurrent 模式 | | |--- |--- |--- | |<a href="./refs-and-the-dom.html#legacy-api-string-refs">String Refs</a> |✅ |🚫<strong> |🚫</strong> | |<a href="./legacy-context.html">Legacy Context</a> |✅ |🚫<strong> |🚫</strong> | |<a href="./strict-mode.html#warning-about-deprecated-finddomnode-usage">findDOMNode</a> |✅ |🚫<strong> |🚫</strong> | |<a href="./concurrent-mode-suspense.html#what-is-suspense-exactly">Suspense</a> |✅ |✅ |✅ | |<a href="./concurrent-mode-patterns.html#suspenselist">SuspenseList</a> |🚫 |✅ |✅ | |Suspense SSR + Hydration |🚫 |✅ |✅ | |Progressive Hydration |🚫 |✅ |✅ | |Selective Hydration |🚫 |🚫 |✅ | |Cooperative Multitasking |🚫 |🚫 |✅ | |Automatic batching of multiple setStates    |🚫* |✅ |✅ | |<a href="./concurrent-mode-patterns.html#splitting-high-and-low-priority-state">Priority-based Rendering</a> |🚫 |🚫 |✅ | |<a href="./concurrent-mode-intro.html#interruptible-rendering">Interruptible Prerendering</a> |🚫 |🚫 |✅ | |<a href="./concurrent-mode-patterns.html#transitions">useTransition</a> |🚫 |🚫 |✅ | |<a href="./concurrent-mode-patterns.html#deferring-a-value">useDeferredValue</a> |🚫 |🚫 |✅ | |<a href="./concurrent-mode-patterns.html#suspense-reveal-train">Suspense Reveal "Train"</a> |🚫 |🚫 |✅ |</div><p>*：legacy 模式在合成事件中有自动批处理的功能，但仅限于一个浏览器任务。非 React 事件想使用这个功能必须使用 <code>unstable_batchedUpdates</code>。在 blocking 模式和 concurrent 模式下，所有的 <code>setState</code> 在默认情况下都是批处理的。<p>**：会在开发中发出警告。 <span style="float:footnote"><a href="./index.html#toc">Go to TOC</a></span></section></section></section>