<!doctype html><html lang="en"><meta charset="utf-8"><title>Packaging</title><meta name="viewport"content="width=device-width,initial-scale=1"><link rel="stylesheet"href="../../../../../themes/packages/prism-coy-theme/theme_common.css"><section class="level1"aria-labelledby="packaging"><h1 id="packaging">Packaging</h1><p>You can use SvelteKit to build apps as well as component libraries, using the <code>@sveltejs/package</code> package (<code>npm create svelte</code> has an option to set this up for you).<p>When you're creating an app, the contents of <code>src/routes</code> is the public-facing stuff; <a href="modules#$lib"><code>src/lib</code></a> contains your app's internal library.<p>A component library has the exact same structure as a SvelteKit app, except that <code>src/lib</code> is the public-facing bit, and your root <code>package.json</code> is used to publish the package. <code>src/routes</code> might be a documentation or demo site that accompanies the library, or it might just be a sandbox you use during development.<p>Running the <code>svelte-package</code> command from <code>@sveltejs/package</code> will take the contents of <code>src/lib</code> and generate a <code>dist</code> directory (which can be <a href="#options">configured</a>) containing the following:<ul><li>All the files in <code>src/lib</code>. Svelte components will be preprocessed, TypeScript files will be transpiled to JavaScript.<li>Type definitions (<code>d.ts</code> files) which are generated for Svelte, JavaScript and TypeScript files. You need to install <code>typescript >= 4.0.0</code> for this. Type definitions are placed next to their implementation, hand-written <code>d.ts</code> files are copied over as is. You can <a href="#options">disable generation</a>, but we strongly recommend against it — people using your library might use TypeScript, for which they require these type definition files.</ul><blockquote><p><code>@sveltejs/package</code> version 1 generated a <code>package.json</code>. This is no longer the case and it will now use the <code>package.json</code> from your project and validate that it is correct instead. If you're still on version 1, see <a href="https://github.com/sveltejs/kit/pull/8922">this PR</a> for migration instructions.</blockquote><section class="level2"aria-labelledby="anatomy-of-a-packagejson"><h2 id="anatomy-of-a-packagejson">Anatomy of a package.json</h2><p>Since you're now building a library for public use, the contents of your <code>package.json</code> will become more important. Through it, you configure the entry points of your package, which files are published to npm, and which dependencies your library has. Let's go through the most important fields one by one.</section><section class="level2"aria-labelledby="name"><h2 id="name">name</h2><p>This is the name of your package. It will be available for others to install using that name, and visible on <code>https://npmjs.com/package/&#x3C;name></code>.<pre class="language-json"><code class="language-json"><span class="token punctuation">{</span>
	<span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"your-library"</span>
<span class="token punctuation">}</span></code></pre><p>Read more about it <a href="https://docs.npmjs.com/cli/v9/configuring-npm/package-json#name">here</a>.</section><section class="level2"aria-labelledby="license"><h2 id="license">license</h2><p>Every package should have a license field so people know how they are allowed to use it. A very popular license which is also very permissive in terms of distribution and reuse without warranty is <code>MIT</code>.<pre class="language-json"><code class="language-json"><span class="token punctuation">{</span>
	<span class="token property">"license"</span><span class="token operator">:</span> <span class="token string">"MIT"</span>
<span class="token punctuation">}</span></code></pre><p>Read more about it <a href="https://docs.npmjs.com/cli/v9/configuring-npm/package-json#license">here</a>. Note that you should also include a <code>LICENSE</code> file in your package.</section><section class="level2"aria-labelledby="files"><h2 id="files">files</h2><p>This tells npm which files it will pack up and upload to npm. It should contain your output folder (<code>dist</code> by default). Your <code>package.json</code> and <code>README</code> and <code>LICENSE</code> will always be included, so you don't need to specify them.<pre class="language-json"><code class="language-json"><span class="token punctuation">{</span>
	<span class="token property">"files"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"dist"</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span></code></pre><p>To exclude unnecessary files (such as unit tests, or modules that are only imported from <code>src/routes</code> etc) you can add them to an <code>.npmignore</code> file. This will result in smaller packages that are faster to install.<p>Read more about it <a href="https://docs.npmjs.com/cli/v9/configuring-npm/package-json#files">here</a>.</section><section class="level2"aria-labelledby="exports"><h2 id="exports">exports</h2><p>The <code>"exports"</code> field contains the package's entry points. If you set up a new library project through <code>npm create svelte@latest</code>, it's set to a single export, the package root:<pre class="language-json"><code class="language-json"><span class="token punctuation">{</span>
	<span class="token property">"exports"</span><span class="token operator">:</span> <span class="token punctuation">{</span>
		<span class="token property">"."</span><span class="token operator">:</span> <span class="token punctuation">{</span>
			<span class="token property">"types"</span><span class="token operator">:</span> <span class="token string">"./dist/index.d.ts"</span><span class="token punctuation">,</span>
			<span class="token property">"svelte"</span><span class="token operator">:</span> <span class="token string">"./dist/index.js"</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><p>This tells bundlers and tooling that your package only has one entry point, the root, and everything should be imported through that, like this:<pre class="language-js"><code class="language-js"><span class="token comment">// @errors: 2307</span>
<span class="token keyword module">import</span> <span class="token imports"><span class="token punctuation">{</span> <span class="token maybe-class-name">Something</span> <span class="token punctuation">}</span></span> <span class="token keyword module">from</span> <span class="token string">'your-library'</span><span class="token punctuation">;</span></code></pre><p>The <code>types</code> and <code>svelte</code> keys are <a href="https://nodejs.org/api/packages.html#conditional-exports">export conditions</a>. They tell tooling what file to import when they look up the <code>your-library</code> import:<ul><li>TypeScript sees the <code>types</code> condition and looks up the type definition file. If you don't publish type definitions, omit this condition.<li>Svelte-aware tooling sees the <code>svelte</code> condition and knows this is a Svelte component library. If you publish a library that does not export any Svelte components and that could also work in non-Svelte projects (for example a Svelte store library), you can replace this condition with <code>default</code>.</ul><blockquote><p>Previous versions of <code>@sveltejs/package</code> also added a <code>package.json</code> export. This is no longer part of the template because all tooling can now deal with a <code>package.json</code> not being explicitly exported.</blockquote><p>You can adjust <code>exports</code> to your liking and provide more entry points. For example, if instead of a <code>src/lib/index.js</code> file that re-exported components you wanted to expose a <code>src/lib/Foo.svelte</code> component directly, you could create the following export map...<pre class="language-json"><code class="language-json"><span class="token punctuation">{</span>
	<span class="token property">"exports"</span><span class="token operator">:</span> <span class="token punctuation">{</span>
		<span class="token property">"./Foo.svelte"</span><span class="token operator">:</span> <span class="token punctuation">{</span>
			<span class="token property">"types"</span><span class="token operator">:</span> <span class="token string">"./dist/Foo.svelte.d.ts"</span><span class="token punctuation">,</span>
			<span class="token property">"svelte"</span><span class="token operator">:</span> <span class="token string">"./dist/Foo.svelte"</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><p>...and a consumer of your library could import the component like so:<pre class="language-js"><code class="language-js"><span class="token comment">// @filename: ambient.d.ts</span>
declare module <span class="token string">'your-library/Foo.svelte'</span><span class="token punctuation">;</span>

<span class="token comment">// @filename: index.js</span>
<span class="token comment">// cut---</span>
<span class="token keyword module">import</span> <span class="token imports"><span class="token maybe-class-name">Foo</span></span> <span class="token keyword module">from</span> <span class="token string">'your-library/Foo.svelte'</span><span class="token punctuation">;</span></code></pre><blockquote><p>Beware that doing this will need additional care if you provide type definitions. Read more about the caveat <a href="#typescript">here</a></blockquote><p>In general, each key of the exports map is the path the user will have to use to import something from your package, and the value is the path to the file that will be imported or a map of export conditions which in turn contains these file paths.<p>Read more about <code>exports</code> <a href="https://nodejs.org/docs/latest-v18.x/api/packages.html#package-entry-points">here</a>.</section><section class="level2"aria-labelledby="svelte"><h2 id="svelte">svelte</h2><p>This is a legacy field that enabled tooling to recognise Svelte component libraries. It's no longer necessary when using the <code>svelte</code> <a href="#anatomy-of-a-package-json-exports">export condition</a>, but for backwards compatibility with outdated tooling that doesn't yet know about export conditions it's good to keep it around. It should point towards your root entry point.<pre class="language-json"><code class="language-json"><span class="token punctuation">{</span>
	<span class="token property">"svelte"</span><span class="token operator">:</span> <span class="token string">"./dist/index.js"</span>
<span class="token punctuation">}</span></code></pre></section><section class="level2"aria-labelledby="typescript"><h2 id="typescript">TypeScript</h2><p>You should ship type definitions for your library even if you don't use TypeScript yourself so that people who do get proper intellisense when using your library. <code>@sveltejs/package</code> makes the process of generating types mostly opaque to you. By default, when packaging your library, type definitions are auto-generated for JavaScript, TypeScript and Svelte files. All you need to ensure is that the <code>types</code> condition in the <a href="#anatomy-of-a-package-json-exports">exports</a> map points to the correct files. When initialising a library project through <code>npm create svelte@latest</code>, this is automatically setup for the root export.<p>If you have something else than a root export however — for example providing a <code>your-library/foo</code> import — you need to take additional care for providing type definitions. Unfortunately, TypeScript by default will <em>not</em> resolve the <code>types</code> condition for an export like <code>{ "./foo": { "types": "./dist/foo.d.ts", ... }}</code>. Instead, it will search for a <code>foo.d.ts</code> relative to the root of your library (i.e. <code>your-library/foo.d.ts</code> instead of <code>your-library/dist/foo.d.ts</code>). To fix this, you have two options:<p>The first option is to require people using your library to set the <code>moduleResolution</code> option in their <code>tsconfig.json</code> (or <code>jsconfig.json</code>) to <code>bundler</code> (available since TypeScript 5, the best and recommended option in the future), <code>node16</code> or <code>nodenext</code>. This opts TypeScript into actually looking at the exports map and resolving the types correctly.<p>The second option is to (ab)use the <code>typesVersions</code> feature from TypeScript to wire up the types. This is a field inside <code>package.json</code> TypeScript uses to check for different type definitions depending on the TypeScript version, and also contains a path mapping feature for that. We leverage that path mapping feature to get what we want. For the mentioned <code>foo</code> export above, the corresponding <code>typesVersions</code> looks like this:<pre class="language-json"><code class="language-json"><span class="token punctuation">{</span>
	<span class="token property">"exports"</span><span class="token operator">:</span> <span class="token punctuation">{</span>
		<span class="token property">"./foo"</span><span class="token operator">:</span> <span class="token punctuation">{</span>
			<span class="token property">"types"</span><span class="token operator">:</span> <span class="token string">"./dist/foo.d.ts"</span><span class="token punctuation">,</span>
			<span class="token property">"svelte"</span><span class="token operator">:</span> <span class="token string">"./dist/foo.js"</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span><span class="token punctuation">,</span>
	<span class="token property">"typesVersions"</span><span class="token operator">:</span> <span class="token punctuation">{</span>
		<span class="token property">">4.0"</span><span class="token operator">:</span> <span class="token punctuation">{</span>
			<span class="token property">"foo"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"./dist/foo.d.ts"</span><span class="token punctuation">]</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><p><code>>4.0</code> tells TypeScript to check the inner map if the used TypeScript version is greater than 4 (which should in practice always be true). The inner map tells TypeScript that the typings for <code>your-library/foo</code> are found within <code>./dist/foo.d.ts</code>, which essentially replicates the <code>exports</code> condition. You also have <code>*</code> as a wildcard at your disposal to make many type definitions at once available without repeating yourself. Note that if you opt into <code>typesVersions</code> you have to declare all type imports through it, including the root import (which is defined as <code>"index.d.ts": [..]</code>).<p>You can read more about that feature <a href="https://www.typescriptlang.org/docs/handbook/declaration-files/publishing.html#version-selection-with-typesversions">here</a>.</section><section class="level2"aria-labelledby="best-practices"><h2 id="best-practices">Best practices</h2><p>You should avoid using <a href="modules">SvelteKit-specific modules</a> like <code>$app</code> in your packages unless you intend for them to only be consumable by other SvelteKit projects. E.g. rather than using <code>import { browser } from '$app/environment'</code> you could use <code>import { BROWSER } from 'esm-env'</code> (<a href="https://github.com/benmccann/esm-env">see esm-env docs</a>). You may also wish to pass in things like the current URL or a navigation action as a prop rather than relying directly on <code>$app/stores</code>, <code>$app/navigation</code>, etc. Writing your app in this more generic fashion will also make it easier to setup tools for testing, UI demos and so on.<p>Ensure that you add <a href="configuration#alias">aliases</a> via <code>svelte.config.js</code> (not <code>vite.config.js</code> or <code>tsconfig.json</code>), so that they are processed by <code>svelte-package</code>.<p>You should think carefully about whether or not the changes you make to your package are a bug fix, a new feature, or a breaking change, and update the package version accordingly. Note that if you remove any paths from <code>exports</code> or any <code>export</code> conditions inside them from your existing library, that should be regarded as a breaking change.<pre class="language-diff"><code class="language-diff">{
	"exports": {
		".": {
			"types": "./dist/index.d.ts",
// changing `svelte` to `default` is a breaking change:
<span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">			"svelte": "./dist/index.js"
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">			"default": "./dist/index.js"
</span></span>		},
// removing this is a breaking change:
<span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">		"./foo": {
</span><span class="token prefix deleted">-</span><span class="token line">			"types": "./dist/foo.d.ts",
</span><span class="token prefix deleted">-</span><span class="token line">			"svelte": "./dist/foo.js",
</span><span class="token prefix deleted">-</span><span class="token line">			"default": "./dist/foo.js"
</span><span class="token prefix deleted">-</span><span class="token line">		},
</span></span>// adding this is ok:
<span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">		"./bar": {
</span><span class="token prefix inserted">+</span><span class="token line">			"types": "./dist/bar.d.ts",
</span><span class="token prefix inserted">+</span><span class="token line">			"svelte": "./dist/bar.js",
</span><span class="token prefix inserted">+</span><span class="token line">			"default": "./dist/bar.js"
</span><span class="token prefix inserted">+</span><span class="token line">		}
</span></span>	}
}</code></pre></section><section class="level2"aria-labelledby="options"><h2 id="options">Options</h2><p><code>svelte-package</code> accepts the following options:<ul><li><code>-w</code>/<code>--watch</code> — watch files in <code>src/lib</code> for changes and rebuild the package<li><code>-i</code>/<code>--input</code> — the input directory which contains all the files of the package. Defaults to <code>src/lib</code><li><code>-o</code>/<code>--o</code> — the output directory where the processed files are written to. Your <code>package.json</code>'s <code>exports</code> should point to files inside there, and the <code>files</code> array should include that folder. Defaults to <code>dist</code><li><code>-t</code>/<code>--types</code> — whether or not to create type definitions (<code>d.ts</code> files). We strongly recommend doing this as it fosters ecosystem library quality. Defaults to <code>true</code></ul></section><section class="level2"aria-labelledby="publishing"><h2 id="publishing">Publishing</h2><p>To publish the generated package:<pre class="language-sh"><code class="language-sh">npm publish</code></pre></section><section class="level2"aria-labelledby="caveats"><h2 id="caveats">Caveats</h2><p>All relative file imports need to be fully specified, adhering to Node's ESM algorithm. This means that for a file like <code>src/lib/something/index.js</code>, you must include the filename with the extension:<pre class="language-diff"><code class="language-diff"><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">import { something } from './something';
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">import { something } from './something/index.js';</span></span></code></pre><p>If you are using TypeScript, you need to import <code>.ts</code> files the same way, but using a <code>.js</code> file ending, <em>not</em> a <code>.ts</code> file ending. (This is a TypeScript design decision outside our control.) Setting <code>"moduleResolution": "NodeNext"</code> in your <code>tsconfig.json</code> or <code>jsconfig.json</code> will help you with this.<p>All files except Svelte files (preprocessed) and TypeScript files (transpiled to JavaScript) are copied across as-is. <span style="float:footnote"><a href="../../index.html#toc">Go to TOC</a></span></section></section>