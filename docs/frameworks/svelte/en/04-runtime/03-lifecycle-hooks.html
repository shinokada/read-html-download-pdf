<!doctype html><html lang="en"><meta charset="utf-8"><title>Lifecycle hooks</title><meta name="viewport"content="width=device-width,initial-scale=1"><link rel="stylesheet"type="text/css"href="../../../../themes/packages/prism-coy-theme/theme_common.css"><section class="level1"aria-labelledby="lifecycle-hooks"><h1 id="lifecycle-hooks">Lifecycle hooks</h1><ul><li>onMount/onDestroy<li>mention that <code>$effect</code> might be better for your use case<li>beforeUpdate/afterUpdate with deprecation notice?<li>or skip this entirely and only have it in the reference docs?</ul><p>In Svelte 5, the component lifecycle consists of only two parts: Its creation and its destruction. Everything in-between - when certain state is updated - is not related to the component as a whole, only the parts that need to react to the state change are notified. This is because under the hood the smallest unit of change is actually not a component, it's the (render) effects that the component sets up upon component initialization. Consequently, there's no such thing as a "before update"/"after update" hook.<section class="level2"aria-labelledby="onmount"><h2 id="onmount"><code>onMount</code></h2><p>The <code>onMount</code> function schedules a callback to run as soon as the component has been mounted to the DOM. It must be called during the component's initialisation (but doesn't need to live <em>inside</em> the component; it can be called from an external module).<p><code>onMount</code> does not run inside a component that is rendered on the server.<pre class="language-svelte"><code class="language-svelte">&#x3C;script>
	import { onMount } from 'svelte';

	onMount(() => {
		console.log('the component has mounted');
	});
&#x3C;/script></code></pre><p>If a function is returned from <code>onMount</code>, it will be called when the component is unmounted.<pre class="language-svelte"><code class="language-svelte">&#x3C;script>
	import { onMount } from 'svelte';

	onMount(() => {
		const interval = setInterval(() => {
			console.log('beep');
		}, 1000);

		return () => clearInterval(interval);
	});
&#x3C;/script></code></pre><blockquote><p>[!NOTE] This behaviour will only work when the function passed to <code>onMount</code> <em>synchronously</em> returns a value. <code>async</code> functions always return a <code>Promise</code>, and as such cannot <em>synchronously</em> return a function.</blockquote></section><section class="level2"aria-labelledby="ondestroy"><h2 id="ondestroy"><code>onDestroy</code></h2><blockquote><p>EXPORT_SNIPPET: svelte#onDestroy</blockquote><p>Schedules a callback to run immediately before the component is unmounted.<p>Out of <code>onMount</code>, <code>beforeUpdate</code>, <code>afterUpdate</code> and <code>onDestroy</code>, this is the only one that runs inside a server-side component.<pre class="language-svelte"><code class="language-svelte">&#x3C;script>
	import { onDestroy } from 'svelte';

	onDestroy(() => {
		console.log('the component is being destroyed');
	});
&#x3C;/script></code></pre></section><section class="level2"aria-labelledby="tick"><h2 id="tick"><code>tick</code></h2><p>While there's no "after update" hook, you can use <code>tick</code> to ensure that the UI is updated before continuing. <code>tick</code> returns a promise that resolves once any pending state changes have been applied, or in the next microtask if there are none.<pre class="language-svelte"><code class="language-svelte">&#x3C;script>
	import { beforeUpdate, tick } from 'svelte';

	beforeUpdate(async () => {
		console.log('the component is about to update');
		await tick();
		console.log('the component just updated');
	});
&#x3C;/script></code></pre></section><section class="level2"aria-labelledby="deprecated-beforeupdate--afterupdate"><h2 id="deprecated-beforeupdate--afterupdate">Deprecated: <code>beforeUpdate</code> / <code>afterUpdate</code></h2><p>Svelte 4 contained hooks that ran before and after the component as a whole was updated. For backwards compatibility, these hooks were shimmed in Svelte 5 but not available inside components that use runes.<pre class="language-svelte"><code class="language-svelte">&#x3C;script>
	import { beforeUpdate, afterUpdate } from 'svelte';

	beforeUpdate(() => {
		console.log('the component is about to update');
	});

	afterUpdate(() => {
		console.log('the component just updated');
	});
&#x3C;/script></code></pre><p>Instead of <code>beforeUpdate</code> use <code>$effect.pre</code> and instead of <code>afterUpdate</code> use <code>$effect</code> instead - these runes offer more granular control and only react to the changes you're actually interested in.</section><section class="level2"aria-labelledby="chat-window-example"><h2 id="chat-window-example">Chat window example</h2><p>To implement a chat window that autoscrolls to the bottom when new messages appear (but only if you were <em>already</em> scrolled to the bottom), we need to measure the DOM before we update it.<p>In Svelte 4, we do this with <code>beforeUpdate</code>, but this is a flawed approach â€” it fires before <em>every</em> update, whether it's relevant or not. In the example below, we need to introduce checks like <code>updatingMessages</code> to make sure we don't mess with the scroll position when someone toggles dark mode.<p>With runes, we can use <code>$effect.pre</code>, which behaves the same as <code>$effect</code> but runs before the DOM is updated. As long as we explicitly reference <code>messages</code> inside the effect body, it will run whenever <code>messages</code> changes, but <em>not</em> when <code>theme</code> changes.<p><code>beforeUpdate</code>, and its equally troublesome counterpart <code>afterUpdate</code>, are therefore deprecated in Svelte 5.<ul><li><a href="/#H4sIAAAAAAAAE31WXa_bNgz9K6yL1QmWOLlrC-w6H8MeBgwY9tY9NfdBtmlbiywZkpyPBfnvo2zLcZK28AWuRPGI5OGhkEuQc4EmiL9eAskqDOLg97oOZoE9125jDigs0t6oRqfOsjap5rXd7uTO8qpW2sIFEsyVxn_qjFmcAcstar-xPN3DFXKtKgi768IVgQku0ELj3Lgs_kZjWIEGNpAzYXDlHWyJFZI1zJjeh4O5uvl_DY8oUkVeVoFuJKYls-_CGYS25Aboj0EtWNqel0wWoBoLTGZgmdgDS9zW4Uz4NsrswPHoyutN4xInkylstnBxdmIhh8m7xzqmoNE2Wq46n1RJQzEbq4g-JQSl7e-HDx-GdaTy3KD9E3lRWvj5Zu9QX1QN20dj7zyHz8s-1S6lW7Cpz3RnXTcm04hIlfdFuO8p2mQ5-3a06cqjrn559bF_2NHOnRZ5I1PLlXQNyQT-hedMHeUEDyjtdMxsa4n2eIbNhlTwhyRthaOKOmYtniwF6pwt0wXa6MBEg0OibZec27gz_dk3UrZ6hB2LLYoiv521Yd8Gt-foTrfhiCDP0lC9VUUhcDLU49Xe_9943cNvEArHfAjxeBTovvXiNpFynfEDpIIZs9kFbg52QbeNHWZzebz32s7xHco3nJAJl1nshmhz8dYOQJDyZetnbb2gTWe-vEeWlrfpZMavr56ldb29eNt6UXvgwgFbp_WC0tl2RK25rGk6lYz3nUI2lzvBXGHhPZPGWmKUXFNBKqdaW259wl_aHbiqoVIZdpE60Nax6IOujT0LbFFxIVTCxCRR2XloUcYNvSbnGHKBp763jHoj59xiZWJI0Wm0P_m3MSS985xkasn-cFq20xTDy3J5KFcjgUTD69BHdcHIjz431z28IqlxGcPSfdFnrGDZn6gD6lyo45zyHAD-btczf-98nhQxHEvKfeUtOVkSejD3q-9X7JbzjGtsdUxlKdFU8qGsT78uaw848syWMXz85Waq2Gnem4mAn3prweq4q6Y3JEpnqMmnPoFRgmd3ySW0LLRqSKlwYHriCvJvUs2yjMaaoA-XzTXLeGMe45zmhv_XAno3Mj0xF7USuqNvnE9H343QHlq-eAgxpbTPNR9yzUkgLjwSR0NK4wKoxy-jDg-9vy8sUSToakzW-9fX13Em9Q8T6Z26uZhBN36XUYo5q7ggLXBZoub2Ofv7g6GCZfTxe034NCjiudXj7Omla0eTfo7QBPOcYxbE7qG-vl3_B1G-_i_JCAAA">Before</a><li><a href="/#H4sIAAAAAAAAE31WXa-jNhD9K7PsdknUQJLurtRLPqo-VKrU1327uQ8GBnBjbGSb5KZR_nvHgMlXtyIS9njO-MyZGZRzUHCBJkhez4FkNQZJ8HvTBLPAnhq3MQcUFmlvVKszZ1mbTPPGbndyZ3ndKG3hDJZne7hAoVUNYY8JV-RBPgIt2AprhA18MpZZnIQ50_twuvLHNRrDSjRXj9fwiCJTBLIKdCsxq5j9EM4gtBU3QD8GjWBZd14xWYJqLTCZg2ViDyx1W4cz4dv0hsiB49FRHkyfsCgws3GjcTKZwmYLZ2feWc9o1W8zJQ2Fb62i5JUQRNRHgs-fx3WsisKg_RN5WVn4-WrvUd9VA9tH4-AcwbfFQIpkLWByvWzqSe2sk3kyjUlOec_XPU-3TRaz_75tuvKoi19e3OvipSpamVmupJM2F_gXnnJ1lBM8oLQjHceys8R7PMFms4HwD2lRhzeEe-EsvluSrHe2TJdo4wMTLY48XKwPzm0KGm2r5ajFtRYU4TWOY7-ddWHfxhDP0QkQhnf5PWRnVVkKnIx8fZsOb5dR16nwG4TCCRdCMphWQ7z1_DoOcp3zA2SCGbPZBa5jd0G_TRxmc36Me-mG6A7l60XIlMs8ce2-OXtrDyBItdz6qVjPadObzx-RZdV1nJjx64tXad1sz962njceOHfAzmk9JzrbXqg1lw3NkZL7vgE257t-uMDcO6attSSokpmgFqVMO2U93e_dDlzOUKsc-3t6zNZp6K9cG3sS2KGSUqiUiUmq8tNYoJwbmvpTAoXA96GyjCojI26xNglk6DpwOPm7NdRYp4ia0JL94bTqRiGB5WJxqFY37RGPoz3c6i4jP3rcUA7wmhqNywQW7om_YQ2L4UQdUBdCHSPiOQJ8bFcxHzeK0jKBY0XcV95SkCWlD9t-9eOM3TLKucauiyktJdpaPqT19ddF4wFHntsqgS-_XE01e48GMwnw02AtWZP02QyGVOkcNfk072CU4PkduZSWpVYt9SkcmJ64hPwHpWF5ziVls3wIFmmW89Y83vMeGf5PBxjcyPSkXNy10J18t3x6-a6CDtBq6SGklNKeazFyLahB3PVIGo2UbhOgGi9vKjzW_j6xVFFD17difXx5ebll0vwvkcGpn4sZ9MN3vqFYsJoL6gUuK9TcPrO_PxgzWMRfflSEr2NHPJf6lj1957rRpH8CNMG84JgHidUtXt4u_wK21LXERAgAAA==">After</a></ul><pre class="language-svelte"><code class="language-svelte">&#x3C;script>
	import { beforeUpdate, afterUpdate,--- tick } from 'svelte';

	let updatingMessages = false;---
	let theme = +++$state('dark')+++;
	let messages = +++$state([])+++;

	let viewport;

	beforeUpdate(() => {---
	+++$effect.pre(() => {+++
		if (!updatingMessages) return;---
		+++messages;+++
		const autoscroll = viewport &#x26;&#x26; viewport.offsetHeight + viewport.scrollTop > viewport.scrollHeight - 50;

		if (autoscroll) {
			tick().then(() => {
				viewport.scrollTo(0, viewport.scrollHeight);
			});
		}

		updatingMessages = false;---
	});

	function handleKeydown(event) {
		if (event.key === 'Enter') {
			const text = event.target.value;
			if (!text) return;

			updatingMessages = true;---
			messages = [...messages, text];
			event.target.value = '';
		}
	}

	function toggle() {
		toggleValue = !toggleValue;
	}
&#x3C;/script>

&#x3C;div class:dark={theme === 'dark'}>
	&#x3C;div bind:this={viewport}>
		{#each messages as message}
			&#x3C;p>{message}&#x3C;/p>
		{/each}
	&#x3C;/div>

	&#x3C;input +++onkeydown+++={handleKeydown} />

	&#x3C;button +++onclick+++={toggle}> Toggle dark mode &#x3C;/button>
&#x3C;/div></code></pre><p><span style="float:footnote"><a href="../index.html#toc">Go to TOC</a></span></section></section>